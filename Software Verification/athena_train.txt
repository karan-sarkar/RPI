conclude right-identity := (forall p . p + zero = p)
  pick-any p
    let {lemma :=  
          pick-any i
	    (!chain 
	     [(Apply (p + zero) i) 
	      = ((Apply p i) +' (Apply zero i))  [definition]
	      = ((Apply p i) +' zero')           [zero-definition]
	      = (Apply p i)                      [Z.Plus.Right-Identity]])}
    (!chain-> [lemma ==> (p + zero = p)    [equality]])

conclude left-identity := (forall p . zero + p = p)
  pick-any p
    let {lemma :=   
          pick-any i
	    (!chain 
	     [(Apply (zero + p) i) 
	      = ((Apply zero i) +' (Apply p i))  [definition]
	      = (zero' +' (Apply p i))           [zero-definition]
	      = (Apply p i)                      [Z.Plus.Left-Identity]])}
    (!chain-> [lemma ==> (zero + p = p)    [equality]])

conclude commutative := (forall p q . p + q = q + p)
  pick-any p:(Fun N Z) q:(Fun N Z)
    let {lemma :=
          pick-any i:N
            (!chain [(Apply (p + q) i)
		     = ((Apply p i) +' (Apply q i))   [definition]
		     = ((Apply q i) +' (Apply p i))   [Z.Plus.commutative]
		     = (Apply (q + p) i)              [definition]])}
    (!chain-> [lemma ==> (p + q = q + p)        [equality]])
    
conclude associative := (forall p q r . (p + q) + r = p + (q + r))
  pick-any p:(Fun N Z) q:(Fun N Z) r:(Fun N Z) 
    let {lemma := 
          pick-any i:N
            (!chain 
	     [(Apply ((p + q) + r) i)
	      = ((Apply (p + q) i) +' (Apply r i))            [definition]
	      = (((Apply p i) +' (Apply q i)) +' (Apply r i)) [definition]
	      = ((Apply p i) +' ((Apply q i) +' (Apply r i)))  
                                                      [Z.Plus.associative]
	      = ((Apply p i) +' (Apply (q + r)  i))           [definition]
	      = (Apply (p + (q + r)) i)                       [definition]])}
    (!chain-> [lemma ==> ((p + q) + r = p + (q + r))     [equality]])

conclude right-inverse := (forall p . p + (Negate p) = zero)
  pick-any p
    let {lemma := 
           pick-any i
             (!chain 
	      [(Apply (p + (Negate p)) i)
	       = ((Apply p i) +' (Apply (Negate p) i))   [definition]
	       = ((Apply p i) +' Z.negate (Apply p i))   [Negate.definition]
	       = zero'                                   [Z.Plus.Right-Inverse]
	       = (Apply zero i)                          [zero-definition]])}
    (!chain-> [lemma ==> ((p + (Negate p)) = zero)  [equality]])

conclude left-inverse := (forall p . (Negate p) + p = zero)
  pick-any p
    (!chain [((Negate p) + p)
	     = (p + (Negate p))   [commutative]
	     = zero               [right-inverse]])

conclude rc1 := (forall m x . (m - x) at x = default m)
by-induction rc1 {
  (m as (empty-map d)) => 
     pick-any x
      (!chain [(m - x at x)
             = (m at x)      [remove-def]
             = d             [apply-def]
             = (default m)   [default-def]])
| (m as (update (pair k:'S v) rest)) =>
    let {IH := (forall x . rest - x at x = default rest)}
      pick-any x:'S
        (!two-cases
           assume (k = x) 
            (!chain [(m - x at x) 
                   = (m - k at k)   [(k = x)] 
                   = (rest - k at k)   [remove-def]
                   = (default rest)    [IH]
                   = (default m)       [default-def]
                    ])
           assume (k =/= x)  
             (!chain [(m - x at x) 
                    = ((k @ v) ++ (rest - x) at x)  [remove-def]
                    = (rest - x at x)               [apply-def]
                    = (default rest)                [IH]
                    = (default m)                   [default-def]]))
                    
conclude rc2 := (forall m k x . k =/= x ==> m - k at x = m at x)
by-induction rc2 {
 (m as (empty-map d:'V)) => 
   pick-any k:'K x:'K  
     assume (k =/= x)
       let {L := (m - k at x);
            R := (m at x)}
         (!chain [L 
                = (m at x)  [remove-def]])
| (m as (update (pair key:'K val:'V) rest:('K 'V))) =>  
   pick-any k:'K x:'K  
     assume (k =/= x)
       let {IH := (forall k x . k =/= x ==> (rest - k) at x = rest at x)}
         (!two-cases 
           assume (key = k)
            let {_ := (!by-contradiction (key =/= x)
                        (!chain [(key = x)
                             ==> (k = x)           [(key = k)]
                             ==> (k = x & k =/= x) [augment]
                             ==> false             [prop-taut]]))}
            (!chain [(m - k at x) 
                   = (((k @ val) ++ rest) - k at x)  [(key = k)]
                   = (rest - k at x)  [remove-def]
                   = (rest at x)      [IH]
                   = (m at x)         [apply-def]])
           assume (key =/= k) 
             (!two-cases
                assume (x = key)
                  (!chain [(m - k at x) 
                        = (([key val] ++ (rest - k)) at x)   [remove-def]
                        = (([x val] ++ (rest - k)) at x)   [(x = key)]
                        = val                              [apply-def]
                        = (([x val] ++ rest) at x)         [apply-def]
                        = (m at x)                          [(x = key)]])
                assume (x =/= key)            
                  (!chain [(m - k at x)                   
                        = (([key val] ++ (rest - k)) at x)   [remove-def]
                        = (rest - k at x)                    [apply-def]
                        = (rest at x)                        [IH]
                        = (m at x)                           [apply-def]])))
}

conclude rc3 := (forall m k . default m = default m - k)
by-induction rc3 {
  (m as (empty-map d:'V)) =>
     pick-any k
       (!chain [(default m)
              = (default m - k) [remove-def]])              
 | (m as (update (pair key:'K val:'V) rest)) =>   
     let {IH := (forall k . default rest = default rest - k)}
     pick-any k:'K
       (!two-cases
          assume (key = k) 
           (!combine-equations 
             (!chain [(default m) 
                    = (default rest)      [default-def]
                    = (default rest - k)  [IH]])
             (!chain [(default m - k) 
                    = (default rest - k)  [remove-def]]))
          assume (key =/= k) 
            (!chain-> [(default m - k)
                     = (default key @ val ++ rest - k) [remove-def]
                     = (default rest - k)              [default-def]
                     = (default rest)                  [IH]
                     = (default m)                     [default-def]
                   ==> (default m - k = default m) 
                   ==> (default m = default m - k)     [sym]]))
}

conclude dom-lemma-1 := (forall k v rest . v =/= default rest ==> k in dom [k v] ++ rest)
    pick-any k v rest
      assume hyp := (v =/= default rest)
      (!chain-> [true ==> (k in k ++ dom rest)     [Set.in-lemma-1]
                      ==> (k in dom [k v] ++ rest) [dom-def]])
                      
conclude dom-lemma-2 := (forall m k v . v =/= default m ==> dom m subset dom [k v] ++ m)
    pick-any m k v
      assume hyp := (v =/= default m)
      (!Set.subset-intro
         pick-any x
            (!chain [(x in dom m)
                 ==> (x in k ++ dom m)      [Set.in-lemma-3]
                 ==> (x in dom [k v] ++ m)  [dom-def]]))

conclude dom-lemma-2c := forall m x k v . x in dom [k v] ++ m ==> x = k | x in dom m - k)
 pick-any m:('K 'V) x:'K k:'K v:'V 
   assume hyp := (x in dom [k v] ++ m)
     (!two-cases
       assume (v = default m)
         (!chain-> [hyp
                ==> (x in dom m - k)         [dom-def]
                ==> (x = k | x in dom m - k) [prop-taut]])
       assume (v =/= default m)
         (!chain-> [hyp
                ==> (x in k ++ dom m)         [dom-def]
                ==> (x = k | x in dom m - k)      [Set.in-def]]))

conclude len-lemma-1 := (forall m k v . len m < len (k @ v) ++ m)
by-induction len-lemma-1 {
  (m as (empty-map d:'V)) =>
    pick-any k v
      let {len-left :=  (!chain [(len m) = zero               [len-def]]);
           len-right := (!chain [(len k @ v ++ m) = (S len m) [len-def]])}
       (!chain-> [true 
              ==> (zero < S len m)         [N.Less.<-def]
              ==> (len m < len k @ v ++ m) [len-left len-right]])
 | (m as (update (pair key:'K val:'V) rest)) => 
     let {IH := (forall k v . len rest < len k @ v ++ rest)}
       pick-any k:'K v:'V
         let {len-left := (!chain [(len m)
                                 = (S len rest)  [len-def]]);
              len-right := (!chain [(len k @ v ++ m)
                                  = (S len m)      [len-def]
                                  = (S S len rest) [len-left]])}
          (!chain-> [true
                 ==> (S len rest < S S len rest)  [N.Less.<S]
                 ==> (len m < len k @ v ++ m)     [len-left len-right]])
}

conclude len-lemma-2 := (forall m k . len m - k <= len m)
by-induction len-lemma-2 {
  (m as (empty-map d:'V)) =>
    pick-any k
    (!chain-> [(len m - k)
             = (len m)             [remove-def]
          ==>  (len m - k <= len m) [N.Less=.<=-def]])
 | (m as (update (pair key:'K val:'V) rest)) =>
     pick-any k:'K  
       let {IH := (forall k . len rest - k <= len rest);
            L2 := (!chain-> [true ==> (len rest - k <= len rest) [IH]]);
            L3 := (!chain-> [true ==> (len rest < len m)         [len-lemma-1]]);
            L4 := (!chain-> [L2 ==> (L2 & L3)                    [augment]
                                ==> (len rest - k < len m)       [N.Less=.transitive2]])}
       (!two-cases
         assume (key = k)
           (!chain-> [(len m - k)
                    = (len rest - k)                   [remove-def]
                  ==> (len m - k <= len rest - k)      [N.Less=.<=-def]
                  ==> (len m - k <= len rest - k & L2) [augment]
                  ==> (len m - k <= len rest)          [N.Less=.transitive]
                  ==> (len m - k <= len rest & L3)     [augment]
                  ==> (len m - k < len m)              [N.Less=.transitive2]
                  ==> (len m - k <= len m)             [N.Less=.<=-def]])
         assume (key =/= k)
           let {L5 := (!chain-> [(len m - k)
                               = (len [key val] ++ (rest - k)) [remove-def]
                               = (S len rest - k)              [len-def]])}
              (!chain-> [L4
                     ==> (S len rest - k <= len m)  [N.Less=.discrete]
                     ==> (len m - k <= len m)       [L5]]))
}

conclude len-lemma-3 := (forall key val k rest . len rest - k < len key @ val ++ rest)
  pick-any key:'K val:'V k:'K rest:('K 'V)
    let {m := (key @ val ++ rest);
         L := (!chain-> [true 
                     ==> (len rest - k <= len rest) [len-lemma-2]])}
      (!chain-> [true 
             ==> (len rest < len m)         [len-lemma-1]
             ==> (L & len rest < len m)     [augment]
             ==> (len rest - k < len m)     [N.Less=.transitive2]])

conclude lemma-D := (forall m k . k in dom m <==> m at k =/= default m)
(!strong-induction.measure-induction lemma-D len 
pick-any m:('K 'V)
  assume IH := (forall m' . len m' < len m ==> lemma-D-property m')
    conclude (lemma-D-property m)      
      datatype-cases (lemma-D-property m) on m  {
        (em as (empty-map d:'V)) => 
         pick-any k
           (!equiv
             (!chain [(k in dom em)
                  ==> (k in null)   [dom-def]
                  ==> false         [Set.NC]
                  ==> (em at k =/= default em) [prop-taut]])
             assume h := (em at k =/= default em)
               (!by-contradiction (k in dom em)
                 assume (~ k in dom em)
                   (!absurd (!reflex (default em))
                            (!chain-> [h ==> (d =/= default em)         [apply-def]
                                         ==> (default em =/= default em) [default-def]]))))
      | (map as (update (pair key:'K val:'V) rest)) =>   
          pick-any k:'K
            let {lemma1 := (!chain-> [true ==> (len rest - key < len map) [len-lemma-3]
                                           ==> (len rest - key < len m)   [(m = map)]]);
                 lemma2 := (!chain-> [true ==> (len rest < len map) [len-lemma-1]
                                           ==> (len rest < len m)   [(m = map)]])}
            (!equiv
              assume hyp := (k in dom map)
               (!two-cases
                 assume (val = default rest)
                   let {L1 := (!by-contradiction (k =/= key)
                                 assume (k = key)
                                  (!absurd 
                                   (!chain [(rest - key at key)
                                          = (default rest)  [rc1]
                                          = (default rest - key) [rc3]])
                                   (!chain-> [(k in dom map)
                                          ==> (key in dom map)        [(k = key)]
                                          ==> (key in dom rest - key) [dom-def]
                                          ==> (rest - key at key =/= default rest - key) [IH]])));
                        _ := (!ineq-sym L1)}
                     (!chain-> [(k in dom map)
                            ==> (k in dom rest - key)  [dom-def]
                            ==> (rest - key at k =/= default rest - key)  [IH]
                            ==> (rest - key at k =/= default rest)        [rc3]
                            ==> (rest - key at k =/= default map)         [default-def]
                            ==> (rest at k =/= default map)               [rc2]
                            ==> (map at k =/= default map)               [apply-def]])
                 assume case2 := (val =/= default rest)
                  let {M := method ()
                             (!chain-> [(map at k) = (map at key)     [(k = key)]
                                                   = val              [apply-def]
                                    ==> (map at k =/= default rest)   [case2]
                                    ==> (map at k =/= default map)    [default-def]])}
                   (!cases (!chain-> [hyp
                                   ==> (k in key ++ dom rest)    [dom-def] 
                                   ==> (k = key | k in dom rest) [Set.in-def]])
                      assume (k = key) 
                        (!M)
                      assume (k in dom rest)
                        (!two-cases
                          assume (k = key)
                            (!M)
                          assume (k =/= key)
                            (!chain-> [(k in dom rest) 
                                   ==> (rest at k =/= default rest) [IH]
                                   ==> (map at k  =/= default rest) [apply-def]
                                   ==> (map at k  =/= default map)  [default-def]]))))
              assume hyp := (map at k =/= default map)
                (!two-cases
                   assume case1 := (val = default rest)
                    let {k=/=key := (!by-contradiction (k =/= key)
                                       assume (k = key)
                                        let {p := (!chain [(map at k)
                                                         = (map at key)   [(k = key)]
                                                         = val            [apply-def]
                                                         = (default rest) [case1]
                                                         = (default map)  [default-def]])}
                                        (!absurd p hyp))}
                      (!chain-> [hyp 
                             ==> (rest at k =/= default map) [apply-def] 
                             ==> ((rest - key) at k =/= default map) [rc2]
                             ==> ((rest - key) at k =/= default rest) [default-def]
                             ==> ((rest - key) at k =/= default rest - key) [rc3]
                             ==> (k in dom rest - key)                      [IH]
                             ==> (k in dom map)                             [dom-def]])
                   assume case2 := (val =/= default rest)
                       (!two-cases
                         assume (k = key)
                           (!chain<- [(k in dom map)
                                  <== (key in dom map) [(k = key)]
                                  <== (key in key ++ dom rest) [dom-def]
                                  <== true                     [Set.in-lemma-1]])
                         assume (k =/= key)
                           (!chain-> [hyp
                                  ==> (rest at k =/= default map)  [apply-def]
                                  ==> (rest at k =/= default rest) [default-def]
                                  ==> (k in dom rest)              [IH]
                                  ==> (k = key | k in dom rest)    [prop-taut]
                                  ==> (k in key ++ dom rest)       [Set.in-def]
                                  ==> (k in dom map)               [dom-def]])))
       )
     })

conclude rc0 := (forall m x . ~ x in dom m - x)
  pick-any m:('K 'V)  x:'K
    (!by-contradiction (~ x in dom m - x)
      assume hyp := (x in dom m - x)
       (!absurd (!chain-> [true ==> (m - x at x = default m) [rc1]])
                (!chain-> [hyp 
                       ==> (m - x at x =/= default m - x)   [lemma-D]
                       ==> (m - x at x =/= default m)       [rc3]])))

conclude dom-corrolary-1 := (forall key val k rest  . k in dom rest - key ==> k in dom [key val] ++ rest)
    pick-any key:'K val:'V k:'K rest:('K 'V)
       let {L1 := (!chain-> [true ==> (dom rest - key subset dom rest)         [dom-lemma-3]])}
         (!two-cases
           assume (val = default rest)
             (!chain [(k in dom rest - key)
                  ==> (k in dom [key val] ++ rest) [dom-def]])
           assume (val =/= default rest)
             (!chain [(k in dom rest - key)
                  ==> (k in dom rest)              [Set.SC]
                  ==> (k = key | k in dom rest)    [prop-taut]
                  ==> (k in key ++ dom rest)       [Set.in-def]
                  ==> (k in dom [key val] ++ rest) [dom-def]]))

conclude ms-lemma-1 := (forall m k v . k @ v in dmap->set m ==> k in dom m)
(!strong-induction.measure-induction ms-lemma-1 len 
  pick-any m:('K 'V)
    assume IH := (forall m' . len m' < len m ==> ms-lemma-1-property m')
      conclude (ms-lemma-1-property m)      
	   datatype-cases (ms-lemma-1-property m) on m  {
             (em as (empty-map d:'V)) => 
               pick-any k v:'V
                 (!chain [(k @ v in dmap->set em)
                      ==> (k @ v in Set.null)     [dmap->set-def]
                      ==> false                    [Set.NC]
                      ==> (k in dom em)             [prop-taut]])
          | (map as (update (pair key:'K val:'V) rest)) =>   
               pick-any k:'K v:'V     
                let {goal := (k @ v in dmap->set map ==> k in dom map);
                     lemma1 := (!chain-> [true ==> (len rest - key < len map) [len-lemma-3]
                                               ==> (len rest - key < len m)   [(m = map)]]);
                     lemma2 := (!chain-> [true ==> (len rest < len map) [len-lemma-1]
                                               ==> (len rest < len m)   [(m = map)]])}
                 (!two-cases
                   assume C1 := (val = default rest)
                     (!chain [(k @ v in dmap->set map)
                          ==> (k @ v in dmap->set rest - key)  [dmap->set-def]
                          ==> (k in dom rest - key)            [IH]
                          ==> (k in dom map)                   [dom-def]])
                   assume C2 := (val =/= default rest)
                     let {_ := (!chain-> [true ==> (dom rest - key subset dom rest) [dom-lemma-3]])}
                     (!chain [(k @ v in dmap->set map)
                          ==> (k @ v in key @ val ++ dmap->set rest - key) [dmap->set-def]
                          ==> (k @ v = key @ val | k @ v in dmap->set rest - key) [Set.in-def]
                          ==> (k = key & v = val | k @ v in dmap->set rest - key) [pair-axioms]
                          ==> (k = key | k @ v in dmap->set rest - key)           [prop-taut]
                          ==> (k = key | k in dom rest - key)                     [IH]
                          ==> (k = key | k in dom rest)                           [Set.SC]
                          ==> (k in key ++ dom rest)                              [Set.in-def]
                          ==> (k in dom map)                                      [dom-def]])
          )
        })

conclude dom-corrolary-1 := (forall key val k rest  . k in dom rest - key ==> k in dom [key val] ++ rest)
 pick-any key:'K val:'V k:'K rest:('K 'V)
    let {L1 := (!chain-> [true ==> (dom rest - key subset dom rest)         [dom-lemma-3]])}
      (!two-cases
        assume (val = default rest)
          (!chain [(k in dom rest - key)
               ==> (k in dom [key val] ++ rest) [dom-def]])
        assume (val =/= default rest)
          (!chain [(k in dom rest - key)
               ==> (k in dom rest)              [Set.SC]
               ==> (k = key | k in dom rest)    [prop-taut]
               ==> (k in key ++ dom rest)       [Set.in-def]
               ==> (k in dom [key val] ++ rest) [dom-def]]))

conclude agreement-characterization := (forall A m1 m2 . (agree-on m1 m2 A) <==> forall k . k in A ==> m1 at k = m2 at k)
by-induction agreement-characterization {
  (A as Set.null:(Set.Set 'K)) =>  
    pick-any m1:('K 'V) m2:('K 'V)
      let {p1 := assume (agree-on m1 m2 A)
                  pick-any k:'K
                    (!chain [(k in A)
                         ==> false                [Set.NC]
                         ==> (m1 at k = m2 at k)  [prop-taut]]);
           p2 := assume (forall k . k in A ==> m1 at k = m2 at k)
                  (!chain-> [true ==> (agree-on m1 m2 A) [agree-on-def]])}
       (!equiv p1 p2)
| (A as (Set.insert h:'K t:(Set.Set 'K))) =>
    let {IH := (forall m1 m2 . (agree-on m1 m2 t) <==> forall k . k in t ==> m1 at k = m2 at k)}
    pick-any m1:('K 'V) m2:('K 'V)
      let {p1 := assume hyp := (agree-on m1 m2 A)
                  pick-any k:'K
                    assume (k in A) 
                      (!cases (!chain-> [(k in A)
                                     ==> (k = h | k in t)  [Set.in-def]])
                        assume (k = h)
                          (!chain-> [hyp
                                 ==> (m1 at h = m2 at h)    [agree-on-def]
                                 ==> (m1 at k = m2 at k)    [(k = h)]])
                        assume (k in t)
                         let {P := (!chain-> [hyp
                                          ==> (agree-on m1 m2 t)                        [agree-on-def]
                                          ==> (forall k . k in t ==> m1 at k = m2 at k) [IH]])}
                          (!chain-> [(k in t) ==> (m1 at k = m2 at k) [P]]));
           p2 := assume hyp := (forall k . k in A ==> m1 at k = m2 at k)
                   let {L1 := (!chain-> [true
                                     ==> (h in A)            [Set.in-lemma-1]
                                     ==> (m1 at h = m2 at h) [hyp]]);
                        L2 := pick-any k:'K
                                (!chain [(k in t)
                                     ==> (k in A)             [Set.in-def]
                                     ==> (m1 at k = m2 at k)       [hyp]]);
                        L3 := (!chain-> [L2 ==> (agree-on m1 m2 t) [IH]])}
                    (!chain-> [L1 
                          ==> (L1 & L3)           [augment]
                          ==> (agree-on m1 m2 A)  [agree-on-def]])}
        (!equiv p1 p2)
}

conclude downward-agreement-lemma := (forall B A m1 m2 . (agree-on m1 m2 A) & B subset A ==> (agree-on m1 m2 B))
    pick-any B:(Set.Set 'K) A:(Set.Set 'K) m1:('K 'V) m2:('K 'V)
      assume hyp := ((agree-on m1 m2 A) & B subset A)
        let {L := pick-any k:'K
                    assume hyp := (k in B)
                      (!chain-> [hyp 
                             ==> (k in A) [Set.SC]
                             ==> (m1 at k = m2 at k)  [AGC]])}
          (!chain-> [L ==> (agree-on m1 m2 B) [AGC]])

conclude ms-lemma-1b := (forall m k . ~ k in dom m ==> forall v . ~ k @ v in dmap->set m)
by-induction ms-lemma-1b {
  (m as (empty-map d:'V)) =>
     pick-any k
      assume hyp := (~ k in dom m)
        pick-any v:'V 
          (!by-contradiction (~ k @ v in dmap->set m)
             (!chain [(k @ v in dmap->set m)
                  ==> (k @ v in Set.null)     [dmap->set-def]
                  ==> false                    [Set.NC]]))
| (m as (update (pair key:'K val:'V) rest)) =>
    let {IH :=  (forall k . ~ k in dom rest ==> forall v . ~ k @ v in dmap->set rest)}
      pick-any k
        assume hyp := (~ k in dom m)
          pick-any v:'V 
            (!by-contradiction (~ k @ v in dmap->set m)
               assume sup := (k @ v in dmap->set m)
               (!two-cases 
                assume (val = default rest)
                  (!chain-> [sup
                         ==> (k @ v in dmap->set rest - key)  [dmap->set-def]
                         ==> (k in dom rest - key)            [ms-lemma-1]
                         ==> (k in dom m)                     [dom-corrolary-1]
                         ==> (k in dom m & hyp)               [augment]
                         ==> false                            [prop-taut]])
                assume (val =/= default rest)
                let {C := 
                      (!chain-> [sup 
                             ==> (k @ v in key @ val Set.++ dmap->set rest - key)    [dmap->set-def]
                             ==> (k @ v = key @ val | k @ v in dmap->set rest - key)  [Set.in-def]]);
                     _ := (!chain-> [true ==> (dom rest - key Set.subset dom rest)   [dom-lemma-3]])
                    }
                 (!cases C
                   assume case1 := (k @ v = key @ val)
                     let {L := (!chain-> [(val =/= default rest)
                                      ==> (key in dom m)         [dom-lemma-1]])}
                     (!chain-> [case1
                            ==> (k = key & v = val)         [pair-axioms]
                            ==> (k = key)                   [left-and]
                            ==> (k in dom m)                [L]
                            ==> (k in dom m & ~ k in dom m) [augment] 
                            ==> false                       [prop-taut]])
                   assume case2 := (k @ v in dmap->set rest - key)
                     (!chain-> [case2
                            ==> (k in dom rest - key)       [ms-lemma-1]
                            ==> (k in dom rest)             [Set.SC]
                            ==> (k in key Set.++ dom rest) [Set.in-lemma-3]
                            ==> (k in dom m)                [dom-def]
                            ==> (k in dom m & ~ k in dom m) [augment]
                            ==> false                       [prop-taut]]))))
}

conclude ms-lemma-1b' := (forall m k . ~ k in dom m ==> ~ exists v . k @ v in >set m)
pick-any m:('K 'V) k:'K
  assume h := (~ k in dom m)
    let {p := (!chain-> [h ==> (forall v . ~ k @ v in >set m) [ms-lemma-1b]])}
      (!by-contradiction (~ exists v . k @ v in >set m)
        assume hyp := (exists v . k @ v in >set m)
          pick-witness w for hyp wp
            (!absurd wp (!chain-> [true ==> (~ k @ w in >set m) [p]])))

conclude ms-theorem-1 := (forall m k v . k @ v in dmap->set m ==> m at k = v)
(!strong-induction.measure-induction ms-theorem-1 len 
    pick-any m:('K 'V)
      assume IH := (forall m' . len m' < len m ==> property m')
        conclude (property m)      
	  datatype-cases (property m) on m  {
            (em as (empty-map d:'V)) =>
               pick-any k:'K v:'V              
                 (!chain [(k @ v in >set em)
                      ==> (k @ v in Set.null)    [>set-def]
                      ==> false                   [Set.NC]
                      ==> (em at k = v)           [prop-taut]])
          | (map as (update (pair key:'K val:'V) rest)) =>   
               pick-any k:'K v:'V     
                let {goal := (k @ v in >set map ==> map at k = v);
                     lemma1 := (!chain-> [true ==> (len rest - key < len map) [len-lemma-3]
                                               ==> (len rest - key < len m)   [(m = map)]]);
                     lemma2 := (!chain-> [true ==> (len rest < len map) [len-lemma-1]
                                               ==> (len rest < len m)   [(m = map)]]);
                     M := method (case)
		               L1 := (!chain-> [case ==> (k in dom rest - key)  [ms-lemma-1]]);
                               L2 := (!by-contradiction (k =/= key)
                                       assume (k = key)
                                         (!absurd (!chain-> [true ==> (~ key in dom rest - key) [rc0]
                                                                  ==> (~ k in dom rest - key)   [(k = key)]])
                                                  L1));
                               _ := (!ineq-sym L2)} 
                            (!chain-> [(key =/= k)
                                   ==> (rest - key at k = rest at k)  [rc2]
                                   ==> (v = rest at k)                [L]
                                   ==> (rest at k = v)                [sym]
                                   ==> (map at k = v)                 [apply-def]])}
                (!two-cases
                 assume (val = default rest)
                   assume hyp := (k @ v in >set map)
                     let {L := (!chain-> [hyp ==> (k @ v in >set rest - key) [>set-def]])}
                       (!M L)
                 assume (val =/= default rest)
                 assume (k @ v in >set map)
                   let {D := (!chain-> [(k @ v in >set map)
                                  ==> (k @ v in (key @ val) ++ >set (rest - key))  [>set-def]
                                  ==> (k @ v = key @ val | k @ v in >set (rest - key)) [Set.in-def]])}
                  (!cases D
                    assume case1 := (k @ v = key @ val)
                      let {
                           L1 := (!chain-> [case1
                                        ==> (k = key & v = val)  [pair-axioms]]);
                           L2 := (!chain-> [(k = key) ==> (key = k) [sym]]);
                           L3 := (!chain-> [(v = val) ==> (val = v) [sym]])
                          } 
                        (!chain-> [(key = k)
                               ==> (map at k = val)   [apply-def]
                               ==> (map at k = v)     [(val = v)]])
                    assume case2 := (k @ v in >set (rest - key))
                      (!M case2)))
                    
          })

conclude ms-theorem-2 := (forall m k . ~ k in dom m ==> m at k = default m)
pick-any m:('K 'V) k:'K
   assume hyp := (~ k in dom m)
     (!chain-> [hyp ==> (~ m at k =/= default m)  [lemma-D]
                    ==> (m at k = default m)      [dn]])

conclude lemma-q := (forall m k k' . k in dom m & k =/= k' ==> k in dom m - k')
by-induction lemma-q {
  (m as (empty-map d:'V)) =>
    pick-any k k' 
      assume hyp := (k in dom m & k =/= k') 
        (!chain-> [(k in dom m) 
               ==> (k in Set.null)   [dom-def]
               ==> false              [Set.NC]
               ==> (k in dom m - k')  [prop-taut]])
| (m as (update (pair key:'K val:'V) rest)) =>
    pick-any k:'K k':'K
      assume hyp := (k in dom m & k =/= k') 
       (!two-cases
        assume (val = default rest)
        let {
             _ := (!chain-> [true ==> (dom rest - key subset dom rest) [dom-lemma-3]]);
             case2 := (!chain-> [(k in dom m)
                         ==> (k in dom rest - key)    [dom-def]
                         ==> (k in dom rest)          [Set.SC]]);
             IH := (forall k k' . k in dom rest & k =/= k' ==> k in dom rest - k');
             L := (!chain-> [case2                    
                         ==> (case2 & k =/= k')   [augment]
                         ==> (k in dom rest - k') [IH]])
            }
               (!two-cases
                 assume (key = k')
                   (!chain-> [L
                          ==> (k in dom rest - key)  [(key = k')]
                          ==> (k in dom m - key)     [remove-def]
                          ==> (k in dom m - k')      [(key = k')]]) 
                 assume (key =/= k')                              
	           let {_ := ();
                        p := (!chain [(dom (key @ val) ++ (rest - k'))
                                    = (key ++ dom rest - k') [dom-def]])
                        }
                     (!chain-> [L 
                           ==> (k in key ++ dom rest - k')           [Set.in-lemma-3]
                           ==> (k in dom (key @ val) ++ (rest - k')) [p]
                           ==> (k in dom m - k')                     [remove-def]]))
        assume (val =/= default rest)
        let {C := (!chain-> [(k in dom m)
                         ==> (k in key ++ dom rest)    [dom-def]
                         ==> (k = key | k in dom rest) [Set.in-def]])}
          (!cases C
            assume case1 := (k = key)
              let {_ := ();
                   _ := (!chain-> [(k =/= k')
                               ==> (key =/= k')  [case1]]) ;
                   _ := (!claim (val =/= default rest));
                   L := (!chain [(dom (key @ val) ++ (rest - k'))
                               = (key ++ dom (rest - k'))  [dom-def]]);
                   _ := ()
                  }
                (!chain-> [true 
                       ==> (key in key ++ dom rest - k') [Set.in-lemma-1]
                       ==> (k in key ++ dom (rest - k'))   [(k = key)]
                       ==> (k in dom (key @ val) ++ (rest - k')) [L]
                       ==> (k in dom m - k')                     [remove-def]])
            assume case2 := (k in dom rest)
              let {IH := (forall k k' . k in dom rest & k =/= k' ==> k in dom rest - k');
                   L := (!chain-> [case2                    
                               ==> (case2 & k =/= k')   [augment]
                               ==> (k in dom rest - k') [IH]])
                  }
               (!two-cases
                 assume (key = k')
                   (!chain-> [L
                          ==> (k in dom rest - key)  [(key = k')]
                          ==> (k in dom m - key)     [remove-def]
                          ==> (k in dom m - k')      [(key = k')]]) 
                 assume (key =/= k')                              
	           let {_ := ();
                        p := (!chain [(dom (key @ val) ++ (rest - k'))
                                    = (key ++ dom rest - k') [dom-def]]);
                        _ := ()
                        }
                     (!chain-> [L 
                           ==> (k in key ++ dom rest - k')           [Set.in-lemma-3]
                           ==> (k in dom (key @ val) ++ (rest - k')) [p]
                           ==> (k in dom m - k')                     [remove-def]]))))
}

conclude lemma-d := (forall m key val . val =/= default m ==> dom key @ val ++ m = key ++ dom m - key)
pick-any m:('K 'V) key:'K val:'V 
  assume (val =/= default m)
  let {L := (dom key @ val ++ m);
       R := (key ++ dom m - key);
       R->L := (!Set.subset-intro 
                  pick-any k:'K
                    assume (k in R)
                      (!cases (!chain-> [(k in R)
                                     ==> (k = key | k in dom m - key)  [Set.in-def]])
                        assume (k = key)
                          (!chain-> [true 
                                 ==> (key in key ++ dom m)       [Set.in-lemma-1]
                                 ==> (key in dom key @ val ++ m) [dom-def]
                                 ==> (k in L)                    [(k = key)]])
                        assume case2 := (k in dom m - key)
                          let {_ := (!chain-> [true ==> (dom m - key subset dom m) [dom-lemma-3]])}
                          (!chain-> [case2
                                 ==> (k in dom m)        [Set.SC]
                                 ==> (k in key ++ dom m) [Set.in-lemma-3]
                                 ==> (k in L)               [dom-def]])));
       L->R := (!Set.subset-intro 
                  pick-any k:'K
                    assume (k in L)
                       let {M := method ()
                                   (!chain-> [true
                                          ==> (key in key ++ dom m - key)  [Set.in-lemma-1]
                                          ==> (k in R)                        [(k = key)]])}
                       (!cases (!chain-> [(k in L)
                                     ==> (k in key ++ dom m)    [dom-def]
                                     ==> (k = key | k in dom m) [Set.in-def]])
                         assume (k = key)
                           (!M)
                         assume (k in dom m)
                           (!two-cases
                             assume (k = key)
                               (!M)
                             assume (k =/= key)
                               (!chain-> [(k in dom m)
                                      ==> (k in dom m & k =/= key)  [augment]
                                      ==> (k in dom m - key)        [lemma-q]
                                      ==> (k in R)                     [Set.in-def]]))))}
    (!Set.set-identity-intro L->R R->L)

conclude ms-theorem-4 := (forall m k . k in dom m ==> exists v . k @ v in >set m)
(!strong-induction.measure-induction ms-theorem-4 len 
    pick-any m:('K 'V)
      assume IH := (forall m' . len m' < len m ==> ms-theorem-4-property m')
        conclude (ms-theorem-4-property m)
	   datatype-cases (ms-theorem-4-property m) on m  {
             (em as (empty-map d:'V)) => 
               pick-any k:'K
                  (!chain [(k in dom em)
                       ==> (k in Set.null)  [dom-def]
                       ==> false             [Set.NC]
                       ==> (exists v . k @ v in >set em) [prop-taut]])
          | (map as (update (pair key:'K val:'V) rest)) =>   
               pick-any k:'K
               let {lemma1 := (!chain-> [true ==> (len rest - key < len map) [len-lemma-3]
                                              ==> (len rest - key < len m)   [(m = map)]]);
                     lemma2 := (!chain-> [true ==> (len rest < len map) [len-lemma-1]
                                              ==> (len rest < len m)   [(m = map)]]);
                    _ := ()
                   }
                assume hyp := (k in dom map)
                 (!two-cases
                  assume (val = default rest)
                    (!chain-> [hyp
                           ==> (k in dom rest - key)                      [dom-def]
                           ==> (exists v . k @ v in >set rest - key) [IH]
                           ==> (exists v . k @ v in >set map)        [>set-def]])
                  assume (val =/= default rest)
                  (!cases (!chain-> [hyp
                                 ==> (k in key ++ dom rest - key)    [lemma-d]
                                 ==> (k = key | k in dom rest - key) [Set.in-def]])
                    assume case1 := (k = key)
                      (!chain-> [true
                             ==> (key @ val in key @ val ++ >set rest - key)  [Set.in-lemma-1]
                             ==> (key @ val in >set map)                      [>set-def]
                             ==> (exists v . key @ v in >set map)             [existence]
                             ==> (exists v . k @ v in >set map)               [case1]])
                    assume case2 := (k in dom rest - key)
                      (!chain-> [case2 
                             ==> (exists v . k @ v in >set rest - key) [IH]
                             ==> (exists v . k @ v in key @ val ++ >set rest - key) [Set.in-lemma-3]
                             ==> (exists v . k @ v in >set map)                     [>set-def]])))
})

conclude at-characterization-1 := (forall m k v . m at k = v ==> k @ v in >set m | ~ k in dom m & v = default m)
  pick-any m:('K 'V) k:'K v:'V
    assume hyp := (m at k = v)
      (!two-cases
        assume case1 := (k in dom m)
          pick-witness val for (!chain-> [(k in dom m)
                                      ==> (exists v . k @ v in >set m) [ms-theorem-4]])
           # we now have (k @ val in >set m) 
            let {v=val := (!chain-> [(k @ val in >set m)
                                 ==> (m at k = val)           [ms-theorem-1]
                                 ==> (v = val)                [hyp]])}
              (!chain-> [(k @ val in >set m)
                     ==> (k @ v in >set m)    [v=val]
                     ==> (k @ v in >set m | ~ k in dom m & v = default m) [prop-taut]])
        assume case2 := (~ k in dom m)
          (!chain-> [case2
                 ==> (m at k = default m)                                  [ms-theorem-2]
                 ==> (v = default m)                                       [hyp]
                 ==> (~ k in dom m & v = default m)                        [augment]
                 ==> (k @ v in >set m | ~ k in dom m & v = default m) [prop-taut]]))

conclude at-characterization-2 := (forall m k v . k @ v in >set m | ~ k in dom m & v = default m ==> m at k = v)
  pick-any m:('K 'V) k:'K v:'V
    assume hyp := (k @ v in >set m | ~ k in dom m & v = default m)
      (!cases hyp
        assume case1 := (k @ v in >set m)
          (!chain-> [case1 ==> (m at k = v)   [ms-theorem-1]])
        assume case2 := (~ k in dom m & v = default m)
          (!chain-> [(~ k in dom m)
                 ==> (m at k = default m)   [ms-theorem-2]
                 ==> (m at k = v)           [(v = default m)]]))

conclude at-characterization := (forall m k v . m at k = v <==> k @ v in >set m | ~ k in dom m & v = default m)
  pick-any m:('K 'V) k:'K v:'V
    (!equiv  
      (!chain [(m at k = v) ==> (k @ v in >set m | ~ k in dom m & v = default m) [at-characterization-1]])
      (!chain [(k @ v in >set m | ~ k in dom m & v = default m) ==> (m at k = v) [at-characterization-2]]))

conclude rc1 := (forall m x . (m - x) at x = default m)
by-induction rc1 {
  (m as (empty-map d)) => 
     pick-any x
      (!chain [(m - x at x)
             = (m at x)      [remove-def]
             = d             [apply-def]
             = (default m)   [default-def]])
| (m as (update (pair k:'S v) rest)) =>
    let {IH := (forall x . rest - x at x = default rest)}
      pick-any x:'S
        (!two-cases
           assume (k = x) 
            (!chain [(m - x at x) 
                   = (m - k at k)   [(k = x)] 
                   = (rest - k at k)   [remove-def]
                   = (default rest)    [IH]
                   = (default m)       [default-def]
                    ])
           assume (k =/= x)  
             (!chain [(m - x at x) 
                    = ((k @ v) ++ (rest - x) at x)  [remove-def]
                    = (rest - x at x)               [apply-def]
                    = (default rest)                [IH]
                    = (default m)                   [default-def]]))
}

conclude rc2 := (forall m k x . k =/= x ==> m - k at x = m at x)
by-induction rc2 {
 (m as (empty-map d:'V)) => 
   pick-any k:'K x:'K  
     assume (k =/= x)
       let {L := (m - k at x);
            R := (m at x)}
         (!chain [L 
                = (m at x)  [remove-def]])
| (m as (update (pair key:'K val:'V) rest:('K 'V))) =>  
   pick-any k:'K x:'K  
     assume (k =/= x)
       let {IH := (forall k x . k =/= x ==> (rest - k) at x = rest at x)}
         (!two-cases 
           assume (key = k)
            let {_ := (!by-contradiction (key =/= x)
                        (!chain [(key = x)
                             ==> (k = x)           [(key = k)]
                             ==> (k = x & k =/= x) [augment]
                             ==> false             [prop-taut]]))}
            (!chain [(m - k at x) 
                   = (((k @ val) ++ rest) - k at x)  [(key = k)]
                   = (rest - k at x)  [remove-def]
                   = (rest at x)      [IH]
                   = (m at x)         [apply-def]])
           assume (key =/= k) 
             (!two-cases
                assume (x = key)
                  (!chain [(m - k at x) 
                        = (([key val] ++ (rest - k)) at x)   [remove-def]
                        = (([x val] ++ (rest - k)) at x)   [(x = key)]
                        = val                              [apply-def]
                        = (([x val] ++ rest) at x)         [apply-def]
                        = (m at x)                          [(x = key)]])
                assume (x =/= key)            
                  (!chain [(m - k at x)                   
                        = (([key val] ++ (rest - k)) at x)   [remove-def]
                        = (rest - k at x)                    [apply-def]
                        = (rest at x)                        [IH]
                        = (m at x)                           [apply-def]])))
}

conclude rc3 := (forall m k . default m = default m - k)
by-induction rc3 {
  (m as (empty-map d:'V)) =>
     pick-any k
       (!chain [(default m)
              = (default m - k) [remove-def]])              
 | (m as (update (pair key:'K val:'V) rest)) =>   
     let {IH := (forall k . default rest = default rest - k)}
     pick-any k:'K
       (!two-cases
          assume (key = k) 
           (!combine-equations 
             (!chain [(default m) 
                    = (default rest)      [default-def]
                    = (default rest - k)  [IH]])
             (!chain [(default m - k) 
                    = (default rest - k)  [remove-def]]))
          assume (key =/= k) 
            (!chain-> [(default m - k)
                     = (default key @ val ++ rest - k) [remove-def]
                     = (default rest - k)              [default-def]
                     = (default rest)                  [IH]
                     = (default m)                     [default-def]
                   ==> (default m - k = default m) 
                   ==> (default m = default m - k)     [sym]]))
}

conclude dom-lemma-1 := (forall k v rest . v =/= default rest ==> k in dom [k v] ++ rest)
pick-any k v rest
  assume hyp := (v =/= default rest)
  (!chain-> [true ==> (k in k ++ dom rest)     [FSet.in-lemma-1]
                  ==> (k in dom [k v] ++ rest) [dom-def]])

conclude dom-lemma-2 := (forall m k v . v =/= default m ==> dom m subset dom [k v] ++ m)
pick-any m k v
  assume hyp := (v =/= default m)
  (!FSet.subset-intro
     pick-any x
        (!chain [(x in dom m)
             ==> (x in k ++ dom m)      [FSet.in-lemma-3]
             ==> (x in dom [k v] ++ m)  [dom-def]]))
             
conclude dom-lemma-2b := (forall m x k v . v =/= default m & x in dom m ==> x in dom [k v] ++ m)
pick-any m x k v
  assume (v =/= default m & x in dom m)
  let {_ := (!chain-> [(v =/= default m) ==> (dom m subset dom [k v] ++ m) [dom-lemma-2]])}

conclude dom-lemma-2c := (forall m x k v . x in dom [k v] ++ m ==> x = k | x in dom m - k)
pick-any m:('K 'V) x:'K k:'K v:'V 
  assume hyp := (x in dom [k v] ++ m)
    (!two-cases
      assume (v = default m)
        (!chain-> [hyp
               ==> (x in dom m - k)         [dom-def]
               ==> (x = k | x in dom m - k) [prop-taut]])
      assume (v =/= default m)
        (!chain-> [hyp
               ==> (x in k ++ dom m)         [dom-def]
               ==> (x = k | x in dom m - k)      [FSet.in-def]]))
    (!chain-> [(x in dom m) ==> (x in dom [k v] ++ m) [FSet.SC]])

conclude len-lemma-1 := (forall m k v . len m < len (k @ v) ++ m)
by-induction len-lemma-1 {
  (m as (empty-map d:'V)) =>
    pick-any k v
      let {len-left :=  (!chain [(len m) = zero               [len-def]]);
           len-right := (!chain [(len k @ v ++ m) = (S len m) [len-def]])}
       (!chain-> [true 
              ==> (zero < S len m)         [N.Less.<-def]
              ==> (len m < len k @ v ++ m) [len-left len-right]])
 | (m as (update (pair key:'K val:'V) rest)) => 
     let {IH := (forall k v . len rest < len k @ v ++ rest)}
       pick-any k:'K v:'V
         let {len-left := (!chain [(len m)
                                 = (S len rest)  [len-def]]);
              len-right := (!chain [(len k @ v ++ m)
                                  = (S len m)      [len-def]
                                  = (S S len rest) [len-left]])}
          (!chain-> [true
                 ==> (S len rest < S S len rest)  [N.Less.<S]
                 ==> (len m < len k @ v ++ m)     [len-left len-right]])
}

conclude len-lemma-2 := (forall m k . len m - k <= len m)
by-induction len-lemma-2 {
  (m as (empty-map d:'V)) =>
    pick-any k
    (!chain-> [(len m - k)
             = (len m)             [remove-def]
          ==>  (len m - k <= len m) [N.Less=.<=-def]])
 | (m as (update (pair key:'K val:'V) rest)) =>
     pick-any k:'K  
       let {IH := (forall k . len rest - k <= len rest);
            L2 := (!chain-> [true ==> (len rest - k <= len rest) [IH]]);
            L3 := (!chain-> [true ==> (len rest < len m)         [len-lemma-1]]);
            L4 := (!chain-> [L2 ==> (L2 & L3)                    [augment]
                                ==> (len rest - k < len m)       [N.Less=.transitive2]])}
       (!two-cases
         assume (key = k)
           (!chain-> [(len m - k)
                    = (len rest - k)                   [remove-def]
                  ==> (len m - k <= len rest - k)      [N.Less=.<=-def]
                  ==> (len m - k <= len rest - k & L2) [augment]
                  ==> (len m - k <= len rest)          [N.Less=.transitive]
                  ==> (len m - k <= len rest & L3)     [augment]
                  ==> (len m - k < len m)              [N.Less=.transitive2]
                  ==> (len m - k <= len m)             [N.Less=.<=-def]])
         assume (key =/= k)
           let {L5 := (!chain-> [(len m - k)
                               = (len [key val] ++ (rest - k)) [remove-def]
                               = (S len rest - k)              [len-def]])}
              (!chain-> [L4
                     ==> (S len rest - k <= len m)  [N.Less=.discrete]
                     ==> (len m - k <= len m)       [L5]]))
}

conclude len-lemma-3 := (forall key val k rest . len rest - k < len key @ val ++ rest)
  pick-any key:'K val:'V k:'K rest:('K 'V)
    let {m := (key @ val ++ rest);
         L := (!chain-> [true 
                     ==> (len rest - k <= len rest) [len-lemma-2]])}
      (!chain-> [true 
             ==> (len rest < len m)         [len-lemma-1]
             ==> (L & len rest < len m)     [augment]
             ==> (len rest - k < len m)     [N.Less=.transitive2]])

conclude lemma-D := (forall m k .  k in dom m <==> m at k =/= default m)
(!strong-induction.measure-induction lemma-D len 
pick-any m:('K 'V)
  assume IH := (forall m' . len m' < len m ==> lemma-D-property m')
    conclude (lemma-D-property m)      
      datatype-cases (lemma-D-property m) on m  {
        (em as (empty-map d:'V)) => 
         pick-any k
           (!equiv
             (!chain [(k in dom em)
                  ==> (k in null)   [dom-def]
                  ==> false         [FSet.NC]
                  ==> (em at k =/= default em) [prop-taut]])
             assume h := (em at k =/= default em)
               (!by-contradiction (k in dom em)
                 assume (~ k in dom em)
                   (!absurd (!reflex (default em))
                            (!chain-> [h ==> (d =/= default em)         [apply-def]
                                         ==> (default em =/= default em) [default-def]]))))
      | (map as (update (pair key:'K val:'V) rest)) =>   
          pick-any k:'K
            let {lemma1 := (!chain-> [true ==> (len rest - key < len map) [len-lemma-3]
                                           ==> (len rest - key < len m)   [(m = map)]]);
                 lemma2 := (!chain-> [true ==> (len rest < len map) [len-lemma-1]
                                           ==> (len rest < len m)   [(m = map)]])}
            (!equiv
              assume hyp := (k in dom map)
               (!two-cases
                 assume (val = default rest)
                   let {L1 := (!by-contradiction (k =/= key)
                                 assume (k = key)
                                  (!absurd 
                                   (!chain [(rest - key at key)
                                          = (default rest)  [rc1]
                                          = (default rest - key) [rc3]])
                                   (!chain-> [(k in dom map)
                                          ==> (key in dom map)        [(k = key)]
                                          ==> (key in dom rest - key) [dom-def]
                                          ==> (rest - key at key =/= default rest - key) [IH]])));
                        _ := (!ineq-sym L1)}
                     (!chain-> [(k in dom map)
                            ==> (k in dom rest - key)  [dom-def]
                            ==> (rest - key at k =/= default rest - key)  [IH]
                            ==> (rest - key at k =/= default rest)        [rc3]
                            ==> (rest - key at k =/= default map)         [default-def]
                            ==> (rest at k =/= default map)               [rc2]
                            ==> (map at k =/= default map)               [apply-def]])
                 assume case2 := (val =/= default rest)
                  let {M := method ()
                             (!chain-> [(map at k) = (map at key)     [(k = key)]
                                                   = val              [apply-def]
                                    ==> (map at k =/= default rest)   [case2]
                                    ==> (map at k =/= default map)    [default-def]])}
                   (!cases (!chain-> [hyp
                                   ==> (k in key ++ dom rest)    [dom-def] 
                                   ==> (k = key | k in dom rest) [FSet.in-def]])
                      assume (k = key) 
                        (!M)
                      assume (k in dom rest)
                        (!two-cases
                          assume (k = key)
                            (!M)
                          assume (k =/= key)
                            (!chain-> [(k in dom rest) 
                                   ==> (rest at k =/= default rest) [IH]
                                   ==> (map at k  =/= default rest) [apply-def]
                                   ==> (map at k  =/= default map)  [default-def]]))))
              assume hyp := (map at k =/= default map)
                (!two-cases
                   assume case1 := (val = default rest)
                    let {k=/=key := (!by-contradiction (k =/= key)
                                       assume (k = key)
                                        let {p := (!chain [(map at k)
                                                         = (map at key)   [(k = key)]
                                                         = val            [apply-def]
                                                         = (default rest) [case1]
                                                         = (default map)  [default-def]])}
                                        (!absurd p hyp))}
                      (!chain-> [hyp 
                             ==> (rest at k =/= default map) [apply-def] 
                             ==> ((rest - key) at k =/= default map) [rc2]
                             ==> ((rest - key) at k =/= default rest) [default-def]
                             ==> ((rest - key) at k =/= default rest - key) [rc3]
                             ==> (k in dom rest - key)                      [IH]
                             ==> (k in dom map)                             [dom-def]])
                   assume case2 := (val =/= default rest)
                       (!two-cases
                         assume (k = key)
                           (!chain<- [(k in dom map)
                                  <== (key in dom map) [(k = key)]
                                  <== (key in key ++ dom rest) [dom-def]
                                  <== true                     [FSet.in-lemma-1]])
                         assume (k =/= key)
                           (!chain-> [hyp
                                  ==> (rest at k =/= default map)  [apply-def]
                                  ==> (rest at k =/= default rest) [default-def]
                                  ==> (k in dom rest)              [IH]
                                  ==> (k = key | k in dom rest)    [prop-taut]
                                  ==> (k in key ++ dom rest)       [FSet.in-def]
                                  ==> (k in dom map)               [dom-def]])))
       )
     })
     
conclude rc0 := (forall m x . ~ x in dom m - x)
  pick-any m:('K 'V)  x:'K
    (!by-contradiction (~ x in dom m - x)
      assume hyp := (x in dom m - x)
       (!absurd (!chain-> [true ==> (m - x at x = default m) [rc1]])
                (!chain-> [hyp 
                       ==> (m - x at x =/= default m - x)   [lemma-D]
                       ==> (m - x at x =/= default m)       [rc3]])))

conclude dom-lemma-3 := (forall m k . dom (m - k) subset dom m) 
pick-any m:('K 'V) k:'K
(!FSet.subset-intro
  pick-any x:'K
    assume hyp := (x in dom m - k)
      (!two-cases
         assume (x = k)
          let {L := (!chain-> [true ==> (m - k at k = default m) [rc1]])}
             (!chain-> [hyp
                    ==> (k in dom m - k)                [(x = k)]
                    ==> (m - k at k =/= default m - k)  [lemma-D]
                    ==> (m - k at k =/= default m)      [rc3]
                    ==> (L & m - k at k =/= default m)  [augment]
                    ==> false                           [prop-taut]
                    ==> (x in dom m)                    [prop-taut]])
         assume (x =/= k)
	   (!chain-> [hyp
                  ==> (m - k at x =/= default m - k)   [lemma-D]
                  ==> (m at x =/= default m - k)       [rc2]
                  ==> (m at x =/= default m)           [rc3]
                  ==> (x in dom m)                     [lemma-D]])))

conclude dom-corrolary-1 := (forall key val k rest  . k in dom rest - key ==> k in dom [key val] ++ rest)
pick-any key:'K val:'V k:'K rest:('K 'V)
   let {L1 := (!chain-> [true ==> (dom rest - key subset dom rest)         [dom-lemma-3]])}
     (!two-cases
       assume (val = default rest)
         (!chain [(k in dom rest - key)
              ==> (k in dom [key val] ++ rest) [dom-def]])
       assume (val =/= default rest)
         (!chain [(k in dom rest - key)
              ==> (k in dom rest)              [FSet.SC]
              ==> (k = key | k in dom rest)    [prop-taut]
              ==> (k in key ++ dom rest)       [FSet.in-def]
              ==> (k in dom [key val] ++ rest) [dom-def]]))

conclude ms-lemma-1 := (forall m k v . k @ v in >set m ==> k in dom m)
(!strong-induction.measure-induction ms-lemma-1 len 
  pick-any m:('K 'V)
    assume IH := (forall m' . len m' < len m ==> ms-lemma-1-property m')
      conclude (ms-lemma-1-property m)      
	   datatype-cases (ms-lemma-1-property m) on m  {
             (em as (empty-map d:'V)) => 
               pick-any k v:'V
                 (!chain [(k @ v in >set em)
                      ==> (k @ v in FSet.null)     [>set-def]
                      ==> false                    [FSet.NC]
                      ==> (k in dom em)             [prop-taut]])
          | (map as (update (pair key:'K val:'V) rest)) =>   
               pick-any k:'K v:'V     
                let {goal := (k @ v in >set map ==> k in dom map);
                     lemma1 := (!chain-> [true ==> (len rest - key < len map) [len-lemma-3]
                                               ==> (len rest - key < len m)   [(m = map)]]);
                     lemma2 := (!chain-> [true ==> (len rest < len map) [len-lemma-1]
                                               ==> (len rest < len m)   [(m = map)]])}
                 (!two-cases
                   assume C1 := (val = default rest)
                     (!chain [(k @ v in >set map)
                          ==> (k @ v in >set rest - key)  [>set-def]
                          ==> (k in dom rest - key)            [IH]
                          ==> (k in dom map)                   [dom-def]])
                   assume C2 := (val =/= default rest)
                     let {_ := (!chain-> [true ==> (dom rest - key subset dom rest) [dom-lemma-3]])}
                     (!chain [(k @ v in >set map)
                          ==> (k @ v in key @ val ++ >set rest - key) [>set-def]
                          ==> (k @ v = key @ val | k @ v in >set rest - key) [FSet.in-def]
                          ==> (k = key & v = val | k @ v in >set rest - key) [pair-axioms]
                          ==> (k = key | k @ v in >set rest - key)           [prop-taut]
                          ==> (k = key | k in dom rest - key)                     [IH]
                          ==> (k = key | k in dom rest)                           [FSet.SC]
                          ==> (k in key ++ dom rest)                              [FSet.in-def]
                          ==> (k in dom map)                                      [dom-def]])
          )
        })

conclude dom-corrolary-1 :=
  (forall key val k rest  . k in dom rest - key ==> k in dom [key val] ++ rest)
pick-any key:'K val:'V k:'K rest:('K 'V)
   let {L1 := (!chain-> [true ==> (dom rest - key subset dom rest)         [dom-lemma-3]])}
     (!two-cases
       assume (val = default rest)
         (!chain [(k in dom rest - key)
              ==> (k in dom [key val] ++ rest) [dom-def]])
       assume (val =/= default rest)
         (!chain [(k in dom rest - key)
              ==> (k in dom rest)              [FSet.SC]
              ==> (k = key | k in dom rest)    [prop-taut]
              ==> (k in key ++ dom rest)       [FSet.in-def]
              ==> (k in dom [key val] ++ rest) [dom-def]]))
              
conclude agreement-characterization := (forall A m1 m2 . (agree-on m1 m2 A) <==> forall k . k in A ==> m1 at k = m2 at k)
by-induction agreement-characterization {
  (A as FSet.null:(FSet.Set 'K)) =>  
    pick-any m1:('K 'V) m2:('K 'V)
      let {p1 := assume (agree-on m1 m2 A)
                  pick-any k:'K
                    (!chain [(k in A)
                         ==> false                [FSet.NC]
                         ==> (m1 at k = m2 at k)  [prop-taut]]);
           p2 := assume (forall k . k in A ==> m1 at k = m2 at k)
                  (!chain-> [true ==> (agree-on m1 m2 A) [agree-on-def]])}
       (!equiv p1 p2)
| (A as (FSet.insert h:'K t:(FSet.Set 'K))) =>
    let {IH := (forall m1 m2 . (agree-on m1 m2 t) <==> forall k . k in t ==> m1 at k = m2 at k)}
    pick-any m1:('K 'V) m2:('K 'V)
      let {p1 := assume hyp := (agree-on m1 m2 A)
                  pick-any k:'K
                    assume (k in A) 
                      (!cases (!chain-> [(k in A)
                                     ==> (k = h | k in t)  [FSet.in-def]])
                        assume (k = h)
                          (!chain-> [hyp
                                 ==> (m1 at h = m2 at h)    [agree-on-def]
                                 ==> (m1 at k = m2 at k)    [(k = h)]])
                        assume (k in t)
                         let {P := (!chain-> [hyp
                                          ==> (agree-on m1 m2 t)                        [agree-on-def]
                                          ==> (forall k . k in t ==> m1 at k = m2 at k) [IH]])}
                          (!chain-> [(k in t) ==> (m1 at k = m2 at k) [P]]));
           p2 := assume hyp := (forall k . k in A ==> m1 at k = m2 at k)
                   let {L1 := (!chain-> [true
                                     ==> (h in A)            [FSet.in-lemma-1]
                                     ==> (m1 at h = m2 at h) [hyp]]);
                        L2 := pick-any k:'K
                                (!chain [(k in t)
                                     ==> (k in A)             [FSet.in-def]
                                     ==> (m1 at k = m2 at k)       [hyp]]);
                        L3 := (!chain-> [L2 ==> (agree-on m1 m2 t) [IH]])}
                    (!chain-> [L1 
                          ==> (L1 & L3)           [augment]
                          ==> (agree-on m1 m2 A)  [agree-on-def]])}
        (!equiv p1 p2)
}

conclude downward-agreement-lemma := (forall B A m1 m2 . (agree-on m1 m2 A) & B subset A ==> (agree-on m1 m2 B))
pick-any B:(FSet.Set 'K) A:(FSet.Set 'K) m1:('K 'V) m2:('K 'V)
  assume hyp := ((agree-on m1 m2 A) & B subset A)
    let {L := pick-any k:'K
                assume hyp := (k in B)
                  (!chain-> [hyp 
                         ==> (k in A) [FSet.SC]
                         ==> (m1 at k = m2 at k)  [AGC]])}
      (!chain-> [L ==> (agree-on m1 m2 B) [AGC]])

conclude ms-lemma-1b := (forall m k . ~ k in dom m ==> forall v . ~ k @ v in >set m)
by-induction ms-lemma-1b {
  (m as (empty-map d:'V)) =>
     pick-any k
      assume hyp := (~ k in dom m)
        pick-any v:'V 
          (!by-contradiction (~ k @ v in >set m)
             (!chain [(k @ v in >set m)
                  ==> (k @ v in FSet.null)     [>set-def]
                  ==> false                    [FSet.NC]]))
| (m as (update (pair key:'K val:'V) rest)) =>
    let {IH :=  (forall k . ~ k in dom rest ==> forall v . ~ k @ v in >set rest)}
      pick-any k
        assume hyp := (~ k in dom m)
          pick-any v:'V 
            (!by-contradiction (~ k @ v in >set m)
               assume sup := (k @ v in >set m)
               (!two-cases 
                assume (val = default rest)
                  (!chain-> [sup
                         ==> (k @ v in >set rest - key)  [>set-def]
                         ==> (k in dom rest - key)            [ms-lemma-1]
                         ==> (k in dom m)                     [dom-corrolary-1]
                         ==> (k in dom m & hyp)               [augment]
                         ==> false                            [prop-taut]])
                assume (val =/= default rest)
                let {C := 
                      (!chain-> [sup 
                             ==> (k @ v in key @ val FSet.++ >set rest - key)    [>set-def]
                             ==> (k @ v = key @ val | k @ v in >set rest - key)  [FSet.in-def]]);
                     _ := (!chain-> [true ==> (dom rest - key FSet.subset dom rest)   [dom-lemma-3]])
                    }
                 (!cases C
                   assume case1 := (k @ v = key @ val)
                     let {L := (!chain-> [(val =/= default rest)
                                      ==> (key in dom m)         [dom-lemma-1]])}
                     (!chain-> [case1
                            ==> (k = key & v = val)         [pair-axioms]
                            ==> (k = key)                   [left-and]
                            ==> (k in dom m)                [L]
                            ==> (k in dom m & ~ k in dom m) [augment] 
                            ==> false                       [prop-taut]])
                   assume case2 := (k @ v in >set rest - key)
                     (!chain-> [case2
                            ==> (k in dom rest - key)       [ms-lemma-1]
                            ==> (k in dom rest)             [FSet.SC]
                            ==> (k in key FSet.++ dom rest) [FSet.in-lemma-3]
                            ==> (k in dom m)                [dom-def]
                            ==> (k in dom m & ~ k in dom m) [augment]
                            ==> false                       [prop-taut]]))))
}

conclude ms-lemma-1b' := (forall m k . ~ k in dom m ==> ~ exists v . k @ v in >set m)
pick-any m:('K 'V) k:'K
  assume h := (~ k in dom m)
    let {p := (!chain-> [h ==> (forall v . ~ k @ v in >set m) [ms-lemma-1b]])}
      (!by-contradiction (~ exists v . k @ v in >set m)
        assume hyp := (exists v . k @ v in >set m)
          pick-witness w for hyp wp
            (!absurd wp (!chain-> [true ==> (~ k @ w in >set m) [p]])))

conclude ms-theorem-1 := (forall k v . k @ v in >set m ==> m at k = v)
(!strong-induction.measure-induction ms-theorem-1 len 
    pick-any m:('K 'V)
      assume IH := (forall m' . len m' < len m ==> property m')
        conclude (property m)      
	  datatype-cases (property m) on m  {
            (em as (empty-map d:'V)) =>
               pick-any k:'K v:'V              
                 (!chain [(k @ v in >set em)
                      ==> (k @ v in FSet.null)    [>set-def]
                      ==> false                   [FSet.NC]
                      ==> (em at k = v)           [prop-taut]])
          | (map as (update (pair key:'K val:'V) rest)) =>   
               pick-any k:'K v:'V     
                let {goal := (k @ v in >set map ==> map at k = v);
                     lemma1 := (!chain-> [true ==> (len rest - key < len map) [len-lemma-3]
                                               ==> (len rest - key < len m)   [(m = map)]]);
                     lemma2 := (!chain-> [true ==> (len rest < len map) [len-lemma-1]
                                               ==> (len rest < len m)   [(m = map)]]);
                     #lemma3 := (!chain-> [true ==> (dom rest - key subset dom rest) [dom-lemma-3]]);
                     #lemma4 := (!chain-> [true ==> (dom rest subset dom map) [dom-lemma-2]]);
                     M := method (case)
                          # case here must be this assumption: (k @ v in >set rest - key)
                          let {L := (!chain-> [case ==> (rest - key at k = v) [IH]]);
		               L1 := (!chain-> [case ==> (k in dom rest - key)  [ms-lemma-1]]);
                               L2 := (!by-contradiction (k =/= key)
                                       assume (k = key)
                                         (!absurd (!chain-> [true ==> (~ key in dom rest - key) [rc0]
                                                                  ==> (~ k in dom rest - key)   [(k = key)]])
                                                  L1));
                               _ := (!ineq-sym L2)} 
                            (!chain-> [(key =/= k)
                                   ==> (rest - key at k = rest at k)  [rc2]
                                   ==> (v = rest at k)                [L]
                                   ==> (rest at k = v)                [sym]
                                   ==> (map at k = v)                 [apply-def]])}
                (!two-cases
                 assume (val = default rest)
                   assume hyp := (k @ v in >set map)
                     let {L := (!chain-> [hyp ==> (k @ v in >set rest - key) [>set-def]])}
                       (!M L)
                 assume (val =/= default rest)
                 assume (k @ v in >set map)
                   let {D := (!chain-> [(k @ v in >set map)
                                  ==> (k @ v in (key @ val) ++ >set (rest - key))  [>set-def]
                                  ==> (k @ v = key @ val | k @ v in >set (rest - key)) [FSet.in-def]])}
                  (!cases D
                    assume case1 := (k @ v = key @ val)
                      let {
                           L1 := (!chain-> [case1
                                        ==> (k = key & v = val)  [pair-axioms]]);
                           L2 := (!chain-> [(k = key) ==> (key = k) [sym]]);
                           L3 := (!chain-> [(v = val) ==> (val = v) [sym]])
                          } 
                        (!chain-> [(key = k)
                               ==> (map at k = val)   [apply-def]
                               ==> (map at k = v)     [(val = v)]])
                    assume case2 := (k @ v in >set (rest - key))
                      (!M case2)))
                    
          })

conclude ms-theorem-2 := (forall m k . ~ k in dom m ==> m at k = default m)
pick-any m:('K 'V) k:'K
   assume hyp := (~ k in dom m)
     (!chain-> [hyp ==> (~ m at k =/= default m)  [lemma-D]
                    ==> (m at k = default m)      [dn]])

conclude lemma-q := (forall m k k' . k in dom m & k =/= k' ==> k in dom m - k')
by-induction lemma-q {
  (m as (empty-map d:'V)) =>
    pick-any k k' 
      assume hyp := (k in dom m & k =/= k') 
        (!chain-> [(k in dom m) 
               ==> (k in FSet.null)   [dom-def]
               ==> false              [FSet.NC]
               ==> (k in dom m - k')  [prop-taut]])
| (m as (update (pair key:'K val:'V) rest)) =>
    pick-any k:'K k':'K
      assume hyp := (k in dom m & k =/= k') 
       (!two-cases
        assume (val = default rest)
        let {
             _ := (!chain-> [true ==> (dom rest - key subset dom rest) [dom-lemma-3]]);
             case2 := (!chain-> [(k in dom m)
                         ==> (k in dom rest - key)    [dom-def]
                         ==> (k in dom rest)          [FSet.SC]]);
             IH := (forall k k' . k in dom rest & k =/= k' ==> k in dom rest - k');
             L := (!chain-> [case2                    
                         ==> (case2 & k =/= k')   [augment]
                         ==> (k in dom rest - k') [IH]])
            }
               (!two-cases
                 assume (key = k')
                   (!chain-> [L
                          ==> (k in dom rest - key)  [(key = k')]
                          ==> (k in dom m - key)     [remove-def]
                          ==> (k in dom m - k')      [(key = k')]]) 
                 assume (key =/= k')                              
	           let {_ := ();
                        p := (!chain [(dom (key @ val) ++ (rest - k'))
                                    = (key ++ dom rest - k') [dom-def]])
                        }
                     (!chain-> [L 
                           ==> (k in key ++ dom rest - k')           [FSet.in-lemma-3]
                           ==> (k in dom (key @ val) ++ (rest - k')) [p]
                           ==> (k in dom m - k')                     [remove-def]]))
        assume (val =/= default rest)
        let {C := (!chain-> [(k in dom m)
                         ==> (k in key ++ dom rest)    [dom-def]
                         ==> (k = key | k in dom rest) [FSet.in-def]])}
          (!cases C
            assume case1 := (k = key)
              let {_ := ();
                   _ := (!chain-> [(k =/= k')
                               ==> (key =/= k')  [case1]]) ;
                   _ := (!claim (val =/= default rest));
                   L := (!chain [(dom (key @ val) ++ (rest - k'))
                               = (key ++ dom (rest - k'))  [dom-def]]);
                   _ := ()
                  }
                (!chain-> [true 
                       ==> (key in key ++ dom rest - k') [FSet.in-lemma-1]
                       ==> (k in key ++ dom (rest - k'))   [(k = key)]
                       ==> (k in dom (key @ val) ++ (rest - k')) [L]
                       ==> (k in dom m - k')                     [remove-def]])
            assume case2 := (k in dom rest)
              let {IH := (forall k k' . k in dom rest & k =/= k' ==> k in dom rest - k');
                   L := (!chain-> [case2                    
                               ==> (case2 & k =/= k')   [augment]
                               ==> (k in dom rest - k') [IH]])
                  }
               (!two-cases
                 assume (key = k')
                   (!chain-> [L
                          ==> (k in dom rest - key)  [(key = k')]
                          ==> (k in dom m - key)     [remove-def]
                          ==> (k in dom m - k')      [(key = k')]]) 
                 assume (key =/= k')                              
	           let {_ := ();
                        p := (!chain [(dom (key @ val) ++ (rest - k'))
                                    = (key ++ dom rest - k') [dom-def]]);
                        _ := ()
                        }
                     (!chain-> [L 
                           ==> (k in key ++ dom rest - k')           [FSet.in-lemma-3]
                           ==> (k in dom (key @ val) ++ (rest - k')) [p]
                           ==> (k in dom m - k')                     [remove-def]]))))
}

conclude lemma-d := (forall m key val . val =/= default m ==> dom key @ val ++ m = key ++ dom m - key)
pick-any m:('K 'V) key:'K val:'V 
  assume (val =/= default m)
  let {L := (dom key @ val ++ m);
       R := (key ++ dom m - key);
       R->L := (!FSet.subset-intro 
                  pick-any k:'K
                    assume (k in R)
                      (!cases (!chain-> [(k in R)
                                     ==> (k = key | k in dom m - key)  [FSet.in-def]])
                        assume (k = key)
                          (!chain-> [true 
                                 ==> (key in key ++ dom m)       [FSet.in-lemma-1]
                                 ==> (key in dom key @ val ++ m) [dom-def]
                                 ==> (k in L)                    [(k = key)]])
                        assume case2 := (k in dom m - key)
                          let {_ := (!chain-> [true ==> (dom m - key subset dom m) [dom-lemma-3]])}
                          (!chain-> [case2
                                 ==> (k in dom m)        [FSet.SC]
                                 ==> (k in key ++ dom m) [FSet.in-lemma-3]
                                 ==> (k in L)               [dom-def]])));
       L->R := (!FSet.subset-intro 
                  pick-any k:'K
                    assume (k in L)
                       let {M := method ()
                                   (!chain-> [true
                                          ==> (key in key ++ dom m - key)  [FSet.in-lemma-1]
                                          ==> (k in R)                        [(k = key)]])}
                       (!cases (!chain-> [(k in L)
                                     ==> (k in key ++ dom m)    [dom-def]
                                     ==> (k = key | k in dom m) [FSet.in-def]])
                         assume (k = key)
                           (!M)
                         assume (k in dom m)
                           (!two-cases
                             assume (k = key)
                               (!M)
                             assume (k =/= key)
                               (!chain-> [(k in dom m)
                                      ==> (k in dom m & k =/= key)  [augment]
                                      ==> (k in dom m - key)        [lemma-q]
                                      ==> (k in R)                     [FSet.in-def]]))))}
    (!FSet.set-identity-intro L->R R->L)

conclude ms-theorem-4 := (forall m k . k in dom m ==> exists v . k @ v in >set m)
(!strong-induction.measure-induction ms-theorem-4 len 
    pick-any m:('K 'V)
      assume IH := (forall m' . len m' < len m ==> ms-theorem-4-property m')
        conclude (ms-theorem-4-property m)
	   datatype-cases (ms-theorem-4-property m) on m  {
             (em as (empty-map d:'V)) => 
               pick-any k:'K
                  (!chain [(k in dom em)
                       ==> (k in FSet.null)  [dom-def]
                       ==> false             [FSet.NC]
                       ==> (exists v . k @ v in >set em) [prop-taut]])
          | (map as (update (pair key:'K val:'V) rest)) =>   
               pick-any k:'K
               let {lemma1 := (!chain-> [true ==> (len rest - key < len map) [len-lemma-3]
                                              ==> (len rest - key < len m)   [(m = map)]]);
                     lemma2 := (!chain-> [true ==> (len rest < len map) [len-lemma-1]
                                              ==> (len rest < len m)   [(m = map)]]);
                    _ := ()
                   }
                assume hyp := (k in dom map)
                 (!two-cases
                  assume (val = default rest)
                    (!chain-> [hyp
                           ==> (k in dom rest - key)                      [dom-def]
                           ==> (exists v . k @ v in >set rest - key) [IH]
                           ==> (exists v . k @ v in >set map)        [>set-def]])
                  assume (val =/= default rest)
                  (!cases (!chain-> [hyp
                                 ==> (k in key ++ dom rest - key)    [lemma-d]
                                 ==> (k = key | k in dom rest - key) [FSet.in-def]])
                    assume case1 := (k = key)
                      (!chain-> [true
                             ==> (key @ val in key @ val ++ >set rest - key)  [FSet.in-lemma-1]
                             ==> (key @ val in >set map)                      [>set-def]
                             ==> (exists v . key @ v in >set map)             [existence]
                             ==> (exists v . k @ v in >set map)               [case1]])
                    assume case2 := (k in dom rest - key)
                      (!chain-> [case2 
                             ==> (exists v . k @ v in >set rest - key) [IH]
                             ==> (exists v . k @ v in key @ val ++ >set rest - key) [FSet.in-lemma-3]
                             ==> (exists v . k @ v in >set map)                     [>set-def]])))
})

conclude at-characterization-1 := (forall m k v . m at k = v ==> k @ v in >set m | ~ k in dom m & v = default m)
  pick-any m:('K 'V) k:'K v:'V
    assume hyp := (m at k = v)
      (!two-cases
        assume case1 := (k in dom m)
          pick-witness val for (!chain-> [(k in dom m)
                                      ==> (exists v . k @ v in >set m) [ms-theorem-4]])
           # we now have (k @ val in >set m) 
            let {v=val := (!chain-> [(k @ val in >set m)
                                 ==> (m at k = val)           [ms-theorem-1]
                                 ==> (v = val)                [hyp]])}
              (!chain-> [(k @ val in >set m)
                     ==> (k @ v in >set m)    [v=val]
                     ==> (k @ v in >set m | ~ k in dom m & v = default m) [prop-taut]])
        assume case2 := (~ k in dom m)
          (!chain-> [case2
                 ==> (m at k = default m)                                  [ms-theorem-2]
                 ==> (v = default m)                                       [hyp]
                 ==> (~ k in dom m & v = default m)                        [augment]
                 ==> (k @ v in >set m | ~ k in dom m & v = default m) [prop-taut]]))

conclude at-characterization-2 := (forall m k v . k @ v in >set m | ~ k in dom m & v = default m ==> m at k = v)
  pick-any m:('K 'V) k:'K v:'V
    assume hyp := (k @ v in >set m | ~ k in dom m & v = default m)
      (!cases hyp
        assume case1 := (k @ v in >set m)
          (!chain-> [case1 ==> (m at k = v)   [ms-theorem-1]])
        assume case2 := (~ k in dom m & v = default m)
          (!chain-> [(~ k in dom m)
                 ==> (m at k = default m)   [ms-theorem-2]
                 ==> (m at k = v)           [(v = default m)]]))
                 
conclude at-characterization := (forall m k v . m at k = v <==> k @ v in >set m | ~ k in dom m & v = default m)
conclude at-characterization
  pick-any m:('K 'V) k:'K v:'V
    (!equiv  
      (!chain [(m at k = v) ==> (k @ v in >set m | ~ k in dom m & v = default m) [at-characterization-1]])
      (!chain [(k @ v in >set m | ~ k in dom m & v = default m) ==> (m at k = v) [at-characterization-2]]))

conclude map-identity-characterization-1 := (forall m1 m2 . (forall k . m1 at k = m2 at k) ==> m1 = m2)
  pick-any m1:('K 'V) m2:('K 'V)
    assume hyp := (forall k . m1 at k = m2 at k)
      let {L1 := conclude (>set m1 = >set m2)
                   (!FSet.set-identity-intro-direct 
                      (!pair-converter
                         pick-any k:'K v:'V
                           (!equiv  
                               assume hyp' := (k @ v in >set m1)
                               let {L := (!chain-> [hyp ==> (k in dom m1) [ms-lemma-1]])}
                               (!chain-> [(k @ v in >set m1)
                                      ==> (m1 at k = v)             [at-characterization]
                                      ==> (m1 at k = v & L)         [augment]
                                      ==> (m2 at k = v & L)         [hyp]
                                      ==> (m2 at k = v)             [hyp]
                                      ==> (k @ v in >set m2)   [at-characterization]])
                               (!chain [(k @ v in >set m2)
                                    ==> (m2 at k = v)             [at-characterization]
                                    ==> (m1 at k = v)             [hyp]
                                    ==> (k @ v in >set m1)   [at-characterization]]))));
           L2 := conclude (default m1 = default m2)
                   (!force (default m1 = default m2))
           ; _ := (halt)
           }
       (!chain-> [L2
              ==> (L2 & L1)  [augment]
              ==> (m1 = m2)  [identity]])

conclude apply-lemma-1 := (forall key val rest x . [key val] ++ rest at x = NONE ==> rest at x = NONE)
   pick-any key val rest x
    let {m := ([key val] ++ rest);
         hyp := (m at x = NONE);
         goal := (rest at x = NONE)}
      assume hyp
        (!two-cases 
          (!chain [(key = x)
               ==> (m at x = SOME val)  [apply-axioms]
               ==> (m at x =/= NONE)    [option-results]
               ==> (hyp & ~hyp)         [augment]
               ==> goal                 [prop-taut]])
          (!chain [(key =/= x) 
	       ==> (m at x = rest at x) [apply-axioms]
               ==>  (NONE = rest at x)  [hyp]
               ==> goal                 [sym]]))

conclude apply-lemma-2 := (forall k v rest x . [k v] ++ rest applied-to x =/= NONE <==> k = x | rest applied-to x =/= NONE)
pick-any k v rest x 
  (!two-cases
     assume case-1 := (k = x) 
       (!equiv assume hyp := ([k v] ++ rest applied-to x =/= NONE)
                 (!chain-> [(k = x) ==> (k = x | rest applied-to x =/= NONE) [alternate]])
               assume (k = x | rest applied-to x =/= NONE)
                 (!chain-> [([k v] ++ rest applied-to x) 
                          = ([x v] ++ rest applied-to x) [(k = x)]
                          = (SOME v)             [apply-axioms]
                        ==> ([k v] ++ rest applied-to x =/= NONE) [option-results]]))
     assume case-2 := (k =/= x) 
       (!equiv assume hyp := ([k v] ++ rest applied-to x =/= NONE)
                 (!chain-> [hyp
                        ==> (rest applied-to x =/= NONE)          [apply-axioms]
                        ==> (k = x | rest applied-to x =/= NONE)  [alternate]])
               assume C := (k = x | rest applied-to x =/= NONE)
                   (!cases C
                      assume (k = x)
                        (!from-complements ([k v] ++ rest applied-to x =/= NONE) (k = x) (k =/= x))
                      (!chain [(rest applied-to x =/= NONE) ==> ([k v] ++ rest applied-to x =/= NONE) [apply-lemma-1]]))))

conclude apply-lemma-3 := (forall m k v1 v2 . m applied-to k = SOME v1 & m applied-to k = SOME v2 ==> v1 = v2)
 pick-any m k v1 v2
    assume hyp := (m applied-to k = SOME v1 & m applied-to k = SOME v2)
      (!chain-> [(SOME v1)
               = (m applied-to k)    
               = (SOME v2)
             ==> (v1 = v2)  [option-results]])

conclude remove-correctness := (forall m x . m - x applied-to x = NONE)
by-induction remove-correctness {
  (m as empty-map) => 
    pick-any x 
      (!chain [([] - x applied-to x)
             = ([] applied-to x)                [remove-def]
             = NONE                     [apply-axioms]])
| (m as (update (pair key val) rest)) =>
   let {IH := (forall x . rest - x applied-to x = NONE)}
     pick-any x
       (!two-cases  
          assume case1 := (key = x)
            (!chain [(m - x applied-to x)      
                   = (m - key applied-to key)  [case1]
                   = (rest - x applied-to x)   [case1 remove-def]
                   = NONE                                 [IH]])
          assume case2 := (key =/= x)
            (!chain [(m - x applied-to x)
                   = ([key val] ++ (rest - x) applied-to x) [remove-def]
                   = (rest - x applied-to x)                [apply-axioms]
                   = NONE                                              [IH]]))
}

conclude remove-correctness-2 := (forall m x y . x =/= y ==> (m - x) at y = m at y)
by-induction remove-correctness-2 {
  (m as empty-map) =>	     
    pick-any x y
      assume hyp := (x =/= y) 
        (!chain [((m - x) at y) 
               = (m at y)                   [remove-def]])
| (m as (update (pair key val) rest)) =>
    let {IH := (forall x y . x =/= y ==> (rest - x) at y = rest at y)}
    pick-any x y
      assume hyp := (x =/= y) 
        (!two-cases 
           assume case1 := (key = x)
            #let {lemma := (!CongruenceClosure.cc (key =/= y) [case1 hyp])}
            let {lemma := (!RC2-M (key =/= y) case1 hyp)}
             (!chain [((m - x) at y)        
                    = ((rest - x) at y)    [(key = x) remove-def]
                    = (rest at y)                     [IH]
                    = (m at y)                        [apply-axioms]])
           assume (key =/= x)
               (!two-cases
                  assume (key = y)
                    (!combine-equations
  		       (!chain [((m - x) at y)
                              = (([key val] ++ (rest - x)) at y) [remove-def]
                              = (SOME val)                                          [apply-axioms]])
                       (!chain [(m at y)
                              = (SOME val)                                          [apply-axioms]]))
                  assume (key =/= y)
                    (!combine-equations
  		       (!chain [((m - x) at y)
                              = (([key val] ++ (rest - x)) at y) [remove-def]
                           = ((rest - x) at y)              [apply-axioms]
                           = (rest at y)                               [IH]])
                       (!chain [(m at y)
                             = (rest at y)                             [apply-axioms]]))))
}

conclude opair-lemma := (forall x1 x2 y1 y2 A . x1 =/= x2 ==> x1 @ y1 in A <==> x1 @ y1 in x2 @ y2 ++ A)
pick-any x1:'S x2:'S y1:'T y2:'T A:(Set.Set (Pair 'S 'T))
  assume (x1 =/= x2) 
    (!equiv (!chain [(x1 @ y1 in A) 
                 ==> (x1 @ y1 in x2 @ y2 ++ A)              [Set.in-lemma-3]])
            (!chain [(x1 @ y1 in x2 @ y2 ++ A) 
                   ==> (x1 @ y1 = x2 @ y2 | x1 @ y1 in A)   [Set.in-def]
                   ==> ((x1 = x2 & y1 = y2) | x1 @ y1 in A) [(datatype-axioms "Pair")]
                   ==> (x1 = x2 | x1 @ y1 in A)             [prop-taut]
                   ==> (x1 =/= x2 & (x1 = x2 | x1 @ y1 in A)) [augment]
                   ==> ((x1 =/= x2 & x1 = x2) | (x1 =/= x2 & x1 @ y1 in A)) [prop-taut] 
                   ==> (false | (x1 =/= x2 & x1 @ y1 in A))                 [prop-taut] 
                   ==> (x1 =/= x2 & x1 @ y1 in A)                           [prop-taut] 
                   ==> (x1 @ y1 in A)                                       [right-and]]))

conclude dom-lemma-1 := (forall k v rest . k in dom [k v] ++ rest)
    pick-any k v rest
      (!chain-> [true ==> (k in k ++ dom rest)     [Set.in-lemma-1]
                      ==> (k in dom [k v] ++ rest) [dom-axioms]])

conclude dom-characterization := (forall m k . k in dom m <==> m applied-to k =/= NONE)
by-induction dom-characterization {
  (m as empty-map) => 
   pick-any k   
     (!equiv 
       (!chain [(k in dom m)
            ==> (k in null)                         [dom-axioms]
            ==> false                               [Set.NC]
            ==> (m applied-to k =/= NONE)           [prop-taut]])
       assume hyp := (m applied-to k =/= NONE)      
         (!chain-> [true                            
                ==> (m applied-to k = NONE)         [apply-axioms]
                ==> (m applied-to k = NONE & hyp)   [augment]
                ==> false                           [prop-taut]
                ==> (k in dom m)                    [prop-taut]]))
| (m as (update (pair x y) rest)) =>                 
   let {IH := (forall k . k in dom rest <==> rest applied-to k =/= NONE)}
    pick-any k                                        
      (!chain [(k in dom m)                          
          <==> (k in x ++ dom rest)                 [dom-axioms]
          <==> (k = x | k in dom rest)              [Set.in-def]
          <==> (k = x | rest applied-to k =/= NONE) [IH]
          <==> (x = k | rest applied-to k =/= NONE) [sym]
          <==> (m applied-to k =/= NONE)            [apply-lemma-2]])
}

conclude dom-lemma-3 := (forall m k . dom (m - k) subset dom m)
by-induction dom-lemma-3 {
  (m as empty-map:(Map 'K 'V)) =>
     pick-any k:'K
       (!Set.subset-intro 
          pick-any x:'K
           (!chain [(x in dom m - k)
                ==> (x in dom empty-map)   [remove-def]
                ==> (x in null)            [dom-axioms]
                ==> false                  [Set.NC]
                ==> (x in dom m)           [prop-taut]]))
| (m as (update (pair key:'K val:'V) rest)) =>
     pick-any k:'K
      let {IH := (!claim (forall k . dom rest - k subset dom rest));
           IH1 := (!chain-> [true ==> (dom rest - key subset dom rest) [IH]]);
           IH2 := (!chain-> [true ==> (dom rest - k subset dom rest) [IH]])}
       (!Set.subset-intro 
          pick-any x:'K
            (!two-cases 
               assume (key = k)
                 (!chain [(x in dom m - k)
                      ==> (x in dom m - key)       [(key = k)]
                      ==> (x in dom rest - key)    [remove-def]
                      ==> (x in dom rest)          [IH1 Set.SC]
                      ==> (x in key ++ dom rest)   [Set.in-lemma-3]
                      ==> (x in dom m)             [dom-axioms]])
               assume case-2 := (key =/= k)
                 (!chain [(x in dom m - k)
                      ==> (x in dom [key val] ++ (rest - k))  [remove-def]
                      ==> (x in key ++ dom rest - k)          [dom-axioms]
                      ==> (x = key | x in dom rest - k)       [Set.in-def]
                      ==> (x = key | x in dom rest)           [Set.SC IH2]
                      ==> (x in key ++ dom rest)              [Set.in-def]
                      ==> (x in dom m)                        [dom-axioms]])))
}

conclude ms-rec-lemma := (forall m k v . size (m - k) < size [k v] ++ m)
  pick-any m:(Map 'K 'V) key:'K val:'V
    let {L1 := (!by-contradiction (~ key in dom m - key)
                  assume h := (key in dom m - key) 
                   (!absurd (!chain-> [true ==> ((m - key) applied-to key = NONE) [remove-correctness]])
                            (!chain-> [h ==> ((m - key) applied-to key =/= NONE)    [dom-characterization]])));
         L2 := (!chain-> [true ==> (key in dom [key val] ++ m) [dom-lemma-1]]);
         L3 := (!both (!chain-> [true ==> (dom m - key subset dom m) [dom-lemma-3]])
                     (!chain-> [true ==> (dom m subset dom [key val] ++ m) [dom-lemma-2]]));
         L4 := (!chain-> [L3 ==> (dom m - key subset dom [key val] ++ m) [Set.subset-transitivity]])}
      (!chain-> [L4 ==> (L4 & L2 & L1) [augment]
                    ==> (dom m - key proper-subset dom [key val] ++ m) [Set.proper-subset-lemma]
                    ==> (card dom m - key < card dom [key val] ++ m)   [Set.proper-subset-card-theorem]
                    ==> (size m - key < size [key val] ++ m)           [size-axioms]])

conclude ms-theorem := (forall m k v . k @ v in map->set m <==> m applied-to k = SOME v)
  (!strong-induction.measure-induction ms-theorem size 
    pick-any m:(Map 'K 'V)
      assume IH := (forall m' . size m' < size m ==> property m')
        conclude (property m) 
	   datatype-cases (property m) on m  {
             (em as empty-map:(Map 'K 'V)) => 
               (pick-any k:'K v:'V 
                 let {none := NONE:(Option 'V)}
                  (!equiv (!chain [(k @ v in map->set em)
                               ==> (k @ v in null)
                               ==> false
                               ==> (em applied-to k = SOME v)])
                          assume hyp := (em applied-to k = SOME v)
                            (!chain-> [true
                                   ==> (em applied-to k = none)                    [apply-axioms]
                                   ==> (em applied-to k = none & hyp)              [augment]
                                   ==> (em applied-to k = none & em applied-to k =/= none) [option-results]
                                   ==> false                               [prop-taut]
                                   ==> (k @ v in map->set em)              [prop-taut]])))
           | (map as (update (pair key:'K val:'V) rest)) => 
               pick-any k:'K v:'V 
                let {goal := (k @ v in map->set map <==> map applied-to k = SOME v);
                     lemma := (!chain-> [true ==> (size rest - key < size map) [ms-rec-lemma]
                                              ==> (size rest - key < size m)   [(m = map)]])}
                  (!two-cases 
                    assume case1 := (k = key)
                      (!equiv assume hyp := (k @ v in map->set map)
                                let {D := (!chain-> [hyp 
                                                 ==> (k @ v in key @ val ++ map->set rest - key)   [map->set-def]
                                                 ==> (key @ v in key @ val ++ map->set rest - key) [case1]
                                                 ==> (key @ v = key @ val | key @ v in map->set rest - key) [Set.in-def]])}
                                  (!cases D
                                     assume h1 := (key @ v in map->set rest - key) 
                                       let {_ := (!absurd (!chain-> [h1 ==> ((rest - key) applied-to key = SOME v)  [IH]
                                                                        ==> (NONE = SOME v)                 [remove-correctness]])
                                                          (!chain-> [true ==> (NONE =/= SOME v) [option-results]]))}
                                         (!from-false (map applied-to k = SOME v))
                                     assume h2 := (key @ v = key @ val)
                                       let {v=val := (!chain [h2 ==> (v = val)])}
                                        (!chain-> [(map applied-to key) = (SOME val) [apply-axioms]
                                                                = (SOME v)   [v=val]
                                               ==> (map applied-to key = SOME v)  
                                               ==> (map applied-to k = SOME v)  [(k = key)]]))
                              assume hyp := (map applied-to k = SOME v)
                                let {val=v := (!chain-> [(SOME val)
                                                       = (map applied-to key) [apply-axioms]
                                                       = (map applied-to k)   [(k = key)]
                                                       = (SOME v)     [hyp]
                                                    ==> (val = v)     [option-results]])}
                                  (!chain-> [true ==> (key @ val in key @ val ++ map->set (rest - key)) [Set.in-lemma-1]
                                                  ==> (key @ val in map->set map)                       [map->set-def]
                                                  ==> (k @ val  in map->set map)                        [(k = key)]
                                                  ==> (k @ v in map->set map)                           [val=v]]))
                    assume case2 := (k =/= key)
                      (!iff-comm            
                        (!chain [(map applied-to k = SOME v)
                            <==> (rest applied-to k = SOME v)                        [apply-axioms]
  	 	            <==> ((rest - key) applied-to k = SOME v)                [remove-correctness-2] 
                            <==> (k @ v in map->set rest - key)              [IH]
                            <==> (k @ v in key @ val ++ map->set rest - key) [(k @ v in map->set rest - key <==> 
                                                                               k @ v in key @ val ++ map->set rest - key)
                                                                              <== case2 [opair-lemma]]
                            <==> (k @ v in map->set map)                     [map->set-def]])))
           })

conclude dom-characterization-2 := (forall m x . x in dom m <==> exists v . x @ v in map->set m)
conclude dom-characterization-2
    pick-any m:(Map 'K 'V) x:'K
       (!chain [(x in dom m)
           <==> (m applied-to x =/= NONE)                [dom-characterization]  
           <==> (exists v . m applied-to x = SOME v)     [option-results]
           <==> (exists v . x @ v in map->set m) [ms-theorem]])

conclude ms-corollary := (forall m k . m applied-to k = NONE <==> ~ exists v . k @ v in map->set m) 
pick-any m:(Map 'K 'V) k:'K
  (!equiv (!chain [(m applied-to k = NONE) 
               ==> (~ exists v . m applied-to k = SOME v)     [option-results]
               ==> (~ exists v . k @ v in map->set m) [ms-theorem]])
          (!chain [(~ exists v . k @ v in map->set m) 
               ==> (~ exists v . m applied-to k = SOME v)     [ms-theorem]
               ==> (m applied-to k = NONE)         

conclude identity-characterization-1 := (forall m1 m2 . m1 = m2 ==> forall k . m1 applied-to k = m2 applied-to k)
pick-any m1:(Map 'S 'T) m2:(Map 'S 'T) 
  assume hyp := (m1 = m2)  
   let {m1=m2 := (!chain-> [hyp ==> (map->set m1 = map->set m2) [map-identity]])}
    pick-any k:'S
      (!cases (!chain-> [true ==> (m1 applied-to k = NONE | exists v . m1 applied-to k = SOME v) [option-results]])
        assume case1 := (m1 applied-to k = NONE)
          let {p := (!by-contradiction (m2 applied-to k = NONE)
                      assume h := (m2 applied-to k =/= NONE)
                        pick-witness v for (!chain-> [h ==> (exists v . m2 applied-to k = SOME v) [option-results]]) wp
                          (!chain-> [wp ==> (k @ v in map->set m2)     [ms-theorem] 
                                        ==> (k @ v in map->set m1)     [m1=m2]
                                        ==> (m1 applied-to k = SOME v)         [ms-theorem]
                                        ==> (m1 applied-to k =/= NONE)         [option-results]
                                        ==> (case1 & m1 applied-to k =/= NONE) [augment]
                                        ==> false                      [prop-taut]]))}
           (!combine-equations (m1 applied-to k = NONE) (m2 applied-to k = NONE))
        assume case2 := (exists v . m1 applied-to k = SOME v)
          pick-witness v for case2 
           (!combine-equations 
              (m1 applied-to k = SOME v)
              (!chain-> [(m1 applied-to k = SOME v) 
                     ==> (k @ v in map->set m1)  [ms-theorem]
                     ==> (k @ v in map->set m2)  [m1=m2]
                     ==> (m2 applied-to k = SOME v)      [ms-theorem]])))

conclude identity-characterization-2 := (forall m1 m2 . (forall k . m1 applied-to k = m2 applied-to k) ==> m1 = m2)
pick-any m1:(Map 'S 'T) m2:(Map 'S 'T) 
  assume hyp := (forall k . m1 applied-to k = m2 applied-to k)
   let {m1=m2-as-sets := 
        (!Set.set-identity-intro-direct 
          (!pair-converter
             pick-any k:'S v:'T
               (!chain [(k @ v in map->set m1)
                   <==> (m1 applied-to k = SOME v)       [ms-theorem]
                   <==> (m2 applied-to k = SOME v)       [hyp] 
                   <==> (k @ v in map->set m2)   [ms-theorem]])))}
     (!chain-> [m1=m2-as-sets ==> (m1 = m2) [map-identity]])

conclude identity-characterization := (forall m1 m2 . m1 = m2 <==> forall k . m1 applied-to k = m2 applied-to k)
pick-any m1:(Map 'S 'T) m2:(Map 'S 'T) 
  (!equiv
     (!chain [(m1 = m2) ==> (forall k . m1 applied-to k = m2 applied-to k) [identity-characterization-1]])
     (!chain [(forall k . m1 applied-to k = m2 applied-to k) ==> (m1 = m2) [identity-characterization-2]]))

conclude restriction-theorem-1 := (forall m A . dom m |^ A subset A)
by-induction restriction-theorem-1 {  
  empty-map => 
    pick-any A 
      (!Set.subset-intro
        pick-any x
          (!chain [(x in dom empty-map |^ A)
               ==> (x in dom empty-map)     [restrict-axioms]
               ==> (x in null)             [dom-axioms]
               ==> false                    [Set.NC]
               ==> (x in A)                 [prop-taut]]))
| (m as (update (pair k v) rest)) =>
     pick-any A 
     let {IH := (forall A . dom rest |^ A subset A);
          lemma := (!chain-> [true ==> (dom rest |^ A subset A) [IH]])}
      (!two-cases
         assume case-1 := (k in A)
           (!Set.subset-intro
              pick-any x
               (!chain [(x in dom m |^ A)
                    ==> (x in dom [k v] ++ (rest |^ A)) [restrict-axioms]
                    ==> (x in k ++ dom rest |^ A)       [dom-axioms]
                    ==> (x = k | x in dom rest |^ A)    [Set.in-def]
                    ==> (x in A | x in dom rest |^ A)   [case-1]
                    ==> (x in A | x in A)              [Set.SC]
                    ==> (x in A)                       [prop-taut]]))
         assume case-2 := (~ k in A)
           (!Set.subset-intro
              pick-any x
               (!chain [(x in dom m |^ A)
                    ==> (x in dom rest |^ A) [restrict-axioms]
                    ==> (x in A)            [Set.SC]])))
}

conclude restriction-theorem-2 := (forall m A . dom m subset A ==> m |^ A = m)
by-induction restriction-theorem-2 {
  (m as empty-map) => 
    pick-any A 
      assume hyp := (dom m subset A) 
        (!chain [(m |^ A) = m [restrict-axioms]])
| (m as (update (pair key val) rest)) =>
    pick-any A
      assume hyp := (dom m subset A) 
        let {lemma1 := (!chain-> [true ==> (key in dom m) [dom-lemma-1]
                                       ==> (key in A)     [Set.SC]]);
             lemma2 := (!chain-> [true ==> (dom rest subset dom m)       [dom-lemma-2]
                                       ==> (dom rest subset dom m & hyp) [augment]
                                       ==> (dom rest subset A)           [Set.subset-transitivity]]);
             IH := (forall A . dom rest subset A ==> rest |^ A = rest)}
         (!chain [(m |^ A)
                = ([key val] ++ (rest |^ A))   [restrict-axioms]
                = ([key val] ++ rest)          [IH]])
}

conclude range-lemma-1 := (forall m v . v in range m <==> exists k . k @ v in map->set m)
pick-any m v
  (!chain [(v in range m)
      <==> (v in Set.range map->set m)     [range-def]
      <==> (exists k . k @ v in map->set m) [Set.range-characterization]])

conclude range-characterization := (forall m v . v in range m <==> exists k . m at k = SOME v)
pick-any m v 
  (!chain [(v in range m) 
      <==> (exists k . k @ v in map->set m) [range-lemma-1]
      <==> (exists k . m at k = SOME v)     [ms-theorem]])
 
conclude range-lemma-2 := (forall k v rest . v in range [k v] ++ rest)
pick-any k v rest
  (!chain<- [(v in range [k v] ++ rest)
         <== (v in Set.range map->set [k v] ++ rest)     [range-def]
         <== (v in Set.range k @ v ++ map->set rest - k) [map->set-def]
         <== (v in v ++ Set.range map->set rest - k)     [Set.range-def]
         <== (v = v | v in Set.range map->set rest - k)  [Set.in-def]
         <== (v = v)                                      [alternate]])

conclude removal-range-theorem := (forall m k . range m - k subset range m)
pick-any m k 
  (!Set.subset-intro 
     pick-any v
       assume hyp := (in v range m - k)         
         pick-witness key for 
           (!chain<- [(exists key . m - k at key = SOME v)  
                  <== hyp [range-characterization]])
           key-premise 
           let {k!=key := 
                 (!by-contradiction (k =/= key) 
                   assume (k = key)
                     (!absurd (!chain-> [key-premise 
                                    ==> (m - key at key = SOME v) [(k = key)]])
                              (!chain-> [true ==> (m - key at key = NONE) [remove-correctness]
                                              ==> (m - key at key =/= SOME v) [option-results]])))}
             (!chain-> [k!=key ==> (m - k at key = m at key) [remove-correctness-2]
                           ==> (SOME v = m at key)       [key-premise]
                           ==> (m at key = SOME v)       [sym]
                           ==> (exists key . m at key = SOME v) [existence]
                           ==> (v in range m)                   [range-characterization]]))

conclude override-theorem-1 := (forall m . [] ** m = m) 
by-induction override-theorem-1 {
  (m as empty-map) =>  
    (!chain [(empty-map ** m) = empty-map [override-def]])
| (m as (update (pair k v) rest)) => 
   let {IH := ([] ** rest = rest)}
    (!chain [(empty-map ** m)
           = ([k v] ++ (empty-map ** rest))  [override-def]
           = ([k v] ++ rest)                 [IH]])
}

conclude conj1 := (forall m1 m2 . dom m2 ** m1 = (dom m2) \/ (dom m1))
by-induction (forall m1 m2 . dom m2 ** m1 = (dom m2) \/ (dom m1)) {
  (m1 as empty-map:(Map 'K 'V)) => 
    pick-any m2:(Map 'K 'V)
      (!chain [(dom m2 ** m1)
             = (dom m2)                                    [override-def]
             = (null \/ dom m2)                            [Set.union-def]
             = ((dom m2) \/ null)                          [Set.union-commutes]
             = ((dom m2) \/ (dom m1))                      [dom-axioms]])
 | (m1 as (update (pair k:'K v:'V) rest)) =>
    let {IH := (forall m2 . dom m2 ** rest = (dom m2) \/ (dom rest))}
    pick-any m2:(Map 'K 'V)
      (!chain [(dom m2 ** m1)   
             = (dom [k v] ++ (m2 ** rest))     [override-def]
             = (k ++ dom (m2 ** rest))         [dom-axioms]
             = (k ++ ((dom m2) \/ (dom rest))) [IH]
             = ((dom m2) \/ k ++ dom rest)     [Set.union-lemma-2]
             = ((dom m2) \/ dom m1)            [dom-axioms]])
}

conclude conj2 := (forall m1 m2 k . k in dom m1 ==> (m2 ** m1) applied-to k = m1 applied-to k)
by-induction conj2 {
  (m1 as empty-map:(Map 'S 'T)) => 
    pick-any m2:(Map 'S 'T) k:'S
       (!chain [(k in dom m1) 
            ==> (k in null)    [dom-axioms]
            ==> false          [Set.NC] 
            ==> ((m2 ** m1) applied-to k = m1 applied-to k) [prop-taut]])
| (m1 as (update (pair key val) rest)) => 
    let {IH := (forall m2 k . k in dom rest ==> (m2 ** rest) applied-to k = rest applied-to k)}
      pick-any m2 k 
        assume hyp := (k in dom m1)
          (!cases (!chain-> [hyp
                        ==> (k in key ++ dom rest)     [dom-axioms]
                        ==> (k = key | k in dom rest)  [Set.in-def]
                        ==> (k = key | k =/= key & k in dom rest)  [prop-taut]])
             assume (k = key)
	       (!chain [((m2 ** m1) applied-to k)
                      = ([key val] ++ (m2 ** rest) applied-to k)   [override-def]
                      = ([key val] ++ (m2 ** rest) applied-to key) [(k = key)]
                      = (SOME val)                                 [apply-axioms]
                      = (m1 applied-to key)                        [apply-axioms]
                      = (m1 applied-to k)                          [(k = key)]])
             assume (k =/= key & k in dom rest)
                 (!chain [((m2 ** m1) applied-to k)
                        = (([key val] ++ (m2 ** rest)) applied-to k)   [override-def]
                        = ((m2 ** rest) applied-to k)                  [apply-axioms]
                        = (rest applied-to k)                          [IH]
                        = (m1 applied-to k)                            [apply-axioms]]))
}

conclude restrict-theorem-3 := (forall m2 m1 A . (m1 ** m2) |^ A = m1 |^ A ** m2 |^ A)
by-induction restrict-theorem-3 {
  (m2 as empty-map) => 
    pick-any m1 A 
      (!combine-equations
          (!chain [((m1 ** m2) |^ A) =  (m1 |^ A)])
          (!chain [(m1 |^ A ** m2 |^ A) 
                 = (m1 |^ A ** empty-map)
                 = (m1 |^ A)]))
| (m2 as (update (pair k v) rest)) =>
   let {IH := (forall m1 A . (m1 ** rest) |^ A = m1 |^ A ** rest |^ A)}
    pick-any m1 A 
      (!two-cases
         assume (k in A)
           (!combine-equations
              (!chain [((m1 ** m2) |^ A)
                     = (([k v] ++ (m1 ** rest)) |^ A)    [override-def]
                     = ([k v] ++ ((m1 ** rest) |^ A))    [restrict-axioms]
                     = ([k v] ++ (m1 |^ A ** rest |^ A)) [IH]])
              (!chain [(m1 |^ A ** m2 |^ A)
                     = (m1 |^ A ** [k v] ++ (rest |^ A)) [restrict-axioms]
                     = ([k v] ++ (m1 |^ A ** rest |^ A)) [override-def]]))
         assume (~ k in A)
           (!chain [((m1 ** m2) |^ A)
                  = (([k v] ++ (m1 ** rest)) |^ A)       [override-def]
                  = ((m1 ** rest) |^ A)                  [restrict-axioms]
                  = (m1 |^ A ** rest |^ A)               [IH]
                  = (m1 |^ A ** m2 |^ A)                 [restrict-axioms]]))
}

conclude option-lemma-1 := (forall ?x ?y . ?x = SOME ?y ==> ?x =/= NONE)
  pick-any x y
    assume hyp := (x = SOME y)
      (!chain-last [true ==> (NONE =/= SOME y)  [opt-axioms]
                         ==> (NONE =/= x)       [hyp]
                         ==> (x =/= NONE)       [sym]])

conclude option-lemma-2 := (forall ?x . ?x =/= NONE ==> exists ?y . ?x = SOME ?y)
  pick-any x 
    assume hyp := (x =/= NONE)
      (!chain-last 
       [true ==> (x = NONE | exists ?y . x = SOME ?y) [opt-axioms]
	     ==> (exists ?y . x = SOME ?y)            [(dsyl with hyp)]])

conclude option-lemma-2-conv := (forall ?x . (forall ?y . ?x =/= SOME ?y) ==> ?x = NONE)
  pick-any x 
    assume hyp := (forall ?y . x =/= SOME ?y)
      (!chain-last 
         [hyp ==> (~ exists ?y . x = SOME ?y)  [qn]
              ==> (x = NONE)                   [option-lemma-2]])

conclude option-lemma-3 := (forall ?x . ?x = NONE ==> ~ exists ?y . ?x = SOME ?y)
  pick-any x
    assume hyp := (x = NONE)
      (!by-contradiction  (~ exists ?y . x = SOME ?y)
       assume hyp' := (exists ?y . x = SOME ?y)
         pick-witness y for hyp' 
           (!absurd 
	    (!chain-last 
	     [(x = SOME y) ==> (NONE = SOME y) [hyp]])
	    (!chain-last 
	     [true ==> (NONE =/= SOME y) [opt-axioms]])))

conclude option-lemma-4 := (forall ?x ?y . ?x = NONE ==> ?x =/= SOME ?y)
  pick-any x y
    assume hyp := (x = NONE)
      (!by-contradiction (x =/= SOME y)
        assume (x = SOME y)
          (!absurd 
	   (!chain-last 
	    [(x = NONE) ==> (NONE = x) [sym] 
	                ==> (NONE = SOME y) [(x = SOME y)]])
	   (!uspec (forall ?y . NONE =/= SOME ?y) y)))

conclude option-lemma-5 := (forall ?x ?y ?z . ?x = SOME ?y & ?y =/= ?z ==> ?x =/= SOME ?z)
 pick-any x y z
  assume h := (x = SOME y & y =/= z)
    (!chain-last [h ==> (y =/= z)           [right-and]
                    ==> (SOME y =/= SOME z) [opt-axioms]
                    ==> (x =/= SOME z)      [h]])

conclude pair-theorem-1 := (forall p . p = (pair-left p) @ (pair-right p))
  datatype-cases pair-theorem-1 {
    (P as (pair x y)) => 
      (!chain [P = ((pair-left P) @ (pair-right P)) [pair-axioms]])
  }

conclude pair-theorem-2 := (forall x y z w . x @ y = z @ w <==> y @ x = w @ z)
  pick-any x y z w
    (!chain [(x @ y = z @ w) <==> (x = z & y = w)    [pair-axioms]
	                       <==> (y = w & x = z)    [prop-taut] 
                               <==> (y @ x = w @ z)  [pair-axioms]])

conclude swap-theorem-1 := (forall x y . swap swap x @ y = x @ y)
pick-any x y 
  (!chain [(swap swap x @ y) = (swap y @ x) [swap-def]
                             = (x @ y)      [swap-def]])

conclude swap-theorem-1b := (forall p . swap swap p = p)
 pick-any p
  let {E := (!chain-> [true ==> (exists x y . p = x @ y) [pair-axioms]])}
    pick-witnesses x y for E 
      (!chain-> [(swap swap x @ y)
               = (swap y @ x)      [swap-def]
               = (x @ y)           [swap-def]
             ==> (swap swap p = p)  [(p = x @ y)]])

conclude swap-theorem-1b := (forall p . swap swap p = p)
  (!pair-converter 
     pick-any x y 
       (!chain [(swap swap x @ y) = (swap y @ x) [swap-def]
		                   = (x @ y)      [swap-def]]))

conclude swap-theorem-1b := (forall p . swap swap p = p)
    (!pair-converter swap-theorem-1)

conclude null-characterization := (forall x . x in [] <==> false)
  pick-any x
    (!equiv
      assume hyp := (x in [])
        (!absurd hyp 
                (!chain-> [true ==> (~ x in []) [in-def]]))
      assume false
        (!from-false (x in [])))

conclude in-lemma-1 := (forall x A . x in x ++ A)
  pick-any x A
    (!chain-> [(x = x) ==> (x in x ++ A) [in-def]])

conclude singleton-characterization := (forall x y . x in singleton y <==> x = y)
 pick-any x y
  (!chain [(x in singleton y) 
      <==> (x in y ++ null) [singleton-axiom]
      <==> (x = y | x in null)    [in-def]
      <==> (x = y | false)         [null-characterization]
      <==> (x = y)                 [prop-taut]])

conclude singleton-lemma := (forall x . x in singleton x)
 pick-any x 
    (!chain-> [(x = x) 
           ==> (x in singleton x)  [singleton-characterization]])

conclude subset-characterization-1 := (forall A B . A subset B ==> forall x . x in A ==> x in B)
by-induction subset-characterization-1 {
    null => pick-any B
             assume (null subset B) 
               pick-any x
                 (!chain [(x in null) ==> false    [NC]
                                      ==> (x in B) [prop-taut]])
  | (A as (insert h t)) => 
      pick-any B
        assume hyp := (A subset B) 
          pick-any x
            let {ih := (forall B . t subset B ==> 
                                     forall x . x in t ==> x in B);
                 _ := (!chain-> [hyp ==> (t subset B) [subset-def]])}
              assume hyp' := (x in A)
                (!cases (!chain<- [(x = h | x in t) <== hyp' [in-def]])
                  assume (x = h)
                    (!chain-> [hyp ==>  (h in B)   [subset-def]
                                   ==>  (x in B)   [(x = h)]])
                  (!chain [(x in t) ==> (x in B)   [ih]]))
  }

conclude subset-characterization-2 := (forall A B . (forall x . x in A ==> x in B) ==> A subset B)
  by-induction subset-characterization-2 {
    null => pick-any B
              assume (forall x . x in null ==> x in B)
                (!chain-> [true ==> (null subset B) [subset-def]])
  | (A as (insert h t)) =>
      pick-any B
        assume hyp :=  (forall x . x in A ==> x in B)
          let  {ih := (forall B . (forall x . x in t ==> x in B) 
                                     ==> t subset B);
                goal := (A subset B);
                ih-cond := pick-any x
                            (!chain [(x in t) ==> (x in A)  [in-def]
                                              ==> (x in B)  [hyp]]);
                _ := (!chain-> [ih-cond ==> (t subset B)    [ih]])}
  	    (!chain-> [(h = h)
                   ==> (h in A)              [in-def]
                   ==> (h in B)              [hyp]
                   ==> (h in B & t subset B) [augment]
                   ==> goal                  [subset-def]])
  }

conclude subset-characterization := (forall s1 s2 . s1 subset s2 <==> forall x . x in s1 ==> x in s2)
     pick-any s1 s2 
       (!equiv (!chain [(s1 subset s2) 
                    ==> (forall x . x in s1 ==> x in s2) [subset-characterization-1]])
               (!chain [(forall x . x in s1 ==> x in s2)
                    ==> (s1 subset s2)                   [subset-characterization-2]]))

conclude set-identity-characterization := (forall A B . A = B <==> forall x . x in A <==> x in B)
 pick-any A:(Set 'S) B
   (!equiv 
     assume hyp := (A = B)
       pick-any x 
         let {_ := (!chain-> [hyp ==> (A subset B) [set-identity]]);
              _ := (!chain-> [hyp ==> (B subset A) [set-identity]])}
          (!chain [(x in A) <==> (x in B) [subset-characterization]])
     assume hyp := (forall x . x in A <==> x in B)
       let {A-subset-B := (!subset-intro 
                            pick-any x 
                              (!chain [(x in A) ==> (x in B) [hyp]]));
            B-subset-A := (!subset-intro
                            pick-any x 
                             (!chain [(x in B) ==> (x in A) [hyp]]));
            p := (!both A-subset-B B-subset-A)}
         (!chain-> [p ==> (A = B) [set-identity]]))

conclude neg-set-identity-characterization-1 := (forall s1 s2 . s1 =/= s2 <==> ~ s1 subset s2 | ~ s2 subset s1) 
pick-any s1 s2 
  (!chain [(s1 =/= s2)
      <==> (~ (s1 subset s2 & s2 subset s1)) [set-identity]
      <==> (~ s1 subset s2 | ~ s2 subset s1) [prop-taut]])

conclude neg-set-identity-characterization-2 := (forall s1 s2 . s1 =/= s2 <==> (exists x . x in s1 & ~ x in s2) | (exists x . x in s2 & ~ x in s1))
pick-any s1 s2 
  (!chain [(s1 =/= s2) 
      <==> (~ s1 subset s2 | ~ s2 subset s1)  [neg-set-identity-characterization-1]
      <==> (~ (forall x . x in s1 ==> x in s2) | ~ (forall x . x in s2 ==> x in s1))       [SC]
      <==> ((exists x . ~ (x in s1 ==> x in s2)) | (exists x . ~ (x in s2 ==> x in s1)))   [qn]
      <==> ((exists x . x in s1 & ~ x in s2) | (exists x . x in s2 & ~ x in s1))           [prop-taut]])

conclude proper-subset-characterization := (forall s1 s2 . s1 proper-subset s2 <==> s1 subset s2 & exists x . x in s2 & ~ x in s1)
  pick-any s1 s2
     (!chain [(s1 proper-subset s2)
         <==> (s1 subset s2 & s1 =/= s2)   [proper-subset-def]
         <==> (s1 subset s2 & ((exists x . x in s1 & ~ x in s2) | 
	                       (exists x . x in s2 & ~ x in s1)))  [neg-set-identity-characterization-2]
         <==> (s1 subset s2 & (((s1 subset s2) & (exists x . x in s1 & ~ x in s2)) | 
                                (exists x . x in s2 & ~ x in s1)))  [prop-taut]
         <==> (s1 subset s2 & (((forall x . x in s1 ==> x in s2) & (exists x . x in s1 & ~ x in s2)) | 
	                         (exists x . x in s2 & ~ x in s1))) [SC]
         <==> (s1 subset s2 & ((~~ (forall x . x in s1 ==> x in s2) & (exists x . x in s1 & ~ x in s2)) | 
	                         (exists x . x in s2 & ~ x in s1))) [bdn]
         <==> (s1 subset s2 & ((~ (exists x . ~ (x in s1 ==> x in s2)) & (exists x . x in s1 & ~ x in s2)) |  
	                         (exists x . x in s2 & ~ x in s1))) [qn]
         <==> (s1 subset s2 & ((~ (exists x . x in s1 & ~ x in s2) & (exists x . x in s1 & ~ x in s2)) |  
	                         (exists x . x in s2 & ~ x in s1))) [prop-taut]
         <==> (s1 subset s2 & (false |  (exists x . x in s2 & ~ x in s1)))  [prop-taut]
         <==> (s1 subset s2 & (exists x . x in s2 & ~ x in s1))  [prop-taut]])

conclude proper-subset-lemma := 
  (forall A B x . A subset B & x in B & ~ x in A ==> A proper-subset B)
    pick-any A B x 
       assume h := (A subset B & x in B & ~ x in A)
         (!chain-> [(x in B)
                ==> (x in B & ~ x in A) [augment]
                ==> (exists x . x in B & ~ x in A) [existence]
                ==> (A subset B & exists x . x in B & ~ x in A) [augment]
                ==> (A proper-subset B) [PSC]])

conclude in-lemma-2 := (forall h t . h in t ==> h ++ t = t)
  pick-any h t
    assume hyp := (h in t)
      (!set-identity-intro-direct
         pick-any x
           (!chain [(x in h ++ t) 
               <==> (x = h | x in t)    [in-def] 
               <==> (x in t | x in t)   [hyp prop-taut] 
               <==> (x in t)            [prop-taut]]))

conclude in-lemma-3 := (forall x h t . x in t ==> x in h ++ t)
  pick-any x h t
    (!chain [(x in t)
         ==> (x = h | x in t)  [alternate]
         ==> (x in h ++ t)     [in-def]])

conclude in-lemma-4 := (forall A x y . x in A ==> y in A <==> y = x | y in A)
pick-any A x y
  assume (x in A) 
    (!equiv assume h := (y in A)
              (!chain-> [h ==> (y = x | y in A) [alternate]])
            assume h := (y = x | y in A)
              (!cases h 
                 (!chain [(y = x) ==> (y in A)  [(x in A)]])
                 (!chain [(y in A) ==> (y in A) [claim]])))

conclude null-characterization-2 := (forall A . A = null <==> forall x . ~ x in A)
pick-any A 
  (!chain [(A = null)
      <==> (forall x . x in A <==> x in null)   [SIC]
      <==> (forall x . x in A <==> false)       [NC]
      <==> (forall x . ~ x in A)                [prop-taut]])

conclude NC-3 := (forall A . A =/= null <==> exists x . x in A)
pick-any A
  (!chain [(A =/= null) 
      <==> (~ forall x . ~ x in A) [NC-2]
      <==> (exists x . ~ ~ x in A) [qn-strict]
      <==> (exists x . x in A)     [bdn]])

conclude subset-reflexivity := (forall A . A subset A)
  pick-any A
    (!subset-intro 
       pick-any x
         (!chain [(x in A) ==> (x in A) [claim]]))

conclude subset-antisymmetry := (forall A B . A subset B & B subset A ==> A = B)
 pick-any A B 
   assume hyp := (A subset B & B subset A)
     (!set-identity-intro (A subset B) (B subset A))

conclude subset-transitivity := (forall A B C . A subset B & B subset C ==> A subset C)
   pick-any A B C
     assume (A subset B & B subset C)
       (!subset-intro
          pick-any x
           (!chain [(x in A) 
                ==> (x in B) [subset-characterization]
                ==> (x in C) [subset-characterization]]))

conclude subset-lemma-1 := (forall A B x . A subset B & x in B ==> x ++ A subset B)
pick-any A B x
  assume hyp := (A subset B & x in B)
    (!subset-intro
      pick-any y 
        (!chain [(y in x ++ A) 
             ==> (y = x | y in A)   [in-def]
             ==> (y in B | y in A)  [(x in B)]
             ==> (y in B | y in B)  [SC]
             ==> (y in B)           [prop-taut]]))

conclude subset-lemma-2 := (forall h t A . h ++ t subset A ==> t subset A)
pick-any h t A
  assume (h ++ t subset A)
    (!subset-intro
       pick-any x 
         (!chain [(x in t)
              ==> (x = h | x in t)  [alternate]
              ==> (x in h ++ t)     [in-def]
              ==> (x in A)          [SC]]))

conclude remove-characterization := (forall A x y . y in A - x <==> y in A & y =/= x)
by-induction remove-characterization {
  null => pick-any x y 
            (!chain [(y in null - x)
                <==> (y in null)
                <==> false
                <==> (y in null & y =/= x)])
| (A as (insert h t)) => 
   let {IH := (forall x y . y in t - x <==> y in t & y =/= x)}
    pick-any x y 
      (!two-cases 
         assume case-1 := (x = h)
           (!chain [(y in A - x) 
               <==> (y in t - x)                 [remove-def]
               <==> (y in t & y =/= x)           [IH]
               <==> ((y = x | y in t) & y =/= x) [prop-taut]  
               <==> ((y = h | y in t) & y =/= x) [case-1]
               <==> (y in A & y =/= x)           [in-def]])
         assume case-2 := (x =/= h)
          let {lemma := assume (y = h)
                         (!chain-> [case-2 ==> (y =/= x) [(y = h)]])}
           (!chain [(y in A - x) 
               <==> (y in h ++ (t - x))                     [remove-def]
               <==> (y = h | y in t - x)                    [in-def]
               <==> (y = h | (y in t & y =/= x))            [IH]
               <==> ((y = h | y in t) & (y = h | y =/= x))  [prop-taut]
               <==> (y in A & (y = h | y =/= x))            [in-def]
               <==> (y in A & (y =/= x | y =/= x))          [prop-taut lemma]
               <==> (y in A & y =/= x)                      [prop-taut]]))
}

conclude remove-corollary := (forall A x  . ~ x in A - x)
  pick-any A x 
   (!by-contradiction (~ x in A - x)
      (!chain [(x in A - x) 
           ==> (x in A & x =/= x)  [remove-characterization]
           ==> (x =/= x)           [right-and]
           ==> (x = x & x =/= x)   [augment]
           ==> false               [prop-taut]]))

conclude remove-corollary-2 := (forall A x  . ~ x in A ==> A - x = A)
pick-any A x
  assume hyp := (~ x in A)
    (!set-identity-intro-direct
       pick-any y
         (!equiv 
           (!chain [(y in A - x) 
                ==> (y in A & y =/= x) [remove-characterization]
                ==> (y in A)           [left-and]])
           assume (y in A)
             let {_ := (!by-contradiction (y =/= x)
                          assume (y = x)
                            (!absurd (y in A) 
                                     (!chain-> [hyp ==> (~ y in A) [(y = x)]])));
                  lemma := (!both (y in A) (y =/= x))}
              (!chain-> [lemma ==> (y in A - x) ])))

conclude remove-corollary-3 := (forall A x y . x in A & y =/= x ==> x in A - y)
pick-any A x y 
  assume hyp := (x in A & y =/= x)
    let {_ := (!ineq-sym (y =/= x))}
      (!chain-> [hyp ==> (x in A - y) [remove-characterization]])

conclude remove-corollary-4 := (forall A x y  . ~ x in A ==> ~ x in A - y)
  pick-any A x y
    (!chain [( ~ x in A) ==> (~ x in A - y) [remove-characterization]])

conclude remove-corollary-5 := (forall A B x . A subset B & ~ x in A ==> A subset B - x)
pick-any A B x
  assume h := (A subset B & ~ x in A)
   (!subset-intro
     pick-any y
       assume h2 := (in y A)
         let {_ := (!chain-> [h2 ==> (in y B) [SC]]);
              _ := (!by-contradiction (y =/= x)
                      assume (y = x)
                        (!absurd (in y A)
                                 (!chain-> [(~ x in A) ==> (~ y in A) [(y = x)]])));
              S := (!both (in y B) (y =/= x))}
          (!chain-> [S ==> (y in B - x) [remove-characterization]]))   
          

conclude remove-corollary-6 := (forall A h t . A subset h ++ t ==> A - h subset t)
pick-any A:(Set.Set 'S) h:'S t:(Set.Set 'S)
 assume hyp := (A subset h ++ t)
   (!subset-intro 
     pick-any x 
       assume hyp' := (x in A - h) 
         let {_ := (!chain-> [hyp' ==> (x in A & x =/= h) [remove-characterization]]);
             disj := (!chain-> [(x in A) ==> (x in h ++ t)    [SC]
                                        ==> (x = h | x in t) [in-def]])}
           (!cases disj
              (!chain [(x = h) 
                     ==> (x = h & x =/= h) [augment]
                     ==> false             [prop-taut]
                     ==> (x in t)          [prop-taut]])
              (!chain [(x in t) ==> (x in t) [claim]])))

conclude remove-corollary-7 := (forall A x . A - x subset A)
pick-any A:(Set.Set 'S) x:'S
  (!subset-intro 
     pick-any y
       (!chain [(y in A - x) 
            ==> (y in A)      [remove-characterization]]))

conclude remove-corollary-8 := (forall A x . x in A ==> A = x ++ (A - x))
pick-any A:(Set.Set 'S) x:'S
  assume (x in A) 
    let {p1 := (!subset-intro
                 pick-any y:'S
                   assume (y in A)
                     (!two-cases
                       assume (x = y)
                         (!chain-> [true ==> (x in x ++ (A - x)) [in-lemma-1]
                                         ==> (y in x ++ (A - x)) [(x = y)]])
                       assume (x =/= y)
                         (!chain-> [(x =/= y) 
                                ==> (y in A & x =/= y)  [augment]
                                ==> (y in A - x)        [remove-corollary-3]
                                ==> (y in x ++ (A - x)) [in-def]])));
          p2 := (!subset-intro
                  pick-any y:'S
                   assume hyp := (y in x ++ (A - x)) 
                     (!cases (!chain<- [(y = x | y in A - x) <== hyp [in-def]])
                        assume (y = x)
                          (!chain-> [(y = x) ==> (y in A) [(x in A)]])                         
                        assume (y in A - x)
                          (!chain-> [(y in A - x) ==> (y in A) [remove-characterization]])))}
     (!set-identity-intro p1 p2)

conclude subset-lemma-3 := (forall A t h . A subset h ++ t & h in A ==> exists B . B subset t & A = h ++ B)
pick-any A:(Set.Set 'S) t h:'S 
  assume hyp := (A subset h ++ t & h in A)
    let {p := (!chain-> [(A subset h ++ t) ==> (A - h subset t) [remove-corollary-6]])}
      (!chain-> [(h in A) 
             ==> (A = h ++ (A - h))                   [remove-corollary-8]
             ==> (p & A = h ++ (A - h))               [augment]
             ==> (exists B . B subset t & A = h ++ B) [existence]])

conclude subset-lemma-4 := (forall A h t . ~ h in A & A subset h ++ t ==> A subset t)
pick-any A h t 
  assume hyp := (~ h in A & A subset h ++ t) 
    (!subset-intro
      pick-any x 
       assume (x in A) 
          (!cases (!chain<- [(x = h | x in t) <== (x in h ++ t) [in-def]
                                              <== (x in A)      [SC]])
             (!chain [(x = h) 
                  ==> (~ x in A) [(~ h in A)]
                  ==> (x in A & ~ x in A) [augment]
                  ==> (in x t)   [prop-taut]])
             (!chain [(x in t) ==> (x in t) [claim]])))

conclude subset-lemma-5 := (forall A t h . A subset t ==> A subset h ++ t)
pick-any A t h
  assume hyp := (A subset t)
    (!subset-intro
       pick-any x 
         (!chain [(x in A) ==> (x in t)      [SC]
                           ==> (x in h ++ t) [in-def]]))

conclude subset-lemma-6 := (forall A . A subset null <==> A = null)
pick-any A 
  (!equiv assume (A subset null)
            (!by-contradiction (A = null) 
              assume (A =/= null)
                pick-witness x for (!chain<- [(exists x . x in A) <== (A =/= null) [NC-3]])
                  (!chain-> [(x in A) ==> (x in null) [SC]
                                      ==> false       [NC]]))
          assume (A = null)
            (!chain-> [true ==> (A subset A)    [subset-reflexivity]
                            ==> (A subset null) [(A = null)]]))

conclude subset-lemma-7 := (forall A B x . ~ x in A & B subset A ==> ~ x in B)
pick-any A B x 
  assume hyp := (~ x in A & B subset A)
    (!by-contradiction (~ x in B)
       (!chain [(x in B) ==> (x in A)            [SC]
                         ==> (x in A & ~ x in A) [augment]
                         ==> false               [prop-taut]]))

conclude union-characterization-1 := (forall A B x . x in A \/ B ==> x in A | x in B)
 by-induction union-characterization-1 {
   null => pick-any B x
            (!chain [(x in null \/ B) 
                 ==> (x in B)             [union-def]
                 ==> (x in null | x in B) [alternate]])
 | (A as (h insert t)) =>
    let {IH := (forall B x . x in t \/ B ==> x in t | x in B)}
      pick-any B x        
        (!chain [(x in A \/ B)
             ==> (x in h ++ (t \/ B))        [union-def]
             ==> (x = h | x in t \/ B)       [in-def] 
             ==> (x = h | x in t | x in B)   [IH]
             ==> ((x = h | x in t) | x in B) [prop-taut]
             ==> (x in A | x in B)           [in-def]])
  }

conclude union-characterization-2 := (forall A B x . x in A | x in B ==> x in A \/ B)
   by-induction union-characterization-2 {
    (A as null) => 
       pick-any B x
        (!chain [(x in null | x in B) 
             ==> (false | x in B)     [NC]
             ==> (x in B)             [prop-taut]
             ==> (x in null \/ B)     [union-def]])
 | (A as (insert h t)) => 
     pick-any B x
       let {IH := (forall B x . x in t | x in B ==> x in t \/ B)}
          (!chain [(x in A | x in B)
              ==> ((x = h | x in t) | x in B)   [in-def]
              ==> (x = h | (x in t | x in B))   [prop-taut]
              ==> (x = h | x in t \/ B)         [IH]
              ==> (x in h ++ (t \/ B))          [in-def]
              ==> (x in A \/ B)                 [union-def]])
  }

conclude union-characterization := (forall A B x . x in A \/ B <==> x in A | x in B)
  pick-any A B x
    (!chain [(x in A \/ B) 
        <==> (x in A | x in B) [union-characterization-1 
                                union-characterization-2]])

conclude intersection-characterization-1 := (forall A B x . x in A /\ B ==> x in A & x in B)  
by-induction intersection-characterization-1 {
  null => pick-any B x
            (!chain [(x in null /\ B) 
                 ==> (x in null)          [intersection-def]
                 ==> false                [NC]
                 ==> (x in null & x in B) [prop-taut]])
| (A as (insert h t)) =>
  let {IH := (forall B x . x in t /\ B ==> x in t & x in B)}
    pick-any B x
      (!two-cases
        assume (h in B)
          (!chain [(x in (h ++ t) /\ B)
               ==> (x in h ++ (t /\ B))                  [intersection-def]
               ==> (x = h | x in t /\ B)                 [in-def]
               ==> (x = h | x in t & x in B)             [IH]
               ==> ((x = h | x in t) & (x = h | x in B)) [prop-taut]
               ==> (x in A & (x in B | x in B))          [in-def (h in B)]
               ==> (x in A & x in B)                     [prop-taut]
                 ])
        assume (~ h in B)
          (!chain [(x in A /\ B)  
               ==> (x in t /\ B)     [intersection-def]
               ==> (x in t & x in B) [IH]
               ==> (x in A & x in B) [in-def]]))
    }

conclude intersection-characterization-2 := (forall A B x . x in A & x in B ==> x in A /\ B)
by-induction intersection-characterization-2 {
  (A as null) => 
    pick-any B x
      (!chain [(x in null & x in B) 
           ==> (x in null)          [left-and]
           ==> false                [NC]
           ==> (x in null /\ B)     [prop-taut]])
| (A as (insert h t)) =>
  let {IH := (forall B x . x in t & x in B ==> x in t /\ B)}
    pick-any B x
      (!two-cases
        assume (h in B)
          (!chain [(x in A & x in B)
               ==> ((x = h | x in t) & x in B)            [in-def]
               ==> ((x = h & x in B) | (x in t & x in B)) [prop-taut]
               ==> (x = h | x in t & x in B)              [prop-taut]
               ==> (x = h | x in t /\ B)                  [IH]
               ==> (x in h ++ (t /\ B))                   [in-def]
               ==> (x in A /\ B)                      [intersection-def]])
        assume case2 := (~ h in B)
          (!chain [(x in A & x in B)
               ==> ((x = h | x in t) & x in B)               [in-def]
               ==> ((~ x in B | x in t) & x in B)            [case2]
               ==> ((~ x in B & x in B) | (x in t & x in B)) [prop-taut]
               ==> (false | x in t & x in B)                 [prop-taut]
               ==> (x in t & x in B)                         [prop-taut]
               ==> (x in t /\ B)                             [IH]
               ==> (x in A /\ B)                      [intersection-def]]))
}

conclude intersection-characterization := (forall A B x . x in A /\ B <==> x in A & x in B)
  pick-any A B x
    (!equiv 
       (!chain [(x in A /\ B) 
            ==> (x in A & x in B) [intersection-characterization-1]])
       (!chain [(x in A & x in B) 
            ==> (x in A /\ B)     [intersection-characterization-2]]))

conclude intersection-subset-theorem := (forall A B . A /\ B subset A)
pick-any A B
  (!subset-intro
     pick-any x
       (!chain [(x in A /\ B) 
            ==> (x in A)       [IC]]))

conclude diff-characterization-1 := (forall A B x . x in A \ B ==> x in A & ~ x in B)
 by-induction diff-characterization-1 {
      (A as null) => 
         pick-any B x 
           (!chain [(x in A \ B)
                ==> (x in null)            [diff-def]
                ==> false                  [null-characterization]
                ==> (x in null & ~ x in B) [prop-taut]])
 | (A as (insert h t)) => 
     pick-any B x
       let {ih := (forall B x . x in t \ B ==> x in t & ~ x in B)}
        assume hyp := (x in A \ B)
          (!two-cases
            assume case1 := (h in B)
              (!chain-> [hyp 
                    ==> (x in t \ B)         [diff-def]
                    ==> (x in t & ~ x in B)  [ih]
                    ==> (x in A & ~ x in B)  [in-def]])
            assume case2 := (~ h in B)
              (!cases (!chain<- [(x = h | x in t \ B) 
                             <== (x in h ++ (t \ B)) [in-def]
                             <== hyp                 [diff-def]])
                assume case2-1 := (x = h)
                 (!chain-> [(h = h) 
                        ==> (h in h ++ t)            [in-def]
                        ==> (h in h ++ t & ~ h in B) [augment]
                        ==> (x in A & ~ x in B)      [case2-1]])
                assume case2-2 := (x in t \ B)
                 (!chain-> [case2-2 
                        ==> (x in t & ~ x in B)      [ih]
                        ==> (x in h ++ t & ~ x in B) [in-def]])))
     }

conclude diff-characterization-2 := (forall A B x . x in A & ~ x in B ==> x in A \ B)
 by-induction diff-characterization-2 {
   (A as null) => 
      pick-any B x 
        (!chain [(x in A & ~ x in B) 
             ==> (x in A)             [left-and]
             ==> false                [null-characterization]
             ==> (x in A \ B)         [prop-taut]])
 | (A as (h insert t)) => 
     pick-any B x 
       assume hyp := (x in A & ~ x in B)
         let {ih := (forall B x . x in t & ~ x in B ==> x in t \ B)}
          (!cases (!chain-> [(x in A) ==> (x = h | x in t) [in-def]])
             assume case-1 := (x = h)
               (!chain<- [(x in A \ B) 
                      <== (x in h ++ (t \ B))  [diff-def case-1]
                      <== (h in h ++ (t \ B))  [case-1]
                      <== true                 [in-lemma-1]])
             assume case-2 := (x in t)
               (!two-cases 
                  assume (h in B)
                    (!chain<- [(x in A \ B)
                           <== (x in t \ B)        [diff-def]
                           <== case-2              [ih]])
                  assume (~ h in B) 
 	            (!chain<- [(x in A \ B)
                           <== (x in h ++ (t \ B)) [diff-def]
                           <== (x in t \ B)        [in-def]
                           <== case-2              [ih]])))
  }

conclude diff-characterization := (forall A B x . x in A \ B <==> x in A & ~ x in B)
  pick-any A B x
    (!equiv 
       (!chain [(x in A \ B) 
            ==> (x in A & ~ x in B) [diff-characterization-1]])
       (!chain [(x in A & ~ x in B) 
            ==> (x in A \ B)        [diff-characterization-2]]))

conclude intersection-commutes := (forall A B . A /\ B = B /\ A)
 pick-any A B
   (!set-identity-intro-direct
     pick-any x
       (!chain [(x in A /\ B) <==> (x in A & x in B)  [IC] 
                              <==> (x in B & x in A)  [prop-taut]
                              <==> (x in B /\ A)      [IC]]))

conclude intersection-commutes := (forall A B . A /\ B = B /\ A)
 pick-any A B
   let {A-subset-of-B := 
         (!subset-intro
           pick-any x
            (!chain [(x in A /\ B) 
                 ==> (x in A & x in B) [IC]
                 ==> (x in B & x in A) [prop-taut]
                 ==> (x in B /\ A)     [IC]]));
        B-subset-of-A := 
         (!subset-intro 
            pick-any x 
              (!chain [(x in B /\ A) 
                   ==> (x in B & x in A) [IC]
                   ==> (x in A & x in B) [prop-taut]
                   ==> (x in A /\ B)     [IC]]))
        }
      (!set-identity-intro A-subset-of-B B-subset-of-A)

conclude intersection-commutes := (forall A B . A /\ B = B /\ A)
  let {M := method (A B) # derive (A /\ B subset B /\ A)
              (!subset-intro
                 pick-any x
                   (!chain [(x in A /\ B) 
                        ==> (x in A & x in B) [IC]
                        ==> (x in B & x in A) [prop-taut]
                        ==> (x in B /\ A)     [IC]]))}
    pick-any A B
      (!set-identity-intro (!M A B) (!M B A))

conclude intersection-subset-theorem-2 := (forall A B . A /\ B subset B)
pick-any A B
  (!chain-> [true ==> (B /\ A subset B)  [intersection-subset-theorem]
                  ==> (A /\ B subset B)  [intersection-commutes]])

conclude intersection-subset-theorem' := (forall A B C . A subset B /\ C <==> A subset B & A subset C)
pick-any A B C 
  (!equiv assume (A subset B /\ C)
            (!both (!subset-intro 
                      pick-any x 
                        (!chain [(x in A) ==> (x in B /\ C) [SC]
                                          ==> (x in B)      [IC]]))
		   (!subset-intro 
                      pick-any x 
                        (!chain [(x in A) ==> (x in B /\ C) [SC]
                                          ==> (x in C)      [IC]])))
          assume (A subset B & A subset C)
            (!subset-intro
              pick-any x
               assume (x in A)
                 let {_ := (!chain-> [(x in A) ==> (x in B) [SC]]);
                      _ := (!chain-> [(x in A) ==> (x in C) [SC]]);
                      p := (!both (x in B) (x in C))}
                   (!chain-> [p ==> (x in B /\ C) [IC]])))

conclude union-subset-theorem := (forall A B C . A subset B | A subset C ==> A subset B \/ C)
pick-any A B C 
  assume hyp := (A subset B | A subset C)
    (!cases hyp
      assume (A subset B)
        (!subset-intro
          pick-any x 
            (!chain [(x in A) ==> (x in B)          [SC]
                              ==> (x in B | x in C) [alternate]
                              ==> (x in B \/ C)     [UC]]))
      assume (A subset C)
        (!subset-intro
          pick-any x 
            (!chain [(x in A) ==> (x in C)          [SC]
                              ==> (x in B | x in C) [alternate]
                              ==> (x in B \/ C)     [UC]])))

conclude union-commutes := (forall A B . A \/ B = B \/ A)
 pick-any A B
   (!set-identity-intro-direct
      pick-any x
        (!chain [(x in A \/ B) <==> (x in A | x in B)  [UC] 
                               <==> (x in B | x in A)  [prop-taut]
                               <==> (x in B \/ A)      [UC]]))

conclude intersection-associativity :=  (forall A B C . A /\ (B /\ C) = (A /\ B) /\ C)
 pick-any A B C
   (!set-identity-intro-direct
     pick-any x 
       (!chain [(x in A /\ B /\ C) 
           <==> (x in A & x in B /\ C)       [IC]
           <==> (x in A & x in B & x in C)   [IC]
           <==> ((x in A & x in B) & x in C) [prop-taut]
           <==> ((x in A /\ B) & x in C)     [IC]
           <==> (x in (A /\ B) /\ C)         [IC]]))

conclude union-associativity := (forall A B C . A \/ B \/ C = (A \/ B) \/ C)
 pick-any A B C
   (!set-identity-intro-direct
      pick-any x
        (!chain [(x in A \/ B \/ C) 
            <==> (x in A | x in B \/ C)       [UC] 
            <==> (x in A | x in B | x in C)   [UC]
            <==> ((x in A | x in B) | x in C) [prop-taut]
            <==> (x in A \/ B | x in C)       [UC]
            <==> (x in (A \/ B) \/ C)         [UC]]))

conclude /\-idempotence := (forall A . A /\ A = A)
pick-any A 
 (!set-identity-intro-direct 
   pick-any x 
     (!chain [(x in A /\ A) 
         <==> (x in A & x in A)  [IC]
         <==> (x in A)           [prop-taut]]))

conclude \/-idempotence := (forall A . A \/ A = A)
pick-any A 
  (!set-identity-intro-direct 
    pick-any x 
     (!chain [(x in A \/ A)
         <==> (x in A | x in A)  [UC]
         <==> (x in A)           [prop-taut]]))

conclude union-null-theorem := (forall A B . A \/ B = null <==> A = null & B = null)
pick-any A B 
  (!chain [(A \/ B = null) 
      <==> (forall x . x in A \/ B <==> x in null)       [SIC]
      <==> (forall x . x in A \/ B <==> false)           [NC]
      <==> (forall x . x in A | x in B <==> false)       [UC]
      <==> (forall x . ~ x in A & ~ x in B)              [prop-taut]
      <==> ((forall x . ~ x in A) & (forall x ~ x in B)) [taut]
      <==> (A = null & B = null)                         [NC-2]])    

conclude distributivity-1 := (forall A B C . A \/ (B /\ C) = (A \/ B) /\ (A \/ C))
  pick-any A B C 
    (!set-identity-intro-direct
       pick-any x
         (!chain [(x in A \/ (B /\ C)) 
             <==> (x in A | x in B /\ C)                  [UC]
             <==> (x in A | x in B & x in C)              [IC]
             <==> ((x in A | x in B) & (x in A | x in C)) [prop-taut]
             <==> (x in A \/ B & x in A \/ C)             [UC]
             <==> (x in (A \/ B) /\ (A \/ C))             [IC]]))

conclude distributivity-2 := (forall A B C . A /\ (B \/ C) = (A /\ B) \/ (A /\ C))
    pick-any A B C   
      (!set-identity-intro-direct
        pick-any x 
          (!chain [(x in A /\ (B \/ C)) 
              <==> (x in A & x in B \/ C)                  [IC]
              <==> (x in A & (x in B | x in C))            [UC]
              <==> ((x in A & x in B) | (x in A & x in C)) [prop-taut]
              <==> (x in A /\ B | x in A /\ C)             [IC]
              <==> (x in (A /\ B) \/ (A /\ C))             [UC]]))

conclude diff-theorem-1 := (forall A . A \ A = null)
  pick-any A 
    (!set-identity-intro-direct
       pick-any x
        (!chain [(x in A \ A) 
            <==> (x in A & ~ x in A) [DC]
            <==> false               [prop-taut]
            <==> (x in null)         [NC]]))

conclude diff-theorem-2 := (forall A B C . B subset C ==> A \ C subset A \ B) 
pick-any A B C
  assume (B subset C)
    (!subset-intro
       pick-any x 
        (!chain [(x in A \ C) 
             ==> (x in A & ~ x in C) [DC]
             ==> (x in A & ~ x in B) [SC]
             ==> (x in A \ B)        [DC]]))

conclude diff-theorem-3 := (forall A B . A \ (A /\ B) = A \ B)
    pick-any A B
      (!set-identity-intro-direct
        pick-any x 
          (!chain [(x in A \ (A /\ B)) 
              <==> (x in A & ~ x in A /\ B)                    [DC] 
              <==> (x in A & ~ (x in A & x in B))              [IC]
              <==> (x in A & (~ x in A | ~ x in B))            [prop-taut]
              <==> ((x in A & ~ x in A) | (x in A & ~ x in B)) [prop-taut]
              <==> (false | x in A & ~ x in B)                 [prop-taut]
              <==> (x in A & ~ x in B)                         [prop-taut]
              <==> (x in A \ B)                                [DC]]))

conclude diff-theorem-4 := (forall A B . A /\ (A \ B) = A \ B)
    pick-any A B
      (!set-identity-intro-direct
        pick-any x 
          (!chain [(x in A /\ (A \ B)) 
              <==> (x in A & x in A \ B)        [IC]
              <==> (x in A & x in A & ~ x in B) [DC]
              <==> (x in A & ~ x in B)          [prop-taut]
              <==> (x in A \ B)                 [DC]]))

conclude diff-theorem-5 := (forall A B . (A \ B) \/ B = A \/ B)
    pick-any A B
      (!set-identity-intro-direct
        pick-any x 
          (!chain [(x in (A \ B) \/ B)
              <==> (x in A \ B | x in B)                     [UC]
              <==> ((x in A & ~ x in B) | x in B)            [DC]
              <==> ((x in A | x in B) & (~ x in B | x in B)) [prop-taut]
              <==> ((x in A | x in B) & true)                [prop-taut]
              <==> (x in A | x in B)                         [prop-taut]
              <==> (x in A \/ B)                             [UC]]))

conclude diff-theorem-6 := (forall A B . (A \/ B) \ B = A \ B)
    pick-any A B
      (!set-identity-intro-direct
        pick-any x 
          (!chain [(x in (A \/ B) \ B)        
              <==> (x in A \/ B & ~ x in B)                [DC]
              <==> ((x in A | x in B) & ~ x in B)          [UC]
              <==> (x in A & ~ x in B | x in B & ~ x in B) [prop-taut]
              <==> (x in A & ~ x in B | false)             [prop-taut]
              <==> (x in A \ B | false)                    [DC]
              <==> (x in A \ B)                            [prop-taut]]))

conclude diff-theorem-7 := (forall A B . (A /\ B) \ B = null)
    pick-any A B
      (!set-identity-intro-direct
        pick-any x 
          (!chain [(x in (A /\ B) \ B)        
              <==> (x in A /\ B & ~ x in B)       [DC]
              <==> ((x in A & x in B) & ~ x in B) [IC]
              <==> false                          [prop-taut]
              <==> (x in null)                    [NC]]))

conclude diff-theorem-8 := (forall A B . (A \ B) /\ B = null)
    pick-any A B
      (!set-identity-intro-direct
        pick-any x 
          (!chain [(x in (A \ B) /\ B)        
              <==> (x in A \ B & x in B)          [IC]
              <==> ((x in A & ~ x in B) & x in B) [DC]
              <==> false                          [prop-taut]
              <==> (x in null)                    [NC]]))

conclude diff-theorem-8 := (forall A B C . A \ (B \/ C) = (A \ B) /\ (A \ C))
    pick-any A B C
      (!set-identity-intro-direct
        pick-any x 
          (!chain [(x in A \ (B \/ C)) 
              <==> (x in A & ~ x in B \/ C)                    [DC]
              <==> (x in A & ~ (x in B | x in C))              [UC]
              <==> (x in A & ~ x in B & ~ x in C)              [prop-taut]
              <==> ((x in A & ~ x in B) & (x in A & ~ x in C)) [prop-taut]
              <==> (x in A \ B & x in A \ C)                   [DC]
              <==> (x in (A \ B) /\ (A \ C))                   [IC]]))

conclude diff-theorem-9 := (forall A B C . A \ (B /\ C) = (A \ B) \/ (A \ C))
    pick-any A B C
      (!set-identity-intro-direct
        pick-any x 
          (!chain [(x in A \ (B /\ C)) 
              <==> (x in A & ~ x in B /\ C)                    [DC]
              <==> (x in A & ~ (x in B & x in C))              [IC]
              <==> (x in A & (~ x in B | ~ x in C))            [prop-taut]
              <==> ((x in A & ~ x in B) | (x in A & ~ x in C)) [prop-taut]
              <==> (x in A \ B | x in A \ C)                   [DC]
              <==> (x in (A \ B) \/ (A \ C))                   [UC]]))

conclude diff-theorem-10 := (forall A B . A \ (A \ B) = A /\ B)
  pick-any A B
    (!set-identity-intro-direct
      pick-any x 
         (!chain [(x in A \ (A \ B)) 
             <==> (x in A & ~ x in A \ B)                   [DC]
             <==> (x in A & ~ (x in A & ~ x in B))          [DC]
             <==> (x in A & (~ x in A | ~ ~ x in B))        [prop-taut]
             <==> ((x in A & ~ x in A) | (x in A & x in B)) [prop-taut]
             <==> (false | x in A & x in B)                 [prop-taut]
             <==> (x in A & x in B)                         [prop-taut]
             <==> (x in A /\ B)                             [IC]]))

conclude diff-theorem-11 := (forall A B . A subset B ==> A \/ (B \ A) = B)
  pick-any A B
    assume hyp := (A subset B)
      (!set-identity-intro-direct
        pick-any x 
          (!chain 
            [(x in A \/ (B \ A)) 
        <==> (x in A | x in B \ A)                     [UC]
        <==> (x in A | x in B & ~ x in A)              [DC]
        <==> ((x in A | x in B) & (x in A | ~ x in A)) [prop-taut]
        <==> (x in A | x in B)                         [prop-taut]
        <==> (x in B | x in B)                         [SC prop-taut]
        <==> (x in B)                                  [prop-taut]]))

conclude diff-theorem-12 := (forall A B . A = (A \ B) \/ (A /\ B))
pick-any A B
  (!comm
    (!set-identity-intro-direct
       pick-any x 
         (!chain [(x in (A \ B) \/ (A /\ B))
             <==> (x in A \ B | x in A /\ B)            [UC]
             <==> (x in A & ~ x in B | x in A & x in B) [DC IC]
             <==> (x in A)                              [prop-taut]])))

conclude diff-theorem-13 := (forall A B . (A \ B) /\ (A /\ B) = null)
pick-any A B 
  (!set-identity-intro-direct 
    pick-any x 
      (!chain [(x in (A \ B) /\ (A /\ B)) 
          <==> (x in (A \ B) & x in A /\ B)              [IC]
          <==> ((x in A & ~ x in B) & (x in A & x in B)) [DC IC]
          <==> false                                     [prop-taut]
          <==> (x in null)                               [NC]]))

conclude absorption-1 := (forall x A . x in A <==> x ++ A = A)
  pick-any x A
    (!equiv
       assume hyp := (x in A)        
          (!set-identity-intro-direct 
             pick-any y
               (!chain [(y in x ++ A) 
                  <==> (y = x | y in A)    [in-def]
                  <==> (y in A | y in A)   [hyp prop-taut]
                  <==> (y in A)            [prop-taut]]))
       assume (x ++ A = A)
         (!chain-> [true ==> (x in x ++ A) [in-lemma-1]
                         ==> (x in A)      [set-identity-characterization]]))

conclude subset-theorem-1 := (forall A B . A subset B ==> A \/ B = B) 
pick-any A B
  assume (A subset B)    
    (!set-identity-intro-direct
      pick-any x 
        (!chain [(x in A \/ B) 
            <==> (x in A | x in B) [UC]
            <==> (x in B | x in B) [prop-taut SC]
            <==> (x in B)          [prop-taut]]))

conclude subset-theorem-2 := (forall A B . A subset B ==> A /\ B = A)
  pick-any A B
    assume (A subset B)    
      (!set-identity-intro-direct
        pick-any x 
          (!chain [(x in A /\ B)             
              <==> (x in A & x in B) [IC]
              <==> (x in A & x in A) [prop-taut SC]
              <==> (x in A)          [prop-taut]]))

conclude intersection-lemma-1 := (forall A B x . x in B & x in A ==> A /\ B = (x ++ A) /\ B)
pick-any A B x 
   assume hyp := (x in B &  x in A)
    (!set-identity-intro-direct
      pick-any y 
        (!chain [(y in A /\ B)
            <==> (y in A & y in B)           [IC]         
            <==> ((y = x | y in A) & y in B) [(y in A <==> y = x | y in A) <== (x in A) [in-lemma-4]]
            <==> ((y in x ++ A) & y in B)    [in-def]
            <==> (y in (x ++ A) /\ B)        [IC]]))
           
conclude intersection-lemma-2 := (forall A B x . ~ x in A ==> ~ x in A /\ B)
pick-any A B x 
  assume hyp := (~ x in A) 
    (!by-contradiction (~ x in A /\ B)
       (!chain [(x in A /\ B) 
            ==> (x in A)            [IC]
            ==> (x in A & ~ x in A) [augment]
            ==> false               [prop-taut]]))

conclude intersection-lemma-3 := (forall A . A /\ A = A)
pick-any A 
 (!set-identity-intro-direct 
   pick-any x 
     (!chain [(x in A /\ A) 
         <==> (x in A & x in A)  [IC]
         <==> (x in A)           [prop-taut]]))

conclude insert-in-all-characterization := (forall U s x . s in x in-all U <==> exists B . B in U & s = x ++ B)
by-induction insert-in-all-characterization { 
  (U as null) => pick-any s x 
                   (!equiv (!chain [(s in x in-all U) 
                                ==> (s in null)                     [insert-in-all-def]
                                ==> false                           [NC]
                                ==> (exists B . B in U & s = x ++ B) [prop-taut]])
                           assume hyp := (exists B . B in U & s = x ++ B)
                             pick-witness B for hyp
                               (!chain-> [(B in U)
                                      ==> false    [NC]
                                      ==> (s in x in-all U)  [prop-taut]]))
| (U as (insert A more)) => 
   let {IH := (forall s x . s in x in-all more <==> exists B . B in more & s = x ++ B)}
    pick-any s x 
    let {
         G := (exists B . B in U & s = x ++ B);
         L := conclude ((s = x ++ A | exists B . B in more & s = x ++ B) <==> G)
              (!equiv 
                assume hyp := (s = x ++ A | exists B . B in more & s = x ++ B)
                 (!cases hyp
                    assume (s = x ++ A)
                      (!chain-> [true ==> (A in U)               [in-lemma-1]
                                      ==> (s = x ++ A & A in U)  [augment]
                                      ==> (A in U & s = x ++ A)  [comm]
                                      ==> G                      [existence]])            
                    (!chain [(exists B . B in more & s = x ++ B)
                         ==> (exists B . B in U & s = x ++ B)    [in-def]]))
                assume hyp := (exists B . B in U & s = x ++ B)
                  let {goal := (s = x ++ A | exists B . B in more & s = x ++ B)}
                  pick-witness B for hyp 
                    (!cases (!chain<- [(B = A | B in more) <== (B in U) [in-def]])
                      assume (B = A)
                        (!chain-> [(s = x ++ B) ==> (s = x ++ A) [(B = A)]
                                                ==> goal         [alternate]])
                      assume (B in more)
                        (!chain-> [(B in more) 
                               ==> (B in more & s = x ++ B)            [augment]
                               ==> (exists B . B in more & s = x ++ B) [existence]
                               ==> goal                                [alternate]])))
     }
      (!chain [(s in x in-all U)
          <==> (s in (x ++ A) ++ (x in-all more)) [insert-in-all-def]
          <==> (s = x ++ A | s in x in-all more)  [in-def]
          <==> (s = x ++ A | exists B . B in more & s = x ++ B) [IH]
          <==> G                                               [L]
              ])                                
}

conclude powerset-characterization := (forall A B . B in powerset A <==> B subset A)
by-induction powerset-characterization {
  (A as Set.null) =>
    pick-any B
      (!chain [(B in powerset A)
          <==> (B in singleton null)  [powerset-def]
          <==> (B = null)             [singleton-characterization]
          <==> (B subset null)        [subset-lemma-6]])
| (A as (Set.insert h t:(Set.Set 'S))) => 
    let {IH := (forall B . B in powerset t <==> B subset t)}
    pick-any B:(Set.Set 'S)
      let {e1 := (!chain [(B in powerset A)
                     <==> (B in (powerset t) \/ (h in-all powerset t))   [powerset-def] 
                     <==> (B in powerset t | B in h in-all powerset t)   [UC]
                     <==> (B subset t      | B in h in-all powerset t)   [IH]
                     <==> (B subset t | exists s . s in powerset t & B = h ++ s) [insert-in-all-characterization]
                     <==> (B subset t | exists s . s subset t & B = h ++ s) [IH]]);
      	   lemma := (!chain-> [true ==> (h in h ++ t) [in-lemma-1]]);
           p3 := (assume hyp := (B subset t | exists s . s subset t & B = h ++ s)
                   (!cases hyp 
                     (!chain [(B subset t) ==> (B subset A) [subset-lemma-5]])
                       (assume ehyp := (exists s . s subset t & B = h ++ s)
                         pick-witness s for ehyp
                           (!subset-intro
                             pick-any x
                               assume (x in B)
                                 (!chain-> [(x in B) ==> (x in h ++ s)    [(B = h ++ s)]
                                                     ==> (x = h | x in s) [in-def]
                                                     ==> (x in h ++ t | x in s) [lemma]
                                                     ==> (x in A | x in t)      [SC]
                                                     ==> (x in A | x in A)    [in-def]
                                                     ==> (x in A)             [prop-taut]])))));
            p4 := (assume (B subset A)
   	            (!two-cases
                      assume case1 := (h in B)
                        (!chain-> [(B subset A)
                               ==> (B subset A & h in B) [augment]
                               ==> (exists s . s subset t & B = h ++ s)  [subset-lemma-3]
                               ==> (B subset t | exists s . s subset t & B = h ++ s)  [alternate]])
                      assume case2 := (~ h in B)
                        (!chain-> [case2 ==> (~ h in B & B subset A) [augment]
                                         ==> (B subset t)            [subset-lemma-4]
                                         ==> (B subset t | exists s . s subset t & B = h ++ s) [alternate]])));
            p3<=>p4 := (!equiv p3 p4)}
       (!equiv-tran e1 p3<=>p4)
}

conclude ps-theorem-1 := (forall A . null in powerset A)
  pick-any A
   (!chain-> [true ==> (null subset A)      [subset-def]
                   ==> (null in powerset A) [POSC]])
   
conclude ps-theorem-2 := (forall A . A in powerset A)
  pick-any A 
    (!chain-> [true ==> (A subset A)      [subset-reflexivity]
                    ==> (A in powerset A) [POSC]])

conclude ps-theorem-3 := (forall A B . A subset B <==> powerset A subset powerset B)
pick-any A B
  (!equiv assume (A subset B)
            (!subset-intro
              pick-any C
                (!chain [(C in powerset A)
                     ==> (C subset A)              [POSC]
                     ==> (C subset B)              [subset-transitivity]
                     ==> (C in powerset B)         [POSC]]))
          assume (powerset A subset powerset B)
            (!chain-> [true ==> (A in powerset A)  [ps-theorem-2]
                            ==> (A in powerset B)  [SC]
                            ==> (A subset B)       [POSC]]))

conclude ps-theorem-4 := (forall A B . powerset A /\ B = (powerset A) /\ (powerset B))
pick-any A B
  (!set-identity-intro-direct
    pick-any C
      (!chain 
        [(C in powerset A /\ B)
    <==> (C subset A /\ B)                   [POSC]
    <==> (C subset A & C subset B)           [intersection-subset-theorem']
    <==> (C in powerset A & C in powerset B) [POSC]
    <==> (C in (powerset A) /\ (powerset B)) [IC]]))

conclude ps-theorem-5 := (forall A B . (powerset A) \/ (powerset B) subset powerset A \/ B)
pick-any A B 
  (!subset-intro   
    pick-any C 
      (!chain [(C in (powerset A) \/ (powerset B)) 
           ==> (C in powerset A | C in powerset B)  [UC]
           ==> (C subset A | C subset B)            [POSC]
           ==> (C subset A \/ B)                    [union-subset-theorem]
           ==> (C in powerset A \/ B)               [POSC]]))

conclude paired-with-characterization := (forall B x y a . x @ y in a paired-with B <==> x = a & y in B)
  by-induction paired-with-characterization {
    null => pick-any x y a
                (!chain [(x @ y in a paired-with null) 
                    <==> (x @ y in null)     [paired-with-def]
                    <==> false               [null-characterization]
                    <==> (x = a & false)     [prop-taut]
                    <==> (x = a & y in null) [null-characterization]])
  | (B as (insert h t)) => 
      pick-any x y a
        let {IH := (forall x y a . x @ y in a paired-with t <==> x = a & y in t)}
          (!chain 
            [(x @ y in a paired-with h ++ t)
        <==> (x @ y in a @ h ++ (a paired-with t))      [paired-with-def]
        <==> (x @ y = a @ h | x @ y in a paired-with t) [in-def]
        <==> (x = a & y = h | x @ y in a paired-with t) [pair-axioms]
        <==> (x = a & y = h | x = a & y in t)           [IH]
        <==> (x = a & (y = h | y in t))                 [prop-taut]
        <==> (x = a & y in B)                           [in-def]])
   }

conclude paired-with-lemma-1 := (forall A  x . x paired-with A = null ==> A = null)
datatype-cases paired-with-lemma-1 {
  null => pick-any x
            (!chain [(x paired-with null = null)
                 ==> (null  = null)              [paired-with-def]])
| (insert h t) => 
   pick-any x 
    (!chain 
      [(x paired-with h ++ t = null) 
   ==> (x @ h ++ (x paired-with t) = null)               [paired-with-def]
   ==> (forall z . ~ z in x @ h ++ (x paired-with t))    [NC-2]
   ==> (forall z . ~ (z = x @ h | z in x paired-with t)) [in-def]
   ==> (forall z . z =/= x @ h)                      [prop-taut]
   ==> (x @ h =/= x @ h)                             [(uspec with x @ h)]
   ==> (x @ h =/= x @ h & x @ h = x @ h)             [augment]
   ==> false                                         [prop-taut]
   ==> (h ++ t = null)                               [prop-taut]])
}

conclude cartesian-product-characterization := (forall A B a b . a @ b in A X B <==> a in A & b in B)
by-induction cartesian-product-characterization {
    null => pick-any B a b 
             (!chain [(a @ b in null X B)
                 <==> (a @ b in null)       [product-def]
                 <==> false                 [null-characterization]
                 <==> (a in null & b in B)  [prop-taut null-characterization]])
  | (A as (insert h t)) =>
      let {IH := (forall B a b . a @ b in t X B <==> a in t & b in B)}
       pick-any B a b
         (!chain [(a @ b in h ++ t X B)
             <==> (a @ b in h paired-with B \/ t X B)          [product-def]
             <==> (a @ b in h paired-with B | a @ b in t X B)  [UC]
             <==> (a = h & b in B | a in t & b in B)           [paired-with-characterization IH]
             <==> ((a = h | a in t) & b in B)                  [prop-taut]
             <==> (a in A & b in B)                            [in-def]])
}

conclude cartesian-product-characterization-2 := (forall x A B . x in A X B <==> exists a b . x = a @ b & a in A & b in B)
pick-any x A B
  (!equiv 
     assume hyp := (x in A X B)
       let {p := (!chain-> [true ==> (exists a b . x = a @ b) [pair-axioms]])}
         pick-witnesses a b for p x=a@b
           (!chain-> [x=a@b ==> (a @ b in A X B) [hyp]
                            ==> (a in A & b in B) [CPC]
                            ==> (x=a@b & a in A & b in B) [augment]
                            ==> (exists a b . x = a @ b & a in A & b in B) [existence]])
     assume hyp := (exists a b . x = a @ b & a in A & b in B)
      pick-witnesses a b for hyp spec-premise
         (!chain-> [spec-premise 
                ==> (a in A & b in B)   [prop-taut]
                ==> (a @ b in A X B)    [CPC]
                ==> (x in A X B)        [(x = a @ b)]]))

conclude product-theorem-1 := (forall A B . A X B = null ==> A = null | B = null)
datatype-cases product-theorem-1 {
  null => pick-any B
            (!chain [(null X B = null)
                 ==> (null = null)      [product-def]
                 ==> (null = null | B = null) [alternate]])
 | (A as (insert h t)) =>
     pick-any B
       (!chain [(h ++ t X B = null)
            ==> (h paired-with B \/ t X B = null)       [product-def]
            ==> (h paired-with B = null & t X B = null) [union-null-theorem]
            ==> (B = null)                              [paired-with-lemma-1]
            ==> (h ++ t = null | B = null)                   [alternate]])
}

conclude product-theorem-2 := (forall A B . A X B = null <==> A = null | B = null)
  pick-any A:(Set 'T1)  B:(Set 'T2) 
     (!chain [(A X B = null)
         <==> (forall x . ~ x in A X B)                                 [NC-2]
         <==> (forall x . ~ exists a b . x = a @ b & a in A & b in B)   [CPC-2]
         <==> (forall x a b . a in A & b in B ==> x =/= a @ b)          [taut]
         <==> (forall a b . a in A & b in B ==> forall x . x =/= a @ b) [taut]
         <==> (forall a b . a in A & b in B ==> false)                  [taut]
         <==> (forall a b . ~ a in A | ~ b in B)                        [taut]
         <==> ((forall a . ~ a in A) | (forall b . ~ b in B))           [taut]
         <==> (A = null | B = null)                                     [NC-2]])

conclude product-theorem-3 := (forall A B . non-empty A & non-empty B ==> A X B = B X A <==> A = B)
pick-any A:(Set 'S) B:(Set 'T)
  assume hyp := (non-empty A & non-empty B)
    let {p1 := (!chain-> [(non-empty A) ==> (exists a . a in A) [NC-3]]);
         p2 := (!chain-> [(non-empty B) ==> (exists b . b in B) [NC-3]]);
         M := method (S1 S2 c2) # assumes c2 in S2, S1 X S2 = S2 X S1, 
                (!subset-intro  # and derives (S1 subset S2)
                  pick-any x 
                    (!chain [(x in S1)
                         ==> (x in S1 & c2 in S2) [augment]
                         ==> (x @ c2 in S1 X S2)  [CPC]
                         ==> (x @ c2 in S2 X S1)  [SIC]
                         ==> (x in S2 & c2 in S1) [CPC]
                         ==> (x in S2)            [left-and]]))
         }
      pick-witness a for p1 # (a in A)
        pick-witness b for p2  # (b in B) 
	  (!equiv 
             assume hyp := (A X B = B X A)
               (!set-identity-intro (!M A B b) (!M B A a))
             assume hyp := (A = B)
              (!chain-> [(A X A = A X A) ==> (A X B = B X A) [hyp]]))

conclude product-theorem-4 := (forall A  B C . non-empty A &  A X B subset A X C ==> B subset C)
pick-any A B C
  assume hyp := (non-empty A & A X B subset A X C)
    pick-witness a for (!chain-> [hyp ==> (exists a . a in A) [NC-3]])
      (!subset-intro
         pick-any b
           (!chain [(b in B)
                ==> (a in A & b in B) [augment]
                ==> (a @ b in A X B)  [CPC]
                ==> (a @ b in A X C)  [SC]
                ==> (a in A & b in C) [CPC]
                ==> (b in C)          [right-and]]))

conclude product-theorem-5 := (forall A B C . B subset C ==> A X B subset A X C)
pick-any A B C
 assume (B subset C)
   (!subset-intro
      (!pair-converter 
          pick-any a b
            (!chain [(a @ b in A X B)
                 ==> (a in A & b in B)  [CPC]
                 ==> (a in A & b in C)  [SC]
                 ==> (a @ b in A X C)   [CPC]])))

conclude product-theorem-6 := (forall A B C . A X (B /\ C) = A X B /\ A X C)
pick-any A B C
  (!set-identity-intro-direct 
    (!pair-converter
       pick-any x y
        (!chain [(x @ y in A X (B /\ C))
            <==> (x in A & y in B /\ C)                  [CPC]
            <==> (x in A & y in B & y in C)              [IC]
            <==> ((x in A & y in B) & (x in A & y in C)) [prop-taut]
            <==> (x @ y in A X B & x @ y in A X C)       [CPC]
            <==> (x @ y in A X B /\ A X C)               [IC]])))

conclude product-theorem-7 := (forall A B C . A X (B \/ C) = A X B \/ A X C)
pick-any A B C
  (!set-identity-intro-direct 
    (!pair-converter
       pick-any x y
        (!chain [(x @ y in A X (B \/ C))
            <==> (x in A & y in B \/ C)                  [CPC]
            <==> (x in A & (y in B | y in C))            [UC]
            <==> ((x in A & y in B) | (x in  A & y in C)) [prop-taut]
            <==> (x @ y in A X B | x @ y in A X C)      [CPC]
            <==> (x @ y in A X B \/ A X C)               [UC]])))

conclude product-theorem-8 := (forall A B C . A X (B \ C) = A X B \ A X C)
pick-any A B C
  (!set-identity-intro-direct 
    (!pair-converter
       pick-any x y
         (!chain [(x @ y in A X (B \ C))
             <==> (x in A & y in B \ C)                  [CPC]
             <==> (x in A & y in B & ~ y in C)            [DC]
             <==> ((x in A & y in B) & (~x in A | ~ y in C)) [prop-taut]
             <==> ((x in A & y in B) & ~ (x in A & y in C)) [prop-taut]
             <==> (x @ y in A X B & ~ x @ y in A X C)       [CPC]
             <==> (x @ y in A X B \ A X C)                  [DC]])))

conclude in-dom-lemma-1 := (forall R a x y . a = x ==> a in dom x @ y ++ R)
pick-any R a x y
  (!chain [(a = x) ==> (a in x ++ dom R) [in-def]
                   ==> (a in dom x @ y ++ R) [dom-def]])

conclude in-range-lemma-1 := (forall R a x y . a = y ==> a in range x @ y ++ R)
pick-any R a x y
  (!chain [(a = y) ==> (a in y ++ range R) [in-def]
                   ==> (a in range x @ y ++ R) [range-def]])

conclude in-dom-lemma-2 := (forall R x a b . x in dom R ==> x in dom a @ b ++ R)
pick-any R x a b
  (!chain   [(x in dom a @ b ++ R)
         <== (x in a ++ dom R)     [dom-def]
         <== (x in dom R)          [in-def]])

conclude in-range-lemma-2 := (forall R y a b . y in range R ==> y in range a @ b ++ R)
pick-any R y a b
  (!chain   [(y in range a @ b ++ R)
         <== (y in b ++ range R)       [range-def]
         <== (y in range R)            [in-def]])

conclude dom-characterization := (forall R x . x in dom R <==> exists y . x @ y in R)
by-induction dom-characterization {
  null =>  pick-any x
            (!chain [(x in dom null) 
                <==> (x in null)                 [dom-def]
                <==> false                       [NC]
                <==> (exists y . false)          [taut]
                <==> (exists y . x @ y in null)  [NC]])
| (R as (insert (pair a:'S b) t)) => 
    let {IH := (forall x . x in dom t <==> exists y . x @ y in t)}
      pick-any x:'S   
        let {p1 := assume hyp := (x in dom R)
                     (!cases (!chain<- [(x = a | x in dom t) 
                                    <== (x in a ++ dom t) [in-def]
                                    <== hyp               [dom-def]])

                        assume case1 := (x = a)
                          (!chain-> [true ==> (a @ b in R) [in-lemma-1]
                                          ==> (x @ b in R) [case1]
                                          ==> (exists y . x @ y in R) [existence]])

                        assume case2 := (x in dom t)
                          (!chain-> [case2 ==> (exists y . x @ y in t) [IH]
                                           ==> (exists y . x @ y in R) [ in-def]]));
             p2 := (!chain [(exists y . x @ y in R)
                        ==> (exists y . x @ y = a @ b | x @ y in t) [in-def]
                        ==> (exists y . x = a | x @ y in t)         [pair-axioms]
                        ==> (exists y . x in dom R | x @ y in t)    [in-dom-lemma-1]
                        ==> (exists y . x in dom R | exists z . x @ z in t)    [in-dom-lemma-1 taut]
                        ==> (exists y . x in dom R | x in dom t)    [IH]
                        ==> (exists y . x in dom R | x in dom R)    [in-dom-lemma-2]
                        ==> (x in dom R)                            [taut]])
            }
        (!equiv p1 p2)
}

conclude range-characterization := (forall R y . y in range R <==> exists x . x @ y in R)
by-induction range-characterization {
  null =>  pick-any y
            (!chain [(y in range null) 
                <==> (y in null)                 [range-def]
                <==> false                       [NC]
                <==> (exists y . false)          [taut]
                <==> (exists x . x @ y in null)  [NC]])
| (R as (insert (pair a b:'T) t)) => 
    let {IH := (forall y . y in range t <==> exists x . x @ y in t)}
      pick-any y:'T   
        let {p1 := assume hyp := (y in range R)
                     (!cases (!chain<- [(y = b | y in range t) 
                                    <== (y in b ++ range t) [in-def]
                                    <== hyp                 [range-def]])

                        assume case1 := (y = b)
                          (!chain-> [true ==> (a @ b in R) [in-lemma-1]
                                          ==> (a @ y in R) [case1]
                                          ==> (exists x . x @ y in R) [existence]])

                        assume case2 := (y in range t)
                          (!chain-> [case2 ==> (exists x . x @ y in t) [IH]
                                           ==> (exists x . x @ y in R) [ in-def]]));
             p2 := (!chain [(exists x . x @ y in R)
                        ==> (exists x . x @ y = a @ b | x @ y in t) [in-def]
                        ==> (exists x . y = b | x @ y in t)         [pair-axioms]
                        ==> (exists x . y in range R | x @ y in t)    [in-range-lemma-1]
                        ==> (exists x . y in range R | exists z . z @ y in t)    [in-range-lemma-1 taut]
                        ==> (exists x . y in range R | y in range t)    [IH]
                        ==> (exists x . y in range R | y in range R)    [in-range-lemma-2]
                        ==> (y in range R)                            [taut]])
            }
        (!equiv p1 p2)
}

conclude dom-theorem-1 := (forall R1 R2 . dom (R1 \/ R2) = dom R1 \/ dom R2)
pick-any R1 R2
  (!set-identity-intro-direct
    pick-any x
      (!chain 
        [(x in dom (R1 \/ R2)) 
    <==> (exists y . x @ y in R1 \/ R2)                        [DOMC]
    <==> (exists y . x @ y in R1 | x @ y in R2)                [UC] 
    <==> ((exists y . x @ y in R1) | (exists y . x @ y in R2)) [taut]
    <==> (x in dom R1 | x in dom R2)                           [DOMC]
    <==> (x in dom R1 \/ dom R2)                               [UC]]))

conclude range-theorem-1 := (forall R1 R2 . range (R1 \/ R2) = range R1 \/ range R2)	
pick-any R1 R2
  (!set-identity-intro-direct
     pick-any y
       (!chain [(y in range (R1 \/ R2)) 
           <==> (exists x . x @ y in R1 \/ R2)                        [RANC]
           <==> (exists x . x @ y in R1 | x @ y in R2)                [UC]
           <==> ((exists x . x @ y in R1) | (exists x . x @ y in R2)) [taut]
           <==> (y in range R1 | y in range R2)                       [RANC]
           <==> (y in range R1 \/ range R2)                           [UC]]))

conclude dom-theorem-2 := (forall R1 R2 . dom (R1 /\ R2) subset dom R1 /\ dom R2)
pick-any R1 R2
 (!subset-intro
    pick-any x 
      (!chain [(x in dom (R1 /\ R2))
           ==> (exists y . x @ y in R1 /\ R2)  [DOMC]
           ==> (exists y . x @ y in R1 & x @ y in R2) [IC]
           ==> ((exists y . x @ y in R1) & (exists y . x @ y in R2)) [taut]
           ==> (x in dom R1 & x in dom R2)  [DOMC]
           ==> (x in dom R1 /\ dom R2)      [IC]]))

conclude range-theorem-2 := (forall R1 R2 . range (R1 /\ R2) subset range R1 /\ range R2)
pick-any R1 R2
 (!subset-intro
    pick-any y
      (!chain [(y in range (R1 /\ R2))
           ==> (exists x . x @ y in R1 /\ R2)  [RANC]
           ==> (exists x . x @ y in R1 & x @ y in R2) [IC]
           ==> ((exists x . x @ y in R1) & (exists x . x @ y in R2)) [taut]
           ==> (y in range R1 & y in range R2)  [RANC]
           ==> (y in range R1 /\ range R2)      [IC]]))

conclude dom-theorem-3 := (forall R1 R2 . dom R1 \ dom R2 subset dom (R1 \ R2))
 pick-any R1 R2
   (!subset-intro
      pick-any x 
        assume hyp := (x in dom R1 \ dom R2) 
          let {lemma := (!chain-> [hyp ==> (x in dom R1 & ~ x in dom R2) [DC]])}
           pick-witness w for (!chain-> [lemma ==> (x in dom R1) [left-and]
                                               ==> (exists y . x @ y in R1) [DOMC]])
             (!chain-> [lemma ==> (~ x in dom R2)                [right-and]
                         ==> (~ exists y . x @ y in R2) [DOMC]
                         ==> (forall y . ~ x @ y in R2) [qn]
                         ==> (~ x @ w in R2)  [(uspec with w)]
                         ==> (x @ w in R1 & ~ x @ w in R2) [augment]
                         ==> (exists y . x @ y in R1 & ~ x @ y in R2) [existence]
                         ==> (exists y . x @ y in R1 \ R2)            [DC]
                         ==>  (x in dom (R1 \ R2))            [DOMC]]))

conclude range-theorem-3 := (forall R1 R2 . range R1 \ range R2 subset range (R1 \ R2))
 pick-any R1 R2
   (!subset-intro
      pick-any y
        assume hyp := (y in range R1 \ range R2) 
          let {lemma := (!chain-> [hyp ==> (y in range R1 & ~ y in range R2) [DC]])}
           pick-witness w for (!chain-> [lemma ==> (y in range R1) [left-and]
                                               ==> (exists x . x @ y in R1) [RANC]])
             (!chain-> [lemma ==> (~ y in range R2)                [right-and]
                         ==> (~ exists x . x @ y in R2) [RANC]
                         ==> (forall x . ~ x @ y in R2) [qn]
                         ==> (~ w @ y in R2)  [(uspec with w)]
                         ==> (w @ y in R1 & ~ w @ y in R2) [augment]
                         ==> (exists x . x @ y in R1 & ~ x @ y in R2) [existence]
                         ==> (exists x . x @ y in R1 \ R2)            [DC]
                         ==>  (y in range (R1 \ R2))            [RANC]]))
 
conclude converse-characterization := (forall R x y . x @ y in -- R <==> y @ x in R)
by-induction converse-characterization {
  null => pick-any x y
           (!chain [(x @ y in -- null)
               <==> (x @ y in null)     [conv-def]
               <==> false               [NC]
               <==> (y @ x in null)     [NC]])
| (R as (insert (pair a b) t)) => 
    let {
         IH := (forall x y . x @ y in -- t <==> y @ x in t)}
      pick-any x y 
        (!chain [(x @ y in -- R)
            <==> (x @ y in b @ a ++ -- t)           [conv-def]
            <==> (x @ y = b @ a | x @ y in -- t)    [in-def]
            <==> (y @ x = a @ b | x @ y in -- t)    [pair-lemma-1]
            <==> (y @ x = a @ b | y @ x in t)      [IH]
            <==> (y @ x in R)                      [in-def]])
      }

conclude converse-theorem-1 := (forall R . -- -- R = R)
by-induction converse-theorem-1 {
  null => (!chain [(-- -- null) = (-- null) [conv-def]
                                = null     [conv-def]])
| (R as (insert (pair x y) t)) => 
    let {IH := (-- -- t = t)}
     (!chain [(-- -- x @ y ++ t)
            = (-- (y @ x ++ -- t))  [conv-def]
            = (x @ y ++ -- -- t)    [conv-def]
            = (x @ y ++ t)        [IH]])
}

conclude converse-theorem-2 := (forall R1 R2 . -- (R1 /\ R2) = -- R1 /\ -- R2)
 pick-any R1 R2
   (!set-identity-intro-direct  
     (!pair-converter
        pick-any x y
          (!chain [(x @ y in -- (R1 /\ R2)) 
              <==> (y @ x in R1 /\ R2)             [converse-characterization]
              <==> (y @ x in R1 & y @ x in R2)     [IC] 
              <==> (x @ y in -- R1 & x @ y in -- R2) [converse-characterization]
              <==> (x @ y in -- R1 /\ -- R2)         [IC]])))

conclude converse-theorem-3 := (forall R1 R2 . -- (R1 \/ R2) = -- R1 \/ -- R2)
 pick-any R1 R2
   (!set-identity-intro-direct  
     (!pair-converter
        pick-any x y
          (!chain [(x @ y in -- (R1 \/ R2)) 
              <==> (y @ x in R1 \/ R2)             [converse-characterization]
              <==> (y @ x in R1 | y @ x in R2)     [UC] 
              <==> (x @ y in -- R1 | x @ y in -- R2) [converse-characterization]
              <==> (x @ y in -- R1 \/ -- R2)         [UC]])))

conclude converse-theorem-4 := (forall R1 R2 . -- (R1 \ R2) = -- R1 \ -- R2)
 pick-any R1 R2
   (!set-identity-intro-direct  
     (!pair-converter
        pick-any x y
          (!chain [(x @ y in -- (R1 \ R2)) 
              <==> (y @ x in R1 \ R2)                [converse-characterization]
              <==> (y @ x in R1 & ~ y @ x in R2)     [DC] 
              <==> (x @ y in -- R1 & ~ x @ y in -- R2) [converse-characterization]
              <==> (x @ y in -- R1 \ -- R2)            [DC]])))

conclude composed-with-characterization := (forall R x y z w . w @ z in x @ y composed-with R <==> w = x & y @ z in R)
by-induction composed-with-characterization {
  (R as null) => pick-any x y z w 
                   (!chain [(w @ z in x @ y composed-with null)
                       <==> (w @ z in null)   [composed-with-def]
                       <==> false             [NC]
                       <==> (w = x & y @ z in null)   [prop-taut NC]])
| (R as (insert (pair a b) t)) => 
    pick-any x y z w
      let {IH := (forall x y z w . w @ z in x @ y composed-with t <==> w = x & y @ z in t)}
       (!two-cases
          assume case1 := (y = a)
            (!chain [(w @ z in x @ y composed-with a @ b ++ t)
                <==> (w @ z in x @ b ++ (x @ y composed-with t)) [composed-with-def]
                <==> (w @ z = x @ b | w @ z in x @ y composed-with t) [in-def]
                <==> (w @ z = x @ b | (w = x & y @ z in t))                     [IH]
                <==> (w = x & z = b | w = x & y @ z in t)        [pair-axioms]
                <==> (w = x & y = a & z = b | w = x & y @ z in t) [augment]
                <==> (w = x & y @ z = a @ b | w = x & y @ z in t) [pair-axioms]
                <==> (w = x & (y @ z = a @ b | y @ z in t)) [prop-taut]
                <==> (w = x & y @ z in R)                 [in-def]])
          assume case2 := (y =/= a)
            (!iff-comm 
              (!chain [(w = x & y @ z in R)
                  <==> (w = x & (y @ z = a @ b | y @ z in t))         [in-def]
                  <==> (w = x & (y = a & z = b | y @ z in t))         [pair-axioms]
                  <==> (w = x & (case2 & y = a & z = b | y @ z in t)) [augment]
                  <==> (w = x & (false | y @ z in t))                 [prop-taut]
                  <==> (w = x & y @ z in t)                           [prop-taut] 
                  <==> (w @ z in x @ y composed-with t) [IH]
                  <==> (w @ z in x @ y composed-with R) [composed-with-def]])))
}

conclude composed-with-characterization' := (forall R x y z . x @ z in x @ y composed-with R <==> y @ z in R)
pick-any R x y z 
  (!chain [(x @ z in x @ y composed-with R) 
      <==> (x = x & y @ z in R)  [composed-with-characterization]
      <==> (y @ z in R)          [augment]])

conclude o-characterization := (forall R1 R2 x z . x @ z in R1 o R2 <==> exists y . x @ y in R1 & y @ z in R2)
by-induction o-characterization {
  (R1 as null) => pick-any R2 x z 
                   (!chain [(x @ z in R1 o R2) 
                       <==> (x @ z in null)   [o-def]
                       <==> false             [NC]
                       <==> (exists y . false & y @ z in R2) [(method (p q) (!force q))]
                       <==> (exists y . x @ y in null & y @ z in R2) [NC (method (p q) (!force q))]])
| (R1 as (insert (pair a b) t)) => 
    pick-any R2 x z
      let {IH := (forall R2 x z . x @ z in t o R2 <==> exists y . x @ y in t & y @ z in R2)}
         let {dir1 := assume hyp := (x @ z in R1 o R2)
                        (!cases (!chain-> [hyp 
                                      ==> (x @ z in a @ b composed-with R2 \/ t o R2)           [o-def]
                                      ==> (x @ z in a @ b composed-with R2 | x @ z in t o R2)   [UC]
                                      ==> (x @ z in a @ b composed-with R2 | exists y . x @ y in t & y @ z in R2) [IH]
                                      ==> (x @ z in a @ b composed-with R2 | exists y . x @ y in R1 & y @ z in R2) [in-def]
                                      ==> (x = a & b @ z in R2  | exists y . x @ y in R1 & y @ z in R2) [composed-with-characterization]])
                           assume case1 := (x = a & b @ z in R2)
                             (!chain-> [true ==> (a @ b in R1) [in-lemma-1]
                                             ==> (x @ b in R1) [case1]
                                             ==> (x @ b in R1 & b @ z in R2) [augment]
                                             ==> (exists y . x @ y in R1 & y @ z in R2) [taut]])
                           assume case2 := (exists y . x @ y in R1 & y @ z in R2)
                             (!claim case2));
              dir2 := assume hyp := (exists y . x @ y in R1 & y @ z in R2)
                        pick-witness y for hyp
                          (!cases (!chain-> [(x @ y in R1)
                                            ==> (x @ y = a @ b | x @ y in t) [in-def]])
                             assume case1 := (x @ y = a @ b)
                               let {_ := (!chain-> [case1 ==> (x = a) [pair-axioms]]);
                                    _ := (!chain-> [case1 ==> (y = b) [pair-axioms]])}
                               (!chain-> [(x = a)
                                      ==> (x = a & y @ z in R2) [augment]
                                      ==> (x = a & b @ z in R2) [(y = b)]
                                      ==> (x @ z in a @ b composed-with R2) [composed-with-characterization]
                                      ==> (x @ z in a @ b composed-with R2 \/ t o R2) [UC]
                                      ==> (x @ z in R1 o R2) [o-def]])
                             assume case2 := (x @ y in t)
                              (!chain-> [case2 
                                     ==> (x @ y in t & y @ z in R2) [augment]
                                     ==> (exists y . x @ y in t & y @ z in R2) [existence]
                                     ==> (x @ z in t o R2) [IH]
                                     ==> (x @ z in a @ b composed-with R2 | x @ z in t o R2) [prop-taut]
                                     ==> (x @ z in a @ b composed-with R2 \/ t o R2) [UC]
                                     ==> (x @ z in R1 o R2)                          [o-def]]))
             }
         (!equiv dir1 dir2)
}

conclude compose-theorem-1 := (forall R1 R2 . dom R1 o R2 subset dom R1)
pick-any R1 R2
  (!subset-intro
     pick-any x
       (!chain [(x in dom R1 o R2)
            ==> (exists y . x @ y in R1 o R2)                       [dom-characterization]
            ==> (exists y . exists z . x @ z in R1 & z @ y in R2)   [o-characterization]
            ==> (exists y . exists z . x @ z in R1)                 [taut]
            ==> (exists y . x in dom R1)                            [dom-characterization]
            ==> (x in dom R1)                                       [taut]]))

conclude compose-theorem-2 := (forall R1 R2 R3 R4 . R1 subset R2 & R3 subset R4 ==> R1 o R3 subset R2 o R4)
pick-any R1:(Set (Pair 'S 'T)) R2:(Set (Pair 'S 'T))
         R3:(Set (Pair 'T 'U)) R4:(Set (Pair 'T 'U))
  assume hyp :=  (R1 subset R2 & R3 subset R4)
    (!subset-intro
       (!pair-converter 
          pick-any x y
            (!chain [(x @ y in R1 o R3)
                 ==> (exists z . x @ z in R1 & z @ y in R3)  [o-characterization] 
                 ==> (exists z . x @ z in R2 & z @ y in R3)  [SC]
                 ==> (exists z . x @ z in R2 & z @ y in R4)  [SC]
                 ==> (x @ y in R2 o R4)                      [o-characterization]])))

conclude compose-theorem-3 := (forall R1 R2 R3  . R1 o (R2 \/ R3) = R1 o R2 \/ R1 o R3)
pick-any R1 R2 R3
  (!set-identity-intro-direct 
     (!pair-converter
        pick-any x y 
          (!chain [(x @ y in R1 o (R2 \/ R3)) 
              <==> (exists z . x @ z in R1 & z @ y in R2 \/ R3) [o-characterization]
              <==> (exists z . x @ z in R1 & (z @ y in R2 | z @ y in R3)) [UC]
              <==> (exists z . x @ z in R1 & z @ y in R2 | x @ z in R1 & z @ y in R3) [prop-taut]
              <==> ((exists z . x @ z in R1 & z @ y in R2) | (exists z . x @ z in R1 & z @ y in R3)) [taut]
              <==> (x @ y in R1 o R2 |  x @ y in R1 o R3) [o-characterization]
              <==> (x @ y in R1 o R2 \/ R1 o R3) [UC]])))

conclude compose-theorem-4 := (forall R1 R2 R3  . R1 o (R2 /\ R3) subset R1 o R2 /\ R1 o R3)
pick-any R1 R2 R3
  (!subset-intro
     (!pair-converter
        pick-any x y 
          (!chain [(x @ y in R1 o (R2 /\ R3)) 
               ==> (exists z . x @ z in R1 & z @ y in R2 /\ R3) [o-characterization]
               ==> (exists z . x @ z in R1 & (z @ y in R2 & z @ y in R3)) [IC]
               ==> (exists z . (x @ z in R1 & z @ y in R2) & (x @ z in R1 & z @ y in R3)) [prop-taut]                
               ==> ((exists z . x @ z in R1 & z @ y in R2) & (exists z . x @ z in R1 & z @ y in R3)) [taut]
               ==> (x @ y in R1 o R2 & x @ y in R1 o R3) [o-characterization]
               ==> (x @ y in R1 o R2 /\ R1 o R3)         [IC]])))

conclude compose-theorem-5 := (forall R1 R2 R3 . R1 o R2 \ R1 o R3 subset R1 o (R2 \ R3))
pick-any R1 R2 R3
  (!subset-intro
     (!pair-converter
        pick-any x y 
          (!chain [(x @ y in R1 o R2 \ R1 o R3)
               ==> (x @ y in R1 o R2 & ~ x @ y in R1 o R3) [DC]
               ==> ((exists z . x @ z in R1 & z @ y in R2) & ~ (exists z . x @ z in R1  & z @ y in R3)) [o-characterization] 
               ==> (exists z . x @ z in R1 & z @ y in R2 & ~ z @ y in R3)  [taut]
               ==> (exists z . x @ z in R1 & z @ y in R2 \ R3)  [DC]
               ==> (x @ y in R1 o (R2 \ R3))  [o-characterization]])))

conclude composition-assoc := (forall R1 R2 R3 . R1 o R2 o R3 = (R1 o R2) o R3)
pick-any R1 R2 R3
  (!set-identity-intro-direct
     (!pair-converter
        pick-any x y 
          (!chain [(x @ y in R1 o R2 o R3)
              <==> (exists z . x @ z in R1 & z @ y in R2 o R3)                    [o-characterization]
              <==> (exists z . x @ z in R1 & exists w . z @ w in R2 & w @ y in R3) [o-characterization]
              <==> (exists w z . x @ z in R1 & z @ w in R2 & w @ y in R3)          [taut]
              <==> (exists w . (exists z . x @ z in R1 & z @ w in R2)  & w @ y in R3)          [taut]
              <==> (exists w . x @ w in R1 o R2  & w @ y in R3)          [o-characterization]
              <==> (x @ y in (R1 o R2) o R3)                             [o-characterization]])))

conclude compose-theorem-6 := (forall R1 R2 . -- (R1 o R2) = -- R2 o -- R1)
 pick-any R1 R2 
   (!set-identity-intro-direct
     (!pair-converter
       pick-any x y
          (!chain [(x @ y in -- (R1 o R2))
              <==> (y @ x in R1 o R2)       [converse-characterization]
              <==> (exists z . y @ z in R1 & z @ x in R2) [o-characterization] 
              <==> (exists z . z @ y in -- R1 & x @ z in -- R2) [converse-characterization]
              <==> (exists z . x @ z in -- R2 & z @ y in -- R1) [prop-taut]
              <==> (x @ y in -- R2 o -- R1)                  [o-characterization]])))

conclude restrict1-lemma := (forall R x y a . x @ y in R & x = a ==> x @ y in R ^1 a)
by-induction restrict1-lemma {
 (R as null) => pick-any x y a 
                 (!chain [(x @ y in R & x = a)
                      ==> (x @ y in R)          [left-and]
                      ==> false                 [NC]
                      ==> (x @ y in R ^1 a)     [prop-taut]])
| (R as (insert (pair x' y') t)) => 
     let {IH := (forall x y a . x @ y in t & x = a ==> x @ y in t ^1 a)}
       pick-any x y a 
         assume hyp := (x @ y in R & x = a)
           (!two-cases 
              assume case1 := (x' = a)
                (!chain-> [hyp 
                       ==> ((x @ y = x' @ y' | x @ y in t) & x = a) [in-def]
                       ==> (x @ y = x' @ y' & x = a | x @ y in t & x = a) [prop-taut]
                       ==> (x @ y in x' @ y' ++ (t ^1 a) & x = a | x @ y in t & x = a) [in-def]
                       ==> (x @ y in R ^1 a & x = a | x @ y in t & x = a) [restrict1-def]
                       ==> (x @ y in R ^1 a & x = a | x @ y in t ^1 a)    [IH]
                       ==> (x @ y in R ^1 a & x = a | x @ y in x' @ y' ++ (t ^1 a)) [in-def]
                       ==> (x @ y in R ^1 a & x = a | x @ y in R ^1 a)    [restrict1-def]
                       ==> (x @ y in R ^1 a)  [prop-taut]])
              assume case2 := (x' =/= a)
                (!cases (!chain-> [hyp 
                               ==> ((x @ y = x' @ y' | x @ y in t) & x = a) [in-def]
                               ==> ((x = x' & y = y' | x @ y in t) & x = a) [pair-axioms]
                               ==> (x = x' & y = y' & x = a | x @ y in t & x = a) [prop-taut]])
                    assume hyp1 := (x = x' & y = y' & x = a)
                       let {_ := (!absurd (!chain-> [hyp1 ==> (x = a)
                                                         ==> (x' = a)])
                                          case2)}
                         (!from-false (x @ y in R ^1 a))
                    assume hyp2 := (x @ y in t & x = a)
                      (!chain-> [hyp2 ==> (x @ y in t ^1 a)  [IH]
                                      ==> (x @ y in R ^1 a)  [restrict1-def]])))
}

conclude restrict1-characterization := (forall R x y a . x @ y in R restrict1 a <==> x @ y in R & x = a)
by-induction restrict1-characterization {
  (R as null) => pick-any x y a
                   (!chain [(x @ y in R ^1 a) 
                       <==> (x @ y in null)         [restrict1-def]
                       <==> false                   [NC]
                       <==> (false & x = a)         [prop-taut]
                       <==> (x @ y in R & x = a)    [NC]])
| (R as (insert (pair x' y') t)) => 
    pick-any x y a
      let {IH := (forall x y a . x @ y in t ^1 a <==> x @ y in t & x = a);
           goal := (x @ y in R ^1 a <==> x @ y in R & x = a);
           dir1 := assume hyp := (x @ y in R ^1 a)
                    (!two-cases
                       assume case1 := (x' = a)
                         (!cases (!chain-> [hyp
                                        ==> (x @ y in x' @ y' ++ (t ^1 a))       [restrict1-def]
                                        ==> (x @ y = x' @ y' | x @ y in t ^1 a)  [in-def]])
                            assume hyp1a := (x @ y = x' @ y')
                              (!both (!chain-> [hyp1a ==> (x @ y in R) [in-def]])
  			      	     (!chain-> [hyp1a ==> (x = x') [pair-axioms]
                                                      ==> (x = a)           [case1]]))
                            (!chain [(x @ y in t ^1 a) ==> (x @ y in t & x = a) [IH]
                                                       ==> (x @ y in R & x = a) [in-def]]))
                       assume case2 := (x' =/= a)
                         (!chain-> [hyp ==> (x @ y in t ^1 a)    [restrict1-def]
                                        ==> (x @ y in t & x = a) [IH]
                                        ==> (x @ y in R & x = a) [in-def]]));
           dir2 := (!chain [(x @ y in R & x = a) ==> (x @ y in R ^1 a) [restrict1-lemma]])}
       (!equiv dir1 dir2)
}

conclude restrict-characterization := (forall A R x y . x @ y in R restrict A <==> x @ y in R & x in A)
by-induction restrict-characterization {
  (A as null) => pick-any R x y
                   (!chain [(x @ y in R restrict A)
                       <==> (x @ y in null)          [restrict-def]
                       <==> false                    [NC]
                       <==> (x @ y in R & false)     [prop-taut]
                       <==> (x @ y in R & x in A)   [NC]])
| (A as (insert h t)) =>    
    let {IH := (forall R x y . x @ y in R restrict t <==> x @ y in R & x in t)}
      pick-any R x y 
        (!chain [(x @ y in R restrict A)
            <==> (x @ y in R ^1 h \/ R restrict t)         [restrict-def]
            <==> (x @ y in R ^1 h | x @ y in R restrict t) [UC] 
            <==> ((x @ y in R & x = h) | x @ y in R restrict t) [restrict1-characterization]
            <==> ((x @ y in R & x = h) | x @ y in R & x in t)   [IH]
            <==> ((x @ y in R) & (x = h | x in t))              [prop-taut]
            <==> (x @ y in R & x in A)                          [in-def]])
}

conclude restriction-theorem-1 := (forall R A B . A subset B ==> R ^ A subset R ^ B)
pick-any R A B
  assume (A subset B)
    (!subset-intro
       (!pair-converter
          pick-any x y
           (!chain [(x @ y in R ^ A)
                ==> (x @ y in R & x in A) [restrict-characterization]
                ==> (x @ y in R & x in B) [SC]
                ==> (x @ y in R ^ B)      [restrict-characterization]])))

conclude restriction-theorem-2 := (forall R A B . R ^ (A /\ B) = R ^ A /\ R ^ B)
pick-any R A B
  (!set-identity-intro-direct
    (!pair-converter
      pick-any x y
        (!chain [(x @ y in R ^ (A /\ B))
            <==> (x @ y in R & x in A /\ B)                      [restrict-characterization]
            <==> (x @ y in R & x in A & x in B)                  [IC]
            <==> ((x @ y in R & x in A) & (x @ y in R & x in B)) [prop-taut]
            <==> (x @ y in R ^ A & x @ y in R ^ B)               [restrict-characterization]
            <==> (x @ y in R ^ A /\ R ^ B)                       [IC]])))

conclude restriction-theorem-3 := (forall R A B . R ^ (A \/ B) = R ^ A \/ R ^ B)
pick-any R A B
  (!set-identity-intro-direct
    (!pair-converter
      pick-any x y
        (!chain [(x @ y in R ^ (A \/ B))
            <==> (x @ y in R & x in A \/ B)                      [restrict-characterization]
            <==> (x @ y in R & (x in A | x in B))                [UC]
            <==> ((x @ y in R & x in A) | (x @ y in R & x in B)) [prop-taut]
            <==> (x @ y in R ^ A | x @ y in R ^ B)               [restrict-characterization]
            <==> (x @ y in R ^ A \/ R ^ B)                       [UC]])))

conclude restriction-theorem-4 := (forall R A B . R ^ (A \ B) = R ^ A \ R ^ B)
pick-any R A B
  (!set-identity-intro-direct
    (!pair-converter
      pick-any x y
        (!chain [(x @ y in R ^ (A \ B))
            <==> (x @ y in R & x in A \ B)                      [restrict-characterization]
            <==> (x @ y in R & (x in A & ~ x in B))                  [DC]
            <==> ((x @ y in R & x in A) & ~ (x @ y in R & x in B)) [prop-taut]
            <==> (x @ y in R ^ A & ~ x @ y in R ^ B)               [restrict-characterization]
            <==> (x @ y in R ^ A \ R ^ B)                       [DC]])))

conclude restriction-theorem-5 := (forall R1 R2 A . (R1 o R2) ^ A = (R1 ^ A) o R2)
pick-any R1 R2 A
  (!set-identity-intro-direct
    (!pair-converter
      pick-any x y
        (!chain [(x @ y in (R1 o R2) ^ A)
            <==> (x @ y in R1 o R2 & x in A)                         [restrict-characterization]
            <==> ((exists z . x @ z in R1 & z @ y in R2) & x in A)   [o-characterization]
            <==> (exists z . x @ z in R1 & z @ y in R2 & x in A)     [taut]
            <==> (exists z . (x @ z in R1 & x in A) & z @ y in R2)   [prop-taut]
            <==> (exists z . x @ z in R1 ^ A & z @ y in R2)          [restrict-characterization]
            <==> (x @ y in (R1 ^ A) o R2)                            [o-characterization]])))

conclude image-characterization := (forall R A y . y in R ** A <==> exists x . x @ y in R & x in A)
pick-any R A y
  (!chain [(y in R ** A)
      <==> (y in range R ^ A)   [image-def]
      <==> (exists x . x @ y in R ^ A) [range-characterization]
      <==> (exists x . x @ y in R  & x in A) [restrict-characterization]])

conclude image-lemma := (forall R A x y . x @ y in R & x in A ==> y in R ** A)
pick-any R A x y 
  (!chain [(x @ y in R & x in A)
       ==> (exists x . x @ y in R & x in A) [existence]
       ==> (y in R ** A)                    [image-characterization]])

conclude image-theorem-1 := (forall R A B . R ** (A \/ B) = R ** A \/ R ** B)
pick-any R A B
  (!set-identity-intro-direct   
      pick-any y
        (!chain [(y in R ** (A \/ B))
           <==> (exists x . x @ y in R & x in A \/ B)  [image-characterization]
           <==> (exists x . x @ y in R & (x in A | x in B))  [UC]
           <==> (exists x . (x @ y in R & x in A) | (x @ y in R & x in B)) [prop-taut]
           <==> ((exists x . x @ y in R & x in A) | (exists x . x @ y in R & x in B)) [taut]
           <==> (y in R ** A | y in R ** B)  [image-characterization]
           <==> (y in R ** A \/ R ** B)      [UC]]))

conclude image-theorem-2 := 
  (forall R A B . R ** (A /\ B) subset R ** A /\ R ** B)
pick-any R A B
  (!subset-intro
      pick-any y
        (!chain [(y in R ** (A /\ B))
           ==> (exists x . x @ y in R & x in A /\ B)  [image-characterization]
           ==> (exists x . x @ y in R & x in A & x in B)  [IC]
           ==> (exists x . (x @ y in R & x in A)  & (x @ y in R & x in B)) [prop-taut]
           ==> ((exists x . x @ y in R & x in A) & (exists x . x @ y in R & x in B)) [taut]
           ==> (y in R ** A & y in R ** B) [image-characterization]
           ==> (y in R ** A /\ R ** B) [IC]]))

conclude image-theorem-3 := (forall R A B . R ** A \ R ** B subset R ** (A \ B))
pick-any R A B
  (!subset-intro
      pick-any y
        (!chain [(y in R ** A \ R ** B)
             ==> (y in R ** A & ~ y in R ** B)  [DC]
             ==> ((exists x . x @ y in R & x in A) & ~ (exists x . x @ y in R & x in B))   [image-characterization] 
             ==> ((exists x . x @ y in R & x in A) & (forall x . x @ y in R ==> ~ x in B))  [taut]
             ==> (exists x . x @ y in R & x in A & ~ x in B) [taut]
             ==> (exists x . x @ y in R & x in A \ B)        [DC]
             ==> (y in R ** (A \ B))                         [image-characterization]]))

conclude image-theorem-4 := (forall R A B . A subset B ==> R ** A subset R ** B)
pick-any R A B
  assume hyp := (A subset B)
    (!subset-intro
       pick-any y
         (!chain [(y in R ** A)
              ==> (exists x . x @ y in R & x in A) [image-characterization]
              ==> (exists x . x @ y in R & x in B) [SC]
              ==> (y in R ** B)                    [image-characterization]]))

conclude image-theorem-5 := (forall R A . R ** A = null <==> dom R /\ A = null)
pick-any R A 
  (!chain [(R ** A = null)
     <==>  (forall y . ~ y in R ** A)  [null-characterization-2]
     <==> (forall y . ~ exists x . x @ y in R & x in A) [image-characterization]
     <==> (forall x . ~ exists y . x @ y in R & x in A) [taut]
     <==> (forall x . ~ ((exists y . x @ y in R) & x in A)) [taut] 
     <==> (forall x . ~ (x in dom R & x in A)) [dom-characterization]
     <==> (forall x . ~ (x in dom R /\ A)) [IC]
     <==> (dom R /\ A = null)  [null-characterization-2]])

conclude image-theorem-6 := (forall R A . dom R /\ A subset -- R ** R ** A)
pick-any R A 
  (!subset-intro
    pick-any x
      (!chain [(x in dom R /\ A)
           ==> (x in dom R & x in A) [IC]
           ==> ((exists y . x @ y in R) & x in A) [dom-characterization]
           ==> (exists y . x @ y in R & x @ y in R & x in A)   [taut]
           ==> (exists y . x @ y in R & y in R ** A)   [image-lemma]
           ==> (exists y . y @ x in -- R & y in R ** A)   [converse-characterization]
           ==> (x in -- R ** R ** A)                     [image-characterization]]))

conclude image-theorem-7 := (forall R A B . (R ** A) /\ B subset R ** (A /\ -- R ** B))
pick-any R A B
  (!subset-intro
     pick-any y
       (!chain [(y in (R ** A) /\ B)
            ==> (y in R ** A & y in B) [IC]
            ==> ((exists x . x @ y in R & x in A) & y in B) [image-characterization]
            ==> (exists x . x @ y in R & x in A & y in B)   [taut]
            ==> (exists x .   y @ x in -- R & x in A & x @ y in R & y in B)   [converse-characterization augment]
            ==> (exists x .   (y @ x in -- R & y in B) & x in A & x @ y in R)   [prop-taut]
            ==> (exists x .   x in -- R ** B & x in A & x @ y in R)   [image-lemma]
            ==> (exists x .   x @ y in R & (x in A & x in -- R ** B))   [prop-taut]
            ==> (exists x .   x @ y in R & x in A /\ -- R ** B)   [IC]
            ==> (y in R ** (A /\ -- R ** B))            [image-characterization]]))

conclude card-theorem-2 := (forall A x . ~ x in A ==> card A < card x ++ A)
pick-any A x
  assume hyp := (~ x in A)
     (!chain-> [true ==> (card A < S card A)    [N.Less.<S]
                     ==> (card A < card x ++ A) [card-def]])
 
conclude minus-card-theorem := (forall A x . x in A ==> card A = N.S card A - x)
by-induction minus-card-theorem {
  (A as null:(Set.Set 'S)) => 
     pick-any x       
       (!chain [(x in A) 
            ==> false     [NC]
            ==> (card A = N.S card A - x) [prop-taut]])
| (A as (insert h:'S t:(Set.Set 'S))) => 
    let {IH := (forall x . x in t ==> card t = N.S card (t - x))}
      pick-any x:'S
        assume hyp := (x in A)
          (!two-cases 
             assume case1 := (x = h)
               (!two-cases
                 assume (h in t)
                   let {_ := (!chain-> [(h in t) ==> (x in t) [case1]])}
                    (!chain [(card A) 
                           = (card t)             [card-def]
                           = (N.S (card t - x))   [IH]
                           = (N.S (card A - x))   [remove-def]])
                 assume (~ h in t)
                   let {_ := (!chain-> [(~ h in t) ==> (~ x in t) [case1]])}
                     (!combine-equations
                       (!chain [(card A) = (N.S card t)])
                       (!chain [(N.S card (A - x))
                              = (N.S card (t - x))
                              = (N.S card t)])))
                 assume case2 := (x =/= h)
                   let {_ := (!chain-> [(x in A) 
                                    ==> (x = h | x in t)  [in-def]
                                    ==> (x in t)          [(dsyl with case2)]])}
                     (!two-cases
                       assume (h in t)
                         let {_ := (!chain-> [(h in t) 
                                          ==> (h in t & x =/= h) [augment] 
                                          ==> (h in t - x)       [remove-corollary-3]])}
 	                   (!chain [(card A)
                                  = (card t)                  [card-def] 
                                  = (N.S card (t - x))        [IH]
                                  = (N.S card h ++ (t - x))   [card-def]
                                  = (N.S card (A - x))        [remove-def]])
                       assume (~ h in t)
		         let {_ := (!chain-> [(~ h in t) ==> (~ h in t - x) [remove-corollary-4]])}
                           (!chain-> [(card t) = (N.S card t - x) [IH]
                                  ==> (N.S card t = N.S N.S card t - x)
                                  ==> (card A     = N.S N.S card t - x)    [card-def]
                                  ==> (card A     = N.S card h ++ (t - x)) [card-def]
                                  ==> (card A     = N.S card A - x)        [remove-def]])))
}

conclude subset-card-theorem := (forall A B . A subset B ==> card A <= card B)
by-induction subset-card-theorem {
  null => pick-any B:(Set.Set 'S)
            assume hyp := (null subset B)
                (!chain-> [true ==> (zero <= card B)   [N.Less=.zero<=]
                                ==> (card null:(Set.Set 'S) <= card B) [card-def]])
| (A as (insert h:'S t:(Set.Set 'S))) =>  
   let {IH := (forall B . t subset B ==> card t <= card B)}
    pick-any B:(Set.Set 'S)
      assume hyp := (A subset B)
        (!two-cases
           assume case1 := (in h t)
             (!chain-> [hyp ==> (t subset B)          [subset-lemma-2]
                            ==> (card t <= card B)    [IH]
                            ==> (card A <= card B)    [card-def]])
           assume case2 := (~ in h t)
             let {t-sub-B := (!chain-> [hyp ==> (t subset B)          [subset-lemma-2]]);
                  _ := (!chain-> [true 
                              ==> (in h A) [in-lemma-1]
                              ==> (in h B) [SC]])}
               (!chain-> [t-sub-B ==> (t subset B & case2)  [augment]
                                  ==> (t subset B - h)     [remove-corollary-5]
                                  ==> (card t <= card B - h) [IH]
                                  ==> (S card t <= S card B - h) 
                                  ==> (S card t <= card B)     [minus-card-theorem]
                                  ==> (card A <= card B)       [card-def]]))
}

conclude proper-subset-card-theorem := (forall A B . A proper-subset B ==> card A < card B)
pick-any A B
  assume hyp := (A proper-subset B)
    pick-witness x for (!chain-> [hyp ==> (A subset B & exists x . x in B & ~ x in A) [PSC]
                                      ==> (exists x . x in B & ~ x in A)              [right-and]])
      let {L1 := (!chain-> [hyp ==> (A subset B)      [PSC]
                               ==> (x ++ A subset B) [subset-lemma-1]
                               ==> (card x ++ A <= card B) [subset-card-theorem]]);
           L2 := (!chain-> [(~ x in A) ==> (card A < card x ++ A) [card-theorem-2]])}
        (!chain-> [L1 ==> (L1 & L2) [augment]
                      ==> (card A < card B)   [N.Less=.transitive1]])

conclude intersection-card-theorem-1 := (forall A B . card A /\ B <= card A)
pick-any A B 
  (!chain-> [true ==> (A /\ B subset A)       [intersection-subset-theorem]
                  ==> (card A /\ B <= card A) [subset-card-theorem]])

conclude intersection-card-theorem-2 := (forall A B . card A /\ B <= card B)
pick-any A B 
  (!chain-> [true ==> (A /\ B subset B)       [intersection-subset-theorem-2]
                  ==> (card A /\ B <= card B) [subset-card-theorem]])

conclude intersection-card-theorem-3 := (forall A B x . ~ x in A & x in B ==> card (x ++ A) /\ B = N.S card A /\ B)
pick-any A B x 
  assume hyp := (~ x in A & x in B)  
    let {_ := (!chain-> [(~ x in A) ==> (~ x in A /\ B) [intersection-lemma-2]])}
      (!chain [(card (x ++ A) /\ B)
             = (card x ++ (A /\ B))   [intersection-def]
             = (S card A /\ B)        [card-def]])

conclude num-lemma := (forall x y z . (x + y) - z = (S x + y) - S z)
pick-any x:N y:N z:N 
   (!chain-> [((S x +  y) -  S z)
            = (S (x + y) - S z)        [N.Plus.left-nonzero]
            = ((x + y) - z)            [N.Minus.axioms]
          ==> ((x + y) - z = (S x + y) - S z) [sym]])

conclude lemma-p1 := (forall A B x . ~ x in A and x in B ==> card (x ++ A) /\ B = S card A /\ B)
pick-any A B x
  assume hyp := (~ x in A & x in B)
    let {_ := (!chain-> [(~ x in A) 
                     ==> (~ x in A /\ B) [intersection-lemma-2]])}
      (!chain [(card x ++ A /\ B)  
             = (card x ++ (A /\ B)) [intersection-def]
             = (S card A /\ B)      [card-def]])

conclude lemma-p2 := (forall A B x . ~ x in A & ~ x in B ==> A /\ B = (x ++ A) /\ B)
pick-any A B x 
  assume hyp := (~ x in A & ~ x in B) 
    (!set-identity-intro-direct
      pick-any y 
        (!equiv assume hyp1 := (y in A /\ B)
                  let {L1 := (!chain-> [hyp1 ==> (y in A) [IC]
                                            ==> (y = x | y in A) [alternate]
                                            ==> (y in x ++ A)    [in-def]]);
                       L2 := (!chain-> [hyp1 ==> (y in B) [IC]])}
                   (!chain-> [L1 
                          ==> (L1 & L2)            [augment]
                          ==> (y in (x ++ A) /\ B) [IC]]) 
		assume hyp2 := (y in (x ++ A) /\ B)
                  let {L1 := (!chain-> [hyp2 ==> (y in B)      [IC]]);
                       L2 := (!by-contradiction (y =/= x) 
                               assume (y = x)
                                 (!chain-> [(y in B) ==> (x in B)            [(y = x)]
                                                     ==> (x in B & ~ x in B) [augment]
                                                     ==> false               [prop-taut]]))}
                    (!chain-> [hyp2 ==> (y in x ++ A)     [IC]
                                    ==> (y = x | y in A)  [in-def]
                                    ==> ((y = x | y in A) & y =/= x) [augment]
                                    ==> (((y = x) & (y =/= x)) | (y in A & y =/= x)) [prop-taut]
                                    ==> (false | y in A & y =/= x)                   [prop-taut]
                                    ==> (y in A)                                     [prop-taut]
                                    ==> (y in A & y in B)                            [augment]
                                    ==> (y in A /\ B)                                [IC]])))

conclude union-lemma-2 := (forall A B x . x ++ (A \/ B) = A \/ x ++ B)
pick-any A B x
  (!chain [(x ++ (A \/ B)) 
        = (x ++ (B \/ A)) [union-commutes]
        = ((x ++ B) \/ A) [union-def]
        = (A \/ (x ++ B)) [union-commutes]])

conclude union-subset-lemma-1 := (forall A B . A subset A \/ B)
  pick-any A B
    (!subset-intro 
       pick-any x
         (!chain [(x in A) ==> (x in A \/ B) [UC]]))
              
conclude union-subset-lemma-2 := (forall A B . B subset A \/ B)
  pick-any A B
    (!subset-intro 
       pick-any x
         (!chain [(x in B) ==> (x in A \/ B) [UC]]))

conclude leq-lemma-1 := (forall x y . x <= x + y)
  pick-any x y 
    (!by-contradiction (x <= x + y)
       let {-y<zero := (!chain-> [true ==> (~ y < zero) [N.Less.not-zero]])}
       (!chain [(~ x <= x + y)
            ==> (x + y < x)          [N.Less=.trichotomy1]
            ==> (x + y < x + zero)   [N.Plus.right-zero]
            ==> (y + x < zero + x)   [N.Plus.commutative]
            ==> (y < zero)           [N.Less.Plus-cancellation]
            ==> (y < zero & -y<zero) [augment]
            ==> false                [prop-taut]]))

conclude leq-lemma := (forall x y z . x <= y ==> x <= y + z)
pick-any x y z  
   assume hyp := (x <= y) 
     (!chain-> [true ==> (y <= y + z)          [leq-lemma-1]
                     ==> (x <= y & y <= y + z) [augment]
                     ==> (x <= y + z)          [N.Less=.transitive]])

conclude minus-lemma := (forall x y . y <= x ==> S (x - y) = (S x) - y) 
pick-any x:N y:N
 assume (y <= x)
  let {_ := (!chain-> [(y <= x) ==> (y <= S x) [N.Less=.S2]])}
  (!chain-> [(S x) = (S x)
         ==> (S ((x - y) + y) = S x)         [N.Minus.Plus-Cancel]
         ==> (S (x - y) + y = S x)           [N.Plus.left-nonzero]
         ==> (S (x - y) + y = (S x - y) + y) [N.Minus.Plus-Cancel]
         ==> (S (x - y) = S x - y)           [N.Plus.=-cancellation]])

conclude union-card := (forall A B . card A \/ B = ((card A) + (card B)) - card A /\ B)
by-induction union-card {
  null => pick-any B
           let {ns := null:(Set.Set 'S)}
             (!chain [(card ns \/ B) 
                         = (card B)                               [union-def]
                         = ((card B) - zero)                      [N.Minus.axioms]
                         = ((card B) - (card ns))                  [card-def]
                         = ((card B) - card ns /\ B)               [intersection-def]
                         = ((zero + card B) - card ns /\ B)        [N.Plus.left-zero]
                         = (((card ns) + (card B)) - card ns /\ B)  [card-def]])
| (A as (insert h t:(Set.Set 'S))) =>
    let {IH := (forall B . card t \/ B = ((card t) + (card B)) - card t /\ B)}
    pick-any B:(Set.Set 'S)
      (!two-cases
        assume case1 := (h in t) 
          let {_ := (!chain-> [(h in t) ==> (h in t \/ B) [UC]]);
               L1 := (!chain [(card A \/ B)
                            = (card h ++ (t \/ B))                    [union-def]
                            = (card t \/ B)                           [card-def]
                            = (((card t) + (card B)) - (card t /\ B)) [IH]
                            = (((card A) + (card B)) - (card t /\ B)) [card-def]])}
            (!two-cases
              assume (h in B) 
               let {_ := (!both (h in B) (h in t))}
                 (!chain [(card A \/ B)
                        = (((card A) + (card B)) - (card t /\ B))   [L1]
                        = (((card A) + (card B)) - (card A /\ B))   [intersection-lemma-1]])
              assume (~ h in B)             
                 (!chain [(card A \/ B)
                        = (((card A) + (card B)) - (card t /\ B))   [L1]
                        = (((card A) + (card B)) - (card A /\ B))   [intersection-def]]))
        assume case2 := (~ h in t) 
          (!two-cases 
            assume (h in B) 
              let {_ := (!chain-> [(h in B) ==> (h in t \/ B) [UC]]);
                   _ := (!chain-> [(~ h in t) ==> (~ h in t /\ B) [IC]])}
                (!chain [(card A \/ B)
                       = (card h ++ (t \/ B))                    [union-def]
                       = (card t \/ B)                           [card-def]
                       = (((card t) + (card B)) - (card t /\ B)) [IH]
                       = (((S card t) + (card B)) - (S (card t /\ B))) [num-lemma]
                       = (((card A) + (card B)) - (S (card t /\ B))) [card-def]
                       = (((card A) + (card B)) - (S (card t /\ B))) [card-def]
                       = (((card A) + (card B)) - (card h ++ (t /\ B))) [card-def]
                       = (((card A) + (card B)) - (card A /\ B))    [intersection-def]])
            assume (~ h in B)  
              let {_ := (!chain-> [(~ h in t)
                               ==> (~ h in t & ~ h in B) [augment]
                               ==> (~ (h in t | h in B)) [dm]
                               ==>  (~ h in t \/ B)      [UC]]);
                   _ := (!chain-> [true
                               ==> (card t /\ B <= card t)               [intersection-card-theorem-1]
                               ==> (card t /\ B  <= (card t) + (card B)) [leq-lemma]])}
                (!chain [(card A \/ B) 
                       = (card h ++ (t \/ B))   [union-def]
                       = (S card t \/ B)        [card-def]
                       = (S (((card t) + card B) - card t /\ B)) [IH]
                       = ((S  ((card t) + (card B))) - (card t /\ B)) [minus-lemma]
                       = ((S  ((card t) + (card B))) - (card A /\ B)) [lemma-p2]
                       = (((S card t) + card B) - (card A /\ B)) [N.Plus.left-nonzero]
                       = (((card A) + card B) - (card A /\ B)) [card-def]])))
}

conclude diff-card-lemma := (forall A B . card A = (card A \ B) + (card A /\ B))
pick-any A B 
  (!chain-> [true ==> (A = (A \ B) \/ (A /\ B)) [diff-theorem-12]
                  ==> (card A = card (A \ B) \/ (A /\ B)) 
                  ==> (card A = ((card A \ B) + (card A /\ B)) - (card (A \ B) /\ (A /\ B))) [union-card]
                  ==> (card A = ((card A \ B) + (card A /\ B)) - (card null))                [diff-theorem-13]
                  ==> (card A = ((card A \ B) + (card A /\ B)) - zero)                [card-def] 
                  ==> (card A = (card A \ B) + card A /\ B)                  [N.Minus.axioms]])

conclude diff-card-theorem := (forall A B . card A \ B =  (card A) - card A /\ B)
pick-any A B 
  (!chain-> [true ==> (card A = (card A \ B) + card A /\ B) [diff-card-lemma]
                  ==> ((card A \ B) + card A /\ B = card A) [sym]
                  ==> (card A \ B = (card A) - card A /\ B) [N.Minus.Plus-Minus-properties]])

conclude Right-Inverse := (forall a . a + negate a = zero)
datatype-cases Right-Inverse {
  (pos x) =>
    conclude (pos x + negate pos x = zero) 
      let {_ := (!chain-> [true ==> (~ x < x) [Less.irreflexive]])}
      (!chain [(pos x + negate pos x)
           --> (pos x + neg x)      [Negate.positive]
           --> (pos (x - x))        [pos-neg-case2]
           --> (pos Top.zero)       [N.Minus.second-equal]
           <-- zero                [zero-definition]])
| (neg x) =>
    conclude (neg x + negate neg x = zero) 
      let {_ := (!chain-> [true ==> (~ x < x) [Less.irreflexive]])}
      (!chain [(neg x + negate neg x)
           --> (neg x + pos x)      [Negate.negative]
           --> (neg (x - x))        [neg-pos-case2]
           --> (neg Top.zero)       [N.Minus.second-equal]
           <-- zero                 [zero-property]])
}

conclude Right-Identity := (forall a . a + zero = a)
datatype-cases Right-Identity {
  (pos x) =>
    conclude (pos x + zero = pos x)
     (!chain [(pos x + zero)
          --> (pos x + pos Top.zero)    [zero-definition]
          --> (pos (x + Top.zero))      [pos-pos]
          --> (pos x)                   [N.Plus.right-zero]])
| (neg x) =>
    conclude (neg x + zero = neg x) 
      let {_ := (!chain-> [true ==> (~ x < Top.zero) [Less.not-zero]])}
      (!chain [(neg x + zero)
           --> (neg x + pos Top.zero)  [zero-definition]
           --> (neg (x - Top.zero))    [neg-pos-case2]
           --> (neg x)                 [N.Minus.zero-right]])
}

conclude Left-Identity := (forall a . zero + a = a)
datatype-cases Left-Identity {
  (pos x) =>
    conclude (zero + pos x = pos x)
      (!chain [(zero + pos x)
           --> (pos Top.zero + pos x)   [zero-definition]
           --> (pos (Top.zero + x))     [pos-pos]
           --> (pos x)                  [N.Plus.left-zero]])
| (neg x) =>
    conclude (zero + neg x = neg x) 
      (!chain [(zero + neg x)
          --> (neg Top.zero + neg x)  [zero-property]
          --> (neg (Top.zero + x))    [neg-neg]
          --> (neg x)                 [N.Plus.left-zero]])
}

conclude associative := (forall a b c . (a +' b) +' c = a +' (b +' c))
datatype-cases associative {
  (nn a1 a2) =>
    datatype-cases 
        (forall b c . ((nn a1 a2) +' b) +' c = 
		         (nn a1 a2) +' (b +' c)) {
      (nn b1 b2) =>
        datatype-cases
	    (forall c . ((nn a1 a2) +' (nn b1 b2)) +' c =
 		          (nn a1 a2) +' ((nn b1 b2) +' c)) {
	  (nn c1 c2) => 
 	    (!chain 
	     [(((nn a1 a2) +' (nn b1 b2)) +' (nn c1 c2))
   	  --> ((nn a1 + b1 a2 + b2) +' (nn c1 c2)) [definition]
   	  --> (nn (a1 + b1) + c1 (a2 + b2) + c2)   [definition]
  	  --> (nn a1 + (b1 + c1) a2 + (b2 + c2))   [N.Plus.associative]
          <-- ((nn a1 a2) +' (nn b1 + c1 b2 + c2)) [definition]
	  <-- ((nn a1 a2) +' ((nn b1 b2) +' (nn c1 c2))) 
                                                   [definition]])
        }
    }
}

conclude inverse := (forall a . NN->Z Z->NN a = a)
datatype-cases inverse {
  (pos x) => {
    (!chain-> [true ==> (~ x < Top.zero) [N.Less.not-zero]]);
    (!chain [(NN->Z Z->NN pos x)
         --> (NN->Z (nn x Top.zero)) [to-pos]
         --> (pos (x - Top.zero))    [from-pos]
         --> (pos x)                 [N.Minus.zero-right]])
  }
| (neg x) =>
   (!two-cases
     assume (x = Top.zero) 
       let {_ := (!chain-> [true ==> (~ Top.zero < Top.zero) 
				             [N.Less.irreflexive]])}
       (!chain [(NN->Z Z->NN neg x)
       	    --> (NN->Z (nn Top.zero x))      [to-neg]
            --> (NN->Z (nn Top.zero Top.zero)) [(x = Top.zero)]
            --> (pos (Top.zero - Top.zero))  [from-pos]
            --> (pos Top.zero)               [N.Minus.zero-right]
            <-- zero                         [zero-definition]
            --> (neg Top.zero)               [zero-property]
            <-- (neg x)                      [(x = Top.zero)]])
     assume (~ x = Top.zero) 
       let {A := (!chain-> 
		  [true ==> (Top.zero <= x)  [N.Less=.zero<=]
			==> (Top.zero < x | Top.zero = x) 
                                        [N.Less=.definition]])}
       (!cases A
	 assume (Top.zero < x)                    
           (!chain [(NN->Z Z->NN neg x)     
                --> (NN->Z (nn Top.zero x))  [to-neg]
                --> (neg (x - Top.zero))     [from-neg]
                --> (neg x)                  [N.Minus.zero-right]])
	 assume (Top.zero = x)
           (!from-complements (NN->Z Z->NN neg x = neg x)
			      (!sym (Top.zero = x)) (x =/= Top.zero))))
}

conclude additive-homomorphism := (forall a b . Z->NN (a + b) = (Z->NN a) +' (Z->NN b))
datatype-cases additive-homomorphism {
  (pos x) =>
    datatype-cases 
       (forall ?b .
	  (Z->NN (pos x + ?b)) = (Z->NN (pos x)) +' (Z->NN ?b)) {
      (pos y) =>
        (!combine-equations
	 (!chain [(Z->NN (pos x + pos y))
              --> (Z->NN (pos (x + y)))              [Plus.pos-pos]
              --> (nn (x + y) Top.zero)              [to-pos]])
         (!chain [((Z->NN pos x) +' (Z->NN pos y))   
              --> ((nn x Top.zero) +' (nn y Top.zero))           [to-pos]
              --> (nn (x + y) (Top.zero + Top.zero)) [NN.Plus.definition]
	      --> (nn (x + y) Top.zero)            [N.Plus.right-zero]]))
    | (neg y) =>
      (!two-cases
        assume (x < y)
          (!combine-equations
	   (!chain [(Z->NN (pos x + neg y))
  	        --> (Z->NN neg (y - x))      [Plus.pos-neg-case1]
                --> (nn Top.zero (y - x))    [to-neg]])
	   (!chain [((Z->NN pos x) +' (Z->NN neg y))
                --> ((nn x Top.zero) +' (nn Top.zero y))   [to-pos to-neg]
  	        --> (nn (x + Top.zero) (Top.zero + y))[NN.Plus.definition]
                --> (nn x y)          [N.Plus.right-zero N.Plus.left-zero]
                --> (nn Top.zero (y - x))        [NN-equivalence.case1]]))
        assume (~ x < y)
 	  (!combine-equations
	   (!chain [(Z->NN (pos x + neg y))
                --> (Z->NN pos (x - y))          [Plus.pos-neg-case2]
	        --> (nn (x - y) Top.zero)        [to-pos]])
	   (!chain [((Z->NN pos x) +' (Z->NN neg y))
	        --> ((nn x Top.zero) +' (nn Top.zero y)) [to-pos to-neg]
                --> (nn (x + Top.zero) (Top.zero + y))[NN.Plus.definition]
                --> (nn x y)          [N.Plus.right-zero N.Plus.left-zero]
                --> (nn (x - y) Top.zero)       [NN-equivalence.case2]])))
    }
| (neg x) =>
    datatype-cases 
       (forall ?b . Z->NN (neg x + ?b) = 
                   (Z->NN neg x) +' (Z->NN ?b)) {
      (pos y) =>
        (!two-cases
	  assume (x < y) 
	   let {_ := (!chain-> [(x < y) ==> (~ y < x) 
				   [N.Less.asymmetric]])}
	   (!combine-equations
   	    (!chain [(Z->NN (neg x + pos y))
                 --> (Z->NN pos (y - x))          [Plus.neg-pos-case1]
                 --> (nn (y - x) Top.zero)        [to-pos]])
	    (!chain [((Z->NN neg x) +' (Z->NN pos y)) 
                 --> ((nn Top.zero x) +' (nn y Top.zero)) [to-neg to-pos]
                 --> (nn (Top.zero + y) (x + Top.zero))
                                                     [NN.Plus.definition]
                 --> (nn y x)        [N.Plus.right-zero N.Plus.left-zero]
                 --> (nn (y - x) Top.zero)      [NN-equivalence.case2]]))
          assume (~ x < y) 
           let {A := (!chain-> 
		      [(~ x < y) 
		       ==> (y <= x)    [N.Less=.trichotomy2]
		       ==> (y < x | y = x)  
                                       [N.Less=.definition]])}
  	   (!cases A
             assume (y < x)		   
	      (!combine-equations
	       (!chain [(Z->NN (neg x + pos y))
                    --> (Z->NN neg (x - y))     [Plus.neg-pos-case2]
                    --> (nn Top.zero (x - y))   [to-neg]])
	       (!chain [((Z->NN neg x) +' (Z->NN pos y))
                    --> ((nn Top.zero x) +' (nn y Top.zero)) 
		                                [to-neg to-pos]
                    --> (nn (Top.zero + y) (x + Top.zero)) 
                                                [NN.Plus.definition]
                    --> (nn y x)                [N.Plus.left-zero 
						 N.Plus.right-zero]
                    --> (nn Top.zero (x - y))  [NN-equivalence.case1]]))
	     assume (y = x) 
               let {_ := (!chain-> [true ==> (~ x < x) 
					    [N.Less.irreflexive]])}
	       (!combine-equations
		(!chain [(Z->NN (neg x + pos y))
                    --> (Z->NN neg (x - y))     [Plus.neg-pos-case2]
	            --> (nn Top.zero (x - y))   [to-neg]
	            --> (nn Top.zero (x - x))   [(y = x)]
                    --> (nn Top.zero Top.zero) [N.Minus.second-equal]])
		(!chain [((Z->NN neg x) +' (Z->NN pos y))
                     --> ((nn Top.zero x) +' (nn y Top.zero)) 
		                               [to-neg to-pos]
   		     --> (nn (Top.zero + y) (x + Top.zero)) 
                                               [NN.Plus.definition]
	             --> (nn y x)              [N.Plus.left-zero 
						N.Plus.right-zero]
	             --> (nn x x)              [(y = x)]
                     --> (nn (x - x) Top.zero) [NN-equivalence.case2]
                     --> (nn Top.zero Top.zero)[N.Minus.second-equal]]))))
    | (neg y) =>
        (!combine-equations
         (!chain [(Z->NN (neg x + neg y))
              --> (Z->NN neg (x + y))              [Plus.neg-neg]
              --> (nn Top.zero (x + y))            [to-neg]])
         (!chain [((Z->NN neg x) +' (Z->NN neg y))
              --> ((nn Top.zero x) +' (nn Top.zero y))           [to-neg]
              --> (nn (Top.zero + Top.zero) (x + y)) [NN.Plus.definition]
              --> (nn Top.zero (x + y))            [N.Plus.right-zero]]))
    }
}

conclude associative := (forall a b c . (a + b) + c = a + (b + c))
  pick-any a:Z b:Z c:Z
    let {f:(OP 1) := Z->NN;
         g:(OP 1) := NN->Z;
         f-application := 
          conclude ((f ((a + b) + c)) =  (f (a + (b + c))))
            (!chain 
	     [(f ((a + b) + c))
	  --> ((f (a + b)) +' (f c))     [Z-NN.additive-homomorphism]
	  --> ((f a +' f b) +' f c)      [Z-NN.additive-homomorphism]
	  --> (f a +' (f b +' f c))      [NN.Plus.associative]
	  <-- (f a +' (f (b + c)))       [Z-NN.additive-homomorphism]
	  <-- (f (a + (b + c)))          [Z-NN.additive-homomorphism]])}
    conclude (((a + b) + c) = a + (b + c))
      (!chain [((a + b) + c)
           <-- (g f ((a + b) + c)) [Z-NN.inverse]
           --> (g f (a + (b + c))) [f-application]
           --> (a + (b + c))       [Z-NN.inverse]])

conclude commutative := (forall a b . a + b = b + a)
datatype-cases commutative {
  (nn a1 a2) =>
    datatype-cases
       (forall ?b . (nn a1 a2) +' ?b = ?b +' (nn a1 a2)) {
      (nn b1 b2) =>
        (!chain [((nn a1 a2) +' (nn b1 b2))
             --> (nn (a1 + b1) (a2 + b2))    [definition]
             --> (nn (b1 + a1) (b2 + a2))    [N.Plus.commutative]
             <-- ((nn b1 b2) +' (nn a1 a2))  [definition]])
    }
}

conclude commutative := (forall a b . a + b = b + a)
  pick-any a:Z b:Z
    let {f:(OP 1) := Z->NN;
         g:(OP 1) := NN->Z;
         f-application := 
          conclude (f (a + b) = f (b + a))
            (!chain [(f (a + b))
                 --> (f a +' f b)  [Z-NN.additive-homomorphism]
		 --> (f b +' f a)  [NN.Plus.commutative]
		 <-- (f (b + a))   [Z-NN.additive-homomorphism]])}
    conclude (a + b = b + a)
      (!chain [(a + b)
           <-- (g f (a + b))   [Z-NN.inverse]
           --> (g f (b + a))   [f-application]
           --> (b + a)         [Z-NN.inverse]])

conclude right-identity := (forall p . p + zero = p)
pick-any p
    let {lemma :=  
          pick-any i
	    (!chain 
	     [((p + zero) at i) 
            = ((p at i) +' (zero at i))   [definition]
	    = ((p at i) +' zero')         [zero-definition]
	    = (p at i)                    [Z.Plus.Right-Identity]])}
      (!chain-> [lemma ==> (p + zero = p) [equality]])

conclude left-identity :=  (forall p . zero + p = p)
pick-any p
    let {lemma :=   
          pick-any i
	    (!chain 
	     [((zero + p) at i) 
	    = ((zero at i) +' (p at i))    [definition]
	    = (zero' +' (p at i))          [zero-definition]
	    = (p at i)                     [Z.Plus.Left-Identity]])}
      (!chain-> [lemma ==> (zero + p = p)  [equality]])

conclude commutative := (forall p q . p + q = q + p)
pick-any p q
    let {lemma :=
          pick-any i
            (!chain [((p + q) at i)
		   = ((p at i) +' (q at i))     [definition]
		   = ((q at i) +' (p at i))     [Z.Plus.commutative]
		   = ((q + p) at i)             [definition]])}
      (!chain-> [lemma ==> (p + q = q + p)      [equality]])

conclude associative := (forall p q r . (p + q) + r = p + (q + r))
pick-any p q r 
    let {lemma := 
          pick-any i
            (!chain 
	     [(((p + q) + r) at i)
	    = (((p + q) at i) +' (r at i))             [definition]
	    = (((p at i) +' (q at i)) +' (r at i))     [definition]
	    = ((p at i) +' ((q at i) +' (r at i)))     [Z.Plus.associative]
	    = ((p at i) +' ((q + r) at i))             [definition]
	    = ((p + (q + r)) at i)                     [definition]])}
    (!chain-> [lemma ==> ((p + q) + r = p + (q + r))   [equality]])

conclude right-inverse := (forall p . p + (negate p) = zero)
pick-any p
      let {lemma := 
            pick-any i
              (!chain 
	        [((p + negate p) at i)
	       = ((p at i) +' ((negate p) at i))   [Plus-definition]
	       = ((p at i) +' Z.negate (p at i))   [Negate.definition]
	       = zero'                             [Z.Plus.Right-Inverse]
	       = (zero at i)                       [zero-definition]])}
        (!chain-> [lemma ==> (p + negate p = zero) [equality]])

conclude associative := (forall a b c . (a * b) * c = a * (b * c))
datatype-cases commutative {
   (pos x) =>
     datatype-cases (forall ?b . pos x * ?b = ?b * pos x) {
       (pos y) => 
         (!chain [(pos x * pos y)
		  --> (pos (x * y))        [pos-pos]
		  --> (pos (y * x))        [N.Times.commutative]
		  <-- (pos y * pos x)      [pos-pos]])
     | (neg y) =>
         (!chain [(pos x * neg y)
		  --> (neg (x * y))        [pos-neg]
		  --> (neg (y * x))        [N.Times.commutative]
		  <-- (neg y * pos x)      [neg-pos]])
     }
 | (neg x) =>
     datatype-cases (forall ?b . neg x * ?b = ?b * neg x) {
       (pos y) => 
         (!chain [(neg x * pos y)
		  --> (neg (x * y))        [neg-pos]
		  --> (neg (y * x))        [N.Times.commutative]
		  <-- (pos y * neg x)      [pos-neg]])
     | (neg y) =>
         (!chain [(neg x * neg y)
		  --> (pos (x * y))        [neg-neg]
		  --> (pos (y * x))        [N.Times.commutative]
		  <-- (neg y * neg x)      [neg-neg]])
     }
}

conclude commutative := (forall a b . a * b = b * a)
let {assoc := N.Times.associative}
datatype-cases associative {
    (pos x) =>
      datatype-cases 
         (forall ?b ?c . ((pos x) * ?b) * ?c = (pos x) * (?b Z.* ?c)) {
        (pos y) =>
          datatype-cases
             (forall ?c . ((pos x) * (pos y)) * ?c = (pos x) * ((pos y) * ?c)) {
            (pos z) =>
              (!chain [(((pos x) * (pos y)) * (pos z))
                   --> ((pos (x * y)) * (pos z))        [pos-pos]
                   --> (pos ((x * y) * z))              [pos-pos]
                   --> (pos (x * (y * z)))              [assoc]
                   <-- ((pos x) * (pos (y * z)))        [pos-pos]
                   <-- ((pos x) * ((pos y) * (pos z)))  [pos-pos]])
          | (neg z) =>
              (!chain [(((pos x) * (pos y)) * (neg z))
                   --> ((pos (x * y)) * (neg z))        [pos-pos]
                   --> (neg ((x * y) * z))              [pos-neg]
                   --> (neg (x * (y * z)))              [assoc]
                   <-- ((pos x) * (neg (y * z)))        [pos-neg]
                   <-- ((pos x) * ((pos y) * (neg z)))  [pos-neg]])
          }
      | (neg y) =>
          datatype-cases
             (forall ?c . ((pos x) * (neg y)) * ?c = (pos x) * ((neg y) * ?c)) {
            (pos z) =>
              (!chain [(((pos x) * (neg y)) * (pos z))
                   --> ((neg (x * y)) * (pos z))        [pos-neg]
                   --> (neg ((x * y) * z))              [neg-pos]
                   --> (neg (x * (y * z)))              [assoc]
                   <-- ((pos x) * (neg (y * z)))        [pos-neg]
                   <-- ((pos x) * ((neg y) * (pos z)))  [neg-pos]])
          | (neg z) =>
              (!chain [(((pos x) * (neg y)) * (neg z))
                   --> ((neg (x * y)) * (neg z))        [pos-neg]
                   --> (pos ((x * y) * z))              [neg-neg]
                   --> (pos (x * (y * z)))              [assoc]
                   <-- ((pos x) * (pos (y * z)))        [pos-pos]
                   <-- ((pos x) * ((neg y) * (neg z)))  [neg-neg]])
          }
      }
  | (neg x) =>
      datatype-cases
         (forall ?b ?c . ((neg x) * ?b) * ?c = (neg x) * (?b Z.* ?c)) {
        (pos y) =>
          datatype-cases
             (forall ?c .((neg x) * (pos y)) * ?c = (neg x) * ((pos y) * ?c)) {
            (pos z) =>
              (!chain [(((neg x) * (pos y)) * (pos z))
                   --> ((neg (x * y)) * (pos z))        [neg-pos]
                   --> (neg ((x * y) * z))              [neg-pos]
                   --> (neg (x * (y * z)))              [assoc]
                   <-- ((neg x) * (pos (y * z)))        [neg-pos]
                   <-- ((neg x) * ((pos y) * (pos z)))  [pos-pos]])
          | (neg z) =>
              (!chain [(((neg x) * (pos y)) * (neg z))
                   --> ((neg (x * y)) * (neg z))        [neg-pos]
                   --> (pos ((x * y) * z))              [neg-neg]
                   --> (pos (x * (y * z)))              [assoc]
                   <-- ((neg x) * (neg (y * z)))        [neg-neg]
                   <-- ((neg x) * ((pos y) * (neg z)))  [pos-neg]])
          }
      | (neg y) =>
          datatype-cases
             (forall ?c . ((neg x) * (neg y)) * ?c = (neg x) * ((neg y) * ?c)) {
            (pos z) => 
              (!chain [(((neg x) * (neg y)) * (pos z))
                   --> ((pos (x * y)) * (pos z))        [neg-neg]
                   --> (pos ((x * y) * z))              [pos-pos]
                   --> (pos (x * (y * z)))              [assoc]
                   <-- ((neg x) * (neg (y * z)))        [neg-neg]
                   <-- ((neg x) * ((neg y) * (pos z)))  [neg-pos]])
          | (neg z) =>
              (!chain [(((neg x) * (neg y)) * (neg z))
                   --> ((pos (x * y)) * (neg z))        [neg-neg]
                   --> (neg ((x * y) * z))              [pos-neg]
                   --> (neg (x * (y * z)))              [assoc]
                   <-- ((neg x) * (pos (y * z)))        [neg-pos]
                   <-- ((neg x) * ((neg y) * (neg z)))  [neg-neg]])
          }
      }
}

conclude multiplicative-homomorphism := (forall a b . (Z->NN (a * b)) = (Z->NN a) *' (Z->NN b))
let {f:(OP 1) := Z->NN; definition := NN.Times.definition}
  datatype-cases multiplicative-homomorphism {
    (pos x) =>
      datatype-cases
         (forall ?b . (f ((pos x) * ?b)) = (f (pos x)) *' (f ?b)) {
        (pos y) =>
          (!combine-equations
           (!chain [(f ((pos x) * (pos y)))
                --> (f (pos (x * y)))             [Times.pos-pos]
                --> (nn (x * y) Top.zero)         [to-pos]])
           (!chain [((f (pos x)) *' (f (pos y)))
                --> ((nn x Top.zero) *' (nn y Top.zero)) [to-pos]
                --> (nn (x * y + Top.zero * Top.zero) 
			(x * Top.zero + Top.zero * y))
                                                 [definition]
                --> (nn (x * y + Top.zero) (Top.zero + Top.zero)) 
		                                 [N.Times.right-zero 
						  N.Times.left-zero]
                --> (nn (x * y) Top.zero)         [N.Plus.right-zero]]))
      | (neg y) =>
          (!combine-equations
           (!chain [(f ((pos x) * (neg y)))
                --> (f (neg (x * y)))            [Times.pos-neg]
                --> (nn Top.zero (x * y))         [to-neg]])
           (!chain [((f (pos x)) *' (f (neg y)))
                --> ((nn x Top.zero) *' (nn Top.zero y)) 
		                                 [to-pos to-neg]
                --> (nn (x * Top.zero + Top.zero * y)
                         (x * y + Top.zero * Top.zero))  [definition]
                --> (nn (Top.zero + Top.zero) (x * y + Top.zero)) 
		                                 [N.Times.right-zero
						  N.Times.left-zero]
                --> (nn Top.zero x * y)           [N.Plus.right-zero]]))
      }
  | (neg x) =>
      datatype-cases
         (forall ?b . (f ((neg x) * ?b)) = (f (neg x)) *' (f ?b)) {
        (pos y) =>
          (!combine-equations
           (!chain [(f ((neg x) * (pos y)))
                --> (f (neg (x * y)))            [Times.neg-pos]
                --> (nn Top.zero (x * y))         [to-neg]])
           (!chain [((f (neg x)) *' (f (pos y)))
                --> ((nn Top.zero x) *' (nn y Top.zero)) [to-neg to-pos]
                --> (nn (Top.zero * y + x * Top.zero) 
			 (Top.zero * Top.zero + x * y))
                                                 [definition]
                --> (nn (Top.zero + Top.zero) (Top.zero + x * y)) 
		                                 [N.Times.right-zero 
                                                  N.Times.left-zero]
                --> (nn Top.zero (x * y))         [N.Plus.left-zero]]))
      | (neg y) =>
          (!combine-equations
           (!chain [(f ((neg x) * (neg y)))
                --> (f (pos (x * y)))            [Times.neg-neg]
                --> (nn (x * y) Top.zero)         [to-pos]])
           (!chain [((f (neg x)) *' (f (neg y)))
                --> ((nn Top.zero x) *' (nn Top.zero y)) [to-neg]
                --> (nn (Top.zero * Top.zero + x * y) 
			 (Top.zero * y + x * Top.zero))
                                                 [definition]
                --> (nn (Top.zero + x * y) (Top.zero + Top.zero)) 
		                                 [N.Times.right-zero 
						  N.Times.left-zero]
                --> (nn (x * y) Top.zero)         [N.Plus.left-zero]]))
      }
  }

conclude Right-Distributive := (forall a b c . (a +' b) *' c = a *' c +' b *' c)
datatype-cases Right-Distributive {
  (Z.nn a1 a2) =>
     datatype-cases
        (forall ?b ?c . ((nn a1 a2) +' ?b) *' ?c =
                         (nn a1 a2) *' ?c +' ?b *' ?c) {
       (Z.nn b1 b2) =>
         datatype-cases
            (forall ?c . 
	       ((nn a1 a2) +' (nn b1 b2)) *' ?c =
                (nn a1 a2) *' ?c +' (nn b1 b2) *' ?c)
         {
           (Z.nn c1 c2) =>
             (!combine-equations
              (!chain 
	       [(((nn a1 a2) +' (nn b1 b2)) *' (nn c1 c2))
		= ((nn (a1 + b1) (a2 + b2)) *' (nn c1 c2))
                                                 [Plus.definition]
                = (nn ((a1 + b1) * c1 + (a2 + b2) * c2)
		       ((a1 + b1) * c2 + (a2 + b2) * c1))
                                                 [definition]
                = (nn ((a1 * c1 + b1 * c1) + (a2 * c2 + b2 * c2))
		       ((a1 * c2 + b1 * c2) + (a2 * c1 + b2 * c1)))
                                          [N.Times.right-distributive]])
              (!chain [((nn a1 a2) *' (nn c1 c2) 
                       +' (nn b1 b2) *' (nn c1 c2))
                     = ((nn (a1 * c1 + a2 * c2) (a1 * c2 + a2 * c1))
                         +' (nn (b1 * c1 + b2 * c2)
                                      (b1 * c2 + b2 * c1)))
                                            [definition]
                     = (nn ((a1 * c1 + a2 * c2) + (b1 * c1 + b2 * c2))
                            ((a1 * c2 + a2 * c1) + (b1 * c2 + b2 * c1)))
                                            [Plus.definition]
                     = (nn ((a1 * c1 + b1 * c1) + (a2 * c2 + b2 * c2))
                            ((a1 * c2 + b1 * c2) + (a2 * c1 + b2 * c1)))
                                            [N.Plus.commutative 
                                             N.Plus.associative]]))
         }
     }
}

conclude Right-Distributive := (forall a b c . (a +' b) *' c = a *' c +' b *' c)
  pick-any a:Z b:Z c:Z 
    let {f:(OP 1) := Z->NN; g:(OP 1) := NN->Z;
         f-application := 
           conclude ((f ((a + b) * c)) = (f (a * c + b * c)))
             (!chain [(f ((a + b) * c))
             --> ((f (a + b)) *' (f c))       
                                  [Z-NN.multiplicative-homomorphism]
             --> (((f a) +' (f b)) *' (f c))
                                  [Z-NN.additive-homomorphism]
             --> (((f a) *' (f c)) +' ((f b) *' (f c)))
                                  [NN.Times.Right-Distributive]
             <-- ((f (a * c)) +' (f (b * c)))             
                                  [Z-NN.multiplicative-homomorphism]
             <-- (f (a * c + b * c)) [Z-NN.additive-homomorphism]])}
    conclude ((a + b) * c = a * c + b * c)
      (!chain [((a + b) * c)
          <-- (g (f ((a + b) * c)))     [Z-NN.inverse]
          --> (g (f (a * c + b * c)))   [f-application]
          --> (a * c + b * c)           [Z-NN.inverse]])

conclude Left-Distributive := (forall a b c . c * (a + b) = c * a + c * b)
  pick-any a:Z b:Z c:Z 
    (!chain [(c * (a + b))
             --> ((a + b) * c)    [commutative]
             --> (a * c + b * c)  [Right-Distributive]
             --> (c * a + c * b)  [commutative]])

conclude Right-Identity := (forall a . a * one = a)
datatype-cases Right-Identity {
  (pos x) =>
    (!chain [((pos x) * one)
         --> ((pos x) * (pos N.one)) [one-definition]
         --> (pos (x * N.one))       [pos-pos]
         --> (pos x)                 [N.Times.right-one]])
| (neg x) =>
    (!chain [((neg x) * one)
         --> ((neg x) * (pos N.one)) [one-definition]
         --> (neg (x * N.one))       [neg-pos]
         --> (neg x)                 [N.Times.right-one]])
} 

conclude Left-Identity :=  (forall a . one * a = a)
pick-any a:Z 
    (!chain [(one * a)
         --> (a * one)              [commutative]
         --> a                      [Right-Identity]])

conclude No-Zero-Divisors := (forall a b . a * b = zero ==> a = zero | b = zero)
datatype-cases No-Zero-Divisors {
  (pos x) =>
    datatype-cases 
       (forall ?b . (pos x) * ?b = zero ==> 
	            (pos x) = zero | ?b = zero) {
      (pos y) =>
        assume ((pos x) * (pos y) = zero)
          let {C := 
                (!chain->
		 [(pos (x * y))
		  <-- ((pos x) * (pos y)) [pos-pos]
		 --> zero                [((pos x) * (pos y) = zero)]
		 --> (pos Top.zero)        [zero-definition]
		 ==> (x * y = Top.zero)    [Z-structure-axioms]
		 ==> (x = Top.zero | y = Top.zero)  [N.Times.no-zero-divisors]])}
          (!cases C
            assume (x = Top.zero) 
              let {_ := (!chain [(pos x) 
				 --> (pos Top.zero)  [(x = Top.zero)] 
				 <-- zero          [zero-definition]])}
              (!left-either ((pos x) = zero) ((pos y) = zero))
            assume (y = Top.zero) 
              let {_ := (!chain [(pos y) 
				 --> (pos Top.zero)   [(y = Top.zero)] 
                                 <-- zero           [zero-definition]])}
              (!right-either ((pos x) = zero) ((pos y) = zero)))
    | (neg y) =>
        assume ((pos x) * (neg y) = zero) 
          let {C :=
                (!chain-> 
		 [(neg (x * y))
		  <-- ((pos x) * (neg y))      [pos-neg]
		  --> zero                     [((pos x) * (neg y) = zero)]
		  --> (neg Top.zero)             [zero-property]
		  ==> (x * y = Top.zero)         [Z-structure-axioms]
		  ==> (x = Top.zero | y = Top.zero) [N.Times.no-zero-divisors]])}
          (!cases C
            assume (x = Top.zero) 
              let {_ := (!chain [(pos x) 
				 --> (pos Top.zero)  [(x = Top.zero)] 
				 <-- zero          [zero-definition]])}
              (!left-either ((pos x) = zero) ((neg y) = zero))
            assume (y = Top.zero) 
              let {_ := (!chain [(neg y) 
				 --> (neg Top.zero)  [(y = Top.zero)] 
				 <-- zero          [zero-property]])}
              (!right-either ((pos x) = zero) ((neg y) = zero)))
    }
 | (neg x) =>
   datatype-cases 
      (forall ?b . (neg x) * ?b = zero ==> (neg x) = zero | ?b = zero) 
   { (pos y) =>
       assume ((neg x) * (pos y) = zero) 
         let {C := (!chain-> 
		    [(neg (x * y))
		     <-- ((neg x) * (pos y))   [neg-pos]
		     --> zero                  [(((neg x) * (pos y)) = zero)]
		     --> (neg Top.zero)          [zero-property]
		     ==> (x * y = Top.zero)      [Z-structure-axioms]
		     ==> (x = Top.zero | y = Top.zero) [N.Times.no-zero-divisors]])}
         (!cases C
           assume (x = Top.zero) 
             let {_ := (!chain [(neg x) 
				--> (neg Top.zero)  [(x = Top.zero)] 
				<-- zero       [zero-property]])}
             (!left-either ((neg x) = zero) ((pos y) = zero))
           assume (y = Top.zero) 
             let {_ := (!chain [(pos y) 
				--> (pos Top.zero)  [(y = Top.zero)] 
				<-- zero       [zero-definition]])}
             (!right-either ((neg x) = zero) ((pos y) = zero)))
   | (neg y) =>
       assume ((neg x) * (neg y) = zero) 
         let {C := (!chain-> 
		    [(pos (x * y))
		     <-- ((neg x) * (neg y))[neg-neg]
		     --> zero               [((neg x) * (neg y) = zero)]
		     --> (pos Top.zero)     [zero-definition]
		     ==> (x * y = Top.zero) [Z-structure-axioms]
		     ==> (x = Top.zero | y = Top.zero)  
                                            [N.Times.no-zero-divisors]])}
         (!cases C
           assume (x = Top.zero) 
             let {_ := (!chain [(neg x) 
				--> (neg Top.zero)  [(x = Top.zero)] 
				<-- zero            [zero-property]])}
             (!left-either ((neg x) = zero) ((neg y) = zero))
           assume (y = Top.zero) 
             let {_ := (!chain [(neg y) 
				--> (neg Top.zero)  [(y = Top.zero)] 
				<-- zero            [zero-property]])}
             (!right-either ((neg x) = zero) ((neg y) = zero)))
   }
}

conclude Nonzero-Product := (forall a b . ~ (a = zero | b = zero) ==> a * b =/= zero)
  pick-any a b 
    (!contra-pos (!instance No-Zero-Divisors [a b]))

conclude right-empty := (forall p . p join nil = p)
by-induction right-empty {
    nil =>
    (!chain [(nil join nil) = nil [left-empty]])
  | (x :: p) => 
    let {induction-hypothesis := (p join nil = p)}
    (!chain [((x :: p) join nil)
   	  --> (x :: (p join nil))  [left-nonempty]
	  --> (x :: p)             [induction-hypothesis]])
  }

conclude right-nonempty := (forall p y q . p join (y :: q) = (p join (y :: nil)) join q)
  by-induction right-nonempty {
    nil =>
    pick-any y q
      (!combine-equations
       (!chain [(nil join (y :: q))
                --> (y :: q)  [left-empty]])
       (!chain [((nil join (y :: nil)) join q)
                --> ((y :: nil) join q)  [left-empty]
                --> (y :: (nil join q))  [left-nonempty]
                --> (y :: q)             [left-empty]]))
  | (x :: p) => 
    let {induction-hypothesis :=
           (forall ?y ?q .
             p join (?y :: ?q) = (p join (?y :: nil)) join ?q)}
    conclude (forall ?y ?q .
               (x :: p) join (?y :: ?q) =
               ((x :: p) join (?y :: nil)) join ?q)
      pick-any y q
        (!combine-equations
        (!chain [((x :: p) join (y :: q))
      --> (x :: (p join (y :: q))) [left-nonempty]
              --> (x :: ((p join (y :: nil)) join q))
                                    [induction-hypothesis]])
 (!chain [(((x :: p) join (y :: nil)) join q)
      --> ((x :: (p join (y :: nil))) join q)
                                    [left-nonempty]
              --> (x :: ((p join (y :: nil)) join q))
                                    [left-nonempty]]))
}       
        
conclude Associative := (forall p q r . (p join q) join r = p join (q join r))
by-induction Associative {
nil =>
pick-any q r
  (!chain [((nil join q) join r)
           --> (q join r)            [left-empty]
           <-- (nil join (q join r)) [left-empty]])
| (x :: p) => 
let {induction-hypothesis :=
       (forall ?q ?r . (p join ?q) join ?r = 
                       p join (?q join ?r))}
conclude (forall ?q ?r .
           ((x :: p) join ?q) join ?r = 
            (x :: p) join (?q join ?r))
  pick-any q r
    (!chain 
     [(((x :: p) join q) join r)
  --> ((x :: (p join q)) join r) [left-nonempty]
  --> (x :: ((p join q) join r)) [left-nonempty]
  --> (x :: (p join (q join r))) [induction-hypothesis]
  <-- ((x :: p) join (q join r)) [left-nonempty]
  ])
}    
  
conclude left-singleton := forall x p . (x :: nil) join p = x :: p)
    pick-any x p 
      (!chain
       [((x :: nil) join p) 
	= (x :: (nil join p))    [left-nonempty]
	= (x :: p)               [left-empty]])

conclude of-join := (forall p q . (reverse (p join q)) = (reverse q) join (reverse p))
by-induction of-join {
    nil =>
    conclude (forall q . (reverse (nil join q)) = 
		          (reverse q) join (reverse nil))
      pick-any q
        (!combine-equations
	 (!chain [(reverse (nil join q))
		  --> (reverse q)            [join.left-empty]])
	 (!chain [((reverse q) join (reverse nil))
		  --> ((reverse q) join nil) [empty]
		  --> (reverse q)            [join.right-empty]]))
  | (x :: p) => 
    let {induction-hypothesis :=
           (forall ?q . (reverse (p join ?q)) =
                        (reverse ?q) join (reverse p))}
    conclude (forall ?q . (reverse ((x :: p) join ?q)) =
		          (reverse ?q) join (reverse (x :: p)))
      pick-any q
        (!chain [(reverse ((x :: p) join q))
		 --> (reverse (x :: (p join q)))  [join.left-nonempty]
		 --> ((reverse (p join q)) join (x :: nil))
                                            [nonempty]
                 --> (((reverse q) join (reverse p)) join (x :: nil))
                                            [induction-hypothesis]
                 --> ((reverse q) join ((reverse p) join (x :: nil)))
                                            [join.Associative]
                 <-- ((reverse q) join (reverse (x :: p)))
                                            [nonempty]])
  }

conclude of-reverse := (forall p . (reverse (reverse p)) = p)
by-induction of-reverse {
    nil =>
    conclude ((reverse (reverse nil)) = nil)
      (!chain [(reverse (reverse nil))
	       --> (reverse nil)          [empty]
	       --> nil                    [empty]])
  | (x :: p) =>
    conclude ((reverse (reverse (x :: p))) = (x :: p)) 
      let {induction-hypothesis := ((reverse (reverse p)) = p)}
      (!chain 
       [(reverse (reverse (x :: p)))
	--> (reverse ((reverse p) join (x :: nil))) 
                                            [nonempty]
        --> ((reverse (x :: nil)) join (reverse (reverse p)))  
                                            [of-join]
        --> ((reverse (x :: nil)) join p)   [induction-hypothesis]
	--> (((reverse nil) join (x :: nil)) join p) 
                                            [nonempty]
        --> ((nil join (x :: nil)) join p)  [empty]
        --> ((x :: nil) join p)             [join.left-empty]
        --> (x :: (nil join p))             [join.left-nonempty]
        --> (x :: p)                        [join.left-empty]])
  }

conclude join-singleton := (forall p x . (reverse (p join (x :: nil))) = x :: (reverse p))
pick-any p x
  (!chain
   [(reverse (p join (x :: nil)))
--> ((reverse (x :: nil)) join (reverse p))  [of-join]
--> (((reverse nil) join (x :: nil)) join (reverse p))  
                                                 [nonempty]
    --> ((nil join (x :: nil)) join (reverse p)) [empty]
--> ((x :: nil) join (reverse p))  [join.left-empty]
--> (x :: (nil join (reverse p)))  [join.left-nonempty]
--> (x :: (reverse p))             [join.left-empty]])

conclude of-reverse := (forall p . (reverse (reverse p)) = p)
by-induction of-reverse {
    nil =>
    conclude ((reverse (reverse nil)) = nil)
      (!chain [(reverse (reverse nil))
	       --> (reverse nil)          [empty]
	       --> nil                    [empty]])
  | (x :: p) =>
    conclude ((reverse (reverse (x :: p))) = (x :: p)) 
      let {induction-hypothesis := ((reverse (reverse p)) = p)}
      (!chain 
       [(reverse (reverse (x :: p)))
	--> (reverse ((reverse p) join (x :: nil))) [nonempty]
        --> (x :: (reverse (reverse p)))  [join-singleton]
	--> (x :: p)                      [induction-hypothesis]])
  }

conclude of-join := (forall p q . length (p join q) = (length p) + (length q))
by-induction of-join {
  nil:(List 'S) =>
  conclude (forall ?q . 
             length (nil:(List 'S) join ?q) = (length nil:(List 'S) + (length ?q)))
    pick-any q:(List 'S)
      (!combine-equations
       (!chain 
        [(length (nil join q))
         --> (length q)             [join.left-empty]])
       (!chain
        [((length nil:(List 'S)) + (length q))
         --> (zero + (length q))    [empty]
         --> (length q)             [Plus.left-zero]]))
| (H:'S :: T:(List 'S)) =>
  conclude (forall ?q . length ((H :: T) join ?q) =
                        (length (H :: T)) + length ?q)
    let {induction-hypothesis :=
          (forall ?q . length (T join ?q) = (length T) + length ?q)}
    pick-any q:(List 'S) 
      (!combine-equations
       (!chain 
        [(length ((H :: T) join q))
         --> (length (H :: (T join q)))     [join.left-nonempty]
         --> (S (length (T join q)))        [nonempty]
         --> (S ((length T) + (length q)))  [induction-hypothesis]])
       (!chain 
        [((length (H :: T)) + (length q))
         --> ((S (length T)) + (length q))  [nonempty]
         --> (S ((length T) + (length q)))  [Plus.left-nonzero]]))
}

conclude of-reverse := (forall p . length reverse p = length p)
by-induction of-reverse {
  nil =>
  (!chain [(length (reverse nil:(List 'S)))
           --> (length nil:(List 'S))       [reverse.empty]])
| (x :: p:(List 'S)) => 
  let {induction-hypothesis := ((length (reverse p)) = (length p))}
  conclude (length (reverse (x :: p)) = length (x :: p))
    (!chain 
     [(length (reverse (x :: p)))
      --> (length ((reverse p) join (x :: nil)))  
                                               [reverse.nonempty]
      --> ((length (reverse p)) + (length (x :: nil)))
                                               [of-join]
      --> ((length p) + (length (x :: nil)))   [induction-hypothesis]
      --> ((length p) + (S (length nil:(List 'S)))) [nonempty]
      --> ((length p) + (S zero))              [empty]
      --> (S ((length p) + zero))              [Plus.right-nonzero]
      --> (S (length p))                       [Plus.right-zero]
      <-- (length (x :: p))                    [nonempty]])
}

conclude of-join := (forall L M x . (count x (L join M)) = (count x L) + (count x M)) 
by-induction of-join {
  nil =>
  pick-any M x
    (!combine-equations
     (!chain [(count x (nil join M))
              = (count x M)             [join.left-empty]])
     (!chain [((count x nil) + (count x M))
             = (zero + (count x M))     [empty]
             = (count x M)              [Plus.left-zero]]))
| (y :: L) => 
  let {ind-hyp := (forall ?M ?x . (count ?x (L join ?M)) = 
                                  (count ?x L) + (count ?x ?M))}
  conclude (forall ?M ?x . (count ?x ((y :: L) join ?M)) = 
                           (count ?x (y :: L)) + (count ?x ?M))
    pick-any M x
      (!two-cases
        assume (x = y)
          (!combine-equations
           (!chain 
            [(count x ((y :: L) join M))
             = (count x (y :: (L join M)))     [join.left-nonempty]
             = (S (count x (L join M)))        [more]
             = (S ((count x L) + (count x M))) [ind-hyp]])
           (!chain 
            [((count x (y :: L)) + (count x M))
             = ((S (count x L)) + (count x M)) [more]
             = (S ((count x L) + (count x M))) [Plus.left-nonzero]
             ]))
        assume (x =/= y)
          (!combine-equations
	   (!chain 
	    [(count x ((y :: L) join M))
	     = (count x (y :: (L join M)))    [join.left-nonempty]
	     = (count x (L join M))           [same]
	     = ((count x L) + (count x M))    [ind-hyp]])
	   (!chain 
	    [((count x (y :: L)) + (count x M))
	     = ((count x L) + (count x M))    [same]
	     ])))
}
  
conclude of-reverse := (forall L x . (count x (reverse L)) = (count x L))
by-induction of-reverse {
  nil =>
  pick-any x
    (!chain [(count x (reverse nil))
             = (count x nil)          [reverse.empty]])
| (y :: L) => 
  let {ind-hyp := (forall ?x . (count ?x (reverse L)) = (count ?x L))}
  conclude (forall ?x . (count ?x (reverse (y :: L))) =
                        (count ?x (y :: L)))
    pick-any x
      (!two-cases
        assume (x = y)
  	  (!chain 
	   [(count x (reverse (y :: L)))
	    = (count x ((reverse L) join (y :: nil)))  
                                       [reverse.nonempty]
            = ((count x (reverse L)) + (count x (y :: nil))) 
                                       [of-join]
            = ((count x L) + (S (count x nil)))  
                                       [ind-hyp more]
            = ((count x L) + (S zero)) [empty]
            = (S ((count x L) + zero)) [Plus.right-nonzero]
            = (S (count x L))          [Plus.right-zero]
            = (count x (y :: L))       [more]])
        assume (x =/= y)
          (!chain 
           [(count x (reverse (y :: L)))
            = (count x ((reverse L) join (y :: nil)))  
                                       [reverse.nonempty]
            = ((count x (reverse L)) + (count x (y :: nil))) 
                                       [of-join]
            = ((count x L) + (count x nil))  
                                       [ind-hyp same]
            = ((count x L) + zero)     [empty]
            = (count x L)              [Plus.right-zero]
            = (count x (y :: L))       [same]]))
}

conclude head := (forall x L . x in (x :: L))
pick-any x L
    (!chain-> [(x = x)            
	       ==> (x = x | x in L) [alternate]
	       ==> (x in (x :: L))  [nonempty]])

conclude tail := (forall x y L . x in L ==> x in (y :: L))
pick-any x y L
    (!chain [(x in L)
             ==> (x = y | x in L)   [alternate]
             ==> (x in (y :: L))    [nonempty]])

conclude of-singleton := (forall x y . x in (y :: nil) ==> x = y)
  pick-any x y
    assume (x in (y :: nil))
      let {C := (!chain-> [(x in (y :: nil)) ==> (x = y | x in nil) 
			               [nonempty]])}
      (!cases C
       assume (x = y)
         (!claim (x = y))
       assume (x in nil)
         (!from-complements (x = y)
	  (x in nil) (!chain-> [true ==> (~ x in nil) [empty]])))

conclude of-join := (forall L M x . x in (L join M) <==> x in L | x in M)
by-induction of-join {
  nil =>
  conclude (forall ?M ?x . ?x in (nil join ?M) <==> 
                           ?x in nil | ?x in ?M)   
    pick-any M x 
      let {_ := (!chain-> 
		 [true ==> (~ x in nil)         [empty]
		       <==> (x in nil <==> false) [prop-taut]])}
      (!chain 
       [(x in (nil join M))
        <==> (x in M)             [join.left-empty]
        <==> (false | x in M)     [prop-taut]
        <==> (x in nil | x in M)  [(x in nil <==> false)]])
| (y :: L) => 
  let {ind-hyp := (forall ?M ?x . 
                    ?x in (L join ?M) <==> ?x in L | ?x in ?M)}
  conclude (forall ?M ?x . 
             ?x in ((y :: L) join ?M) <==> 
             ?x in (y :: L) | ?x in ?M)
    pick-any M x
      (!chain 
       [(x in ((y :: L) join M))
        <==> (x in (y :: (L join M)))    [join.left-nonempty]
        <==> (x = y | x in (L join M))   [nonempty]
	<==> (x = y | x in L | x in M)   [ind-hyp]
	<==> ((x = y | x in L) | x in M) [prop-taut]
	<==> (x in (y :: L) | x in M)    [nonempty]])
}

conclude sanity-check1 := (forall L x y . x =/= y  ==> (count x (replace L x y)) = zero)
by-induction sanity-check1 {
  nil =>
  pick-any x y
    assume (x =/= y)
      (!chain [(count x (replace nil x y))
                = (count x nil)           [empty]
		= zero                    [count.empty]])
| (z :: L) =>
  pick-any x y
    assume (x =/= y)
      let {ind-hyp := (forall ?x ?y .
                        ?x =/= ?y ==> (count ?x (replace L ?x ?y)) = zero);
           _ := (!sym (x =/= y))}
      (!two-cases
       assume (x = z)
         (!chain
	  [(count x (replace (z :: L) x y))
	   = (count x (y :: (replace L x y)))  [equal]
	   = (count x (replace L x y))         [count.same]
	   = zero                              [ind-hyp]])
       assume (x =/= z)
         (!chain
	  [(count x (replace (z :: L) x y))
	   = (count x (z :: (replace L x y)))  [unequal]
	   = (count x (replace L x y))         [count.same]
	   = zero                              [ind-hyp]]))
}    

conclude sanity-check2 := (forall L x y . x =/= y  ==> (count y (replace L x y)) = (count x L) + (count y L))
by-induction sanity-check2 {
  nil =>
  pick-any x y
    assume (x =/= y)
      (!combine-equations
       (!chain [(count y (replace nil x y))
                = (count y nil)           [empty]
		= zero                    [count.empty]])
       (!chain [((count x nil) + (count y nil))
		= (zero + zero)           [count.empty]
		= zero                    [Plus.right-zero]]))
| (z:'S :: L) =>
  pick-any x:'S y
    assume (x =/= y)
      let {ind-hyp := (forall ?x ?y .
                        ?x =/= ?y ==> (count ?y (replace L ?x ?y)) = 
			              (count ?x L) + (count ?y L));
           _ := (!sym (x =/= y))}
      (!two-cases
       assume (y = z)
         (!combine-equations
	  (!chain
	   [(count y (replace (z :: L) x y))
	    = (count y (replace (y :: L) x y))  [(y = z)]
	    = (count y (y :: (replace L x y)))  [unequal]
	    = (S (count y (replace L x y)))     [count.more]
	    = (S ((count x L) + (count y L)))   [ind-hyp]])
	  (!chain
	   [((count x (z :: L)) + (count y (z :: L)))
	    = ((count x (y :: L)) + (count y (z :: L)))
	    = ((count x L) + (count y (y :: L))) [count.same (y = z)]
	    = ((count x L) + (S (count y L)))    [count.more]
	    = (S ((count x L) + (count y L)))    [Plus.right-nonzero]]))
       assume (y =/= z)
         (!two-cases
	  assume (x = z)
            (!combine-equations
	     (!chain
	      [(count y (replace (z :: L) x y))
	       = (count y (y :: (replace L x y))) [equal]
	       = (S (count y (replace L x y)))    [count.more]
	       = (S ((count x L) + (count y L)))  [ind-hyp]])
	     (!chain
	      [((count x (z :: L)) + (count y (z :: L)))
	       = ((S (count x L)) + (count y L))  [count.more count.same]
	       = (S ((count x L) + (count y L)))  [Plus.left-nonzero]]))
	  assume (x =/= z)
            (!combine-equations
	     (!chain
	      [(count y (replace (z :: L) x y))
	       = (count y (z :: (replace L x y))) [unequal]
	       = (count y (replace L x y))        [count.same]
	       = ((count x L) + (count y L))      [ind-hyp]])
	     (!chain
	      [((count x (z :: L)) + (count y (z :: L)))
	       = ((count x L) + (count y L))      [count.same]]))))
}

conclude cancellation :=  (forall x y . zero < y ==> (x * y) / y = x)
by-induction cancellation {
  zero => pick-any y
            assume (zero < y)
              (!chain [((zero * y) / y)
		       = (zero / y)     [Times.left-zero]
		       = zero           [basis (zero < y)]])
| (S x) => 
    pick-any y
      let {ind-hyp := (forall ?y . zero < ?y ==> (x * ?y) / ?y = x)}
        assume (zero < y)
	  let {B := conclude (~ x * y + y < y)
                      (!chain-> [(~ x * y + y < y)
		             <== (y <= x * y + y)  [Less=.trichotomy3]
			     <== (y <= y + x * y)  [Plus.commutative]
			     <== (y <= y)          [Less=.Plus-k1]
			     <== true              [Less=.reflexive]])}
            conclude ((((S x) * y) / y) = (S x))
             (!chain [(((S x) * y) / y)
	            = ((y + x * y) / y)           [Times.left-nonzero]
		    = ((x * y + y) / y)           [Plus.commutative]
		    = (S (((x * y + y) - y) / y)) [reduction B]
		    = (S ((x * y) / y))           [Plus.commutative 
						   Minus.cancellation]
		    = (S x)                       [ind-hyp]])
}

conclude division-algorithm := (forall x y . zero < y ==> (x / y) * y + x % y = x & x % y < y)
 (!strong-induction.principle division-algorithm
   method (x)
    assume IND-HYP := (strong-induction.hypothesis division-algorithm x)
      conclude (strong-induction.conclusion division-algorithm x)
       pick-any y
         assume (zero < y)
           conclude ((x / y) * y + x % y = x & x % y < y)
             (!two-cases
	       assume (x < y)
                 let {C1 := 
                        (!chain->
			 [(x < y) ==> (x / y = zero) [Div.basis]]);
                      C2 := 
                        (!chain->
			 [(x < y) ==> (x % y = x)    [Mod.basis]]);
                      C3 :=
		        (!chain 
			 [((x / y) * y + (x % y))
			  = (zero * y + x)   [C1 C2]
			  = x [Times.left-zero Plus.left-zero]]);
                      C4 := (!chain->
			     [(x < y) ==> (x % y < y) [C2]])}
                   (!both C3 C4)
               assume (~ x < y)
                 let {C1 := 
                        (!chain->
			 [(~ x < y & zero < y) 
			  ==> (x / y = (S ((x - y) / y))) 
			                           [Div.reduction]]);
                      C2 := 
                        (!chain->
			 [(~ x < y & zero < y) 
			  ==> (x % y = (x - y) % y) 
                                                   [Mod.reduction]]);
                      C3 := (!chain->
			     [(~ x < y) ==> (y <= x)  
                                                   [Less=.trichotomy2]]);
                      C4 := 
		        (!chain->
			 [(zero < y & y <= x)   
			  ==> (x - y < x)          [Minus.<-left]
			  ==> (forall ?v . zero < ?v ==>
                                (((x - y) / ?v) * ?v + (x - y) % ?v 
				 = x - y &
                                 (x - y) % ?v < ?v))	 [IND-HYP]]);
                      C5 :=
                        (!chain->
			 [(zero < y)
			   ==> (((x - y) / y) * y + (x - y) % y = x - y
				& (x - y) % y < y)         [C4]]);
                      C5a := (!left-and C5);
                      C5b := (!right-and C5);
                      C6 :=
                        (!chain 
			 [((x / y) * y + x % y)
			  = ((S ((x - y) / y)) * y + (x - y) % y) 
                                            [C1 C2]
			  = ((y + ((x - y) / y) * y) + (x - y) % y)
			                    [Times.left-nonzero]
			  = (y + (((x - y) / y) * y + (x - y) % y))
			                    [Plus.associative]
			  = (y + (x - y))   [C5a]
			  = ((x - y) + y)   [Plus.commutative]
			  = x               [C3 Minus.Plus-Cancel]])}
                    (!chain->
		     [C5b ==> (x % y < y)        [C2]
			  ==> (C6 & (x % y < y)) [augment]])))

conclude division-algorithm-corollary1 := (forall x y . zero < y ==> (x / y) * y + x % y = x)
   let {theorem := division-algorithm}
    (!mp (!taut (theorem ==> division-algorithm-corollary1))
	 theorem)
   
conclude division-algorithm-corollary2 := (forall x y . zero < y ==> x % y < y)
    let {theorem := division-algorithm}
    (!mp (!taut (theorem ==> division-algorithm-corollary2))
	 theorem)
 
conclude characterization := (forall x y . y divides x <==> exists z . y * z = x)
  pick-any x y
   (!two-cases
    assume (zero < y)
       (!equiv
	assume A := (y divides x)
          let {B := (!chain-> [A ==> (x % y = zero)  [left-positive]])}
  	    (!chain-> [(zero < y)
		   ==> ((x / y) * y + x % y = x)   
		                         [division-algorithm-corollary1]
		   ==> ((x / y) * y + zero = x)      [B]
		   ==> ((x / y) * y = x)             [Plus.right-zero]
		   ==> (y * (x / y) = x)             [Times.commutative]
		   ==> (exists ?z . y * ?z = x)      [existence]])
        assume A := (exists ?z . y * ?z = x)
          pick-witness z for A A-w
            (!by-contradiction (y divides x)
             assume B := (~ y divides x)
               let {C := (!chain-> [(zero < y) 
				    ==> (y divides x <==> x % y = zero) 
				                     [left-positive]])}
	       (!absurd
		(!chain->
		 [B ==> (x % y =/= zero) [C]
		    ==> (zero < x % y)   [Less.zero<]
		    ==> (zero + (x / y) * y < x % y + (x / y) * y) 
		                           [Less.Plus-k]
		    ==> ((x / y) * y < (x / y) * y + x % y)  
		                       [Plus.left-zero Plus.commutative]
		    ==> ((x / y) * y < x)  
                                       [division-algorithm-corollary1]
		    ==> (y * (x / y) < y * z)  [A-w Times.commutative]
		    ==> (x / y < z)            [Times.<-cancellation]
		    ==> ((y * z) / y < z)      [A-w]
		    ==> (z < z)   [Times.commutative Div.cancellation]])
		(!chain-> [true ==> (~ z < z)  [Less.irreflexive]]))))
    assume (~ zero < y)
      let {C := (!chain-> [(~ zero < y) ==> (y = zero)  [Less.=zero]])}
        (!equiv
	 assume A := (y divides x)
	   (!chain-> [A ==> (x = zero)                [left-zero]
			==> (zero = x)                [sym]
			==> (y * zero = x)            [Times.right-zero]
			==> (exists ?z . y * ?z = x)  [existence]])
	 assume A := (exists ?z . y * ?z = x)
           let {B := (!chain-> 
		      [C ==> (y divides x <==> x = zero) [left-zero]])}
           pick-witness z for A A-w
             (!chain-> [x = (y * z)            [A-w]
			  = (zero * z)         [C]
			  = zero               [Times.left-zero]
			  ==> (y divides x)    [B]])))

conclude reflexive := (forall x . x divides x)
pick-any x
    (!chain-> 
     [true ==> (x * one = x)             [Times.right-one]
	   ==> (exists ?y . x * ?y = x)  [existence]
	   ==> (x divides x)             [characterization]])

conclude right-zero := (forall x . x divides zero)
pick-any x
    (!chain->
     [true ==> (x * zero = zero)           [Times.right-zero]
	   ==> (exists ?y . x * ?y = zero) [existence]
	   ==> (x divides zero)            [characterization]])

conclude left-zero := (forall x . zero divides x <==> x = zero)
pick-any x
   let {right := conclude (zero divides x ==> x = zero)
                   assume (zero divides x)
                     let {C1 := (!elim zero x)}
                       pick-witness y for C1 C1-w
		         (!chain
			  [x = (zero * y)  [C1-w]
			     = zero        [Times.left-zero]]);
        left := conclude (x = zero ==> zero divides x)
                  assume (x = zero)
 		    (!chain->
		     [true ==> (zero * zero = zero)  [Times.left-zero]
			   ==> (exists ?y . zero * ?y = zero)  [existence]
			   ==> (zero divides zero)   [characterization]
			   ==> (zero divides x)      [(x = zero)]])}
     (!equiv right left)

conclude sum-lemma1 := (forall x y z . x divides y & x divides z ==> x divides (y + z)) 
pick-any x y z
    assume (x divides y & x divides z)
      pick-witness u for (!elim x y)
        pick-witness v for (!elim x z)
          let {witnessed1 := (x * u = y);
               witnessed2 := (x * v = z)}
          conclude goal := (x divides (y + z))
	    (!chain->
	     [(x * (u + v))
	      = (x * u + x * v)  [Times.left-distributive]
	      = (y + z)          [witnessed1 witnessed2]
	      ==> (exists ?w . x * ?w = y + z)   [existence]
	      ==> goal           [characterization]])
            
conclude sum-lemma2 := (forall x y z . x divides y & x divides (y + z) ==> x divides z)
pick-any x y z
    assume (x divides y & x divides (y + z))
      pick-witness u for (!elim x y) 
        pick-witness v for (!elim x (y + z))
          conclude goal := (x divides z)
            let {w1 := (x * u = y);
                 w2 := (x * v = y + z)}
	    (!chain->
	     [(x * (v - u))
	      = (x * v - x * u)  [Minus.Times-Distributivity]
	      = ((y + z) - y)    [w1 w2]
	      = z                [Minus.cancellation]
	      ==> (exists ?w . x * ?w = z)  [existence]
	      ==> goal                      [characterization]])

conclude sum := (forall x y z . x divides y & x divides z <==> x divides y & x divides (y + z))
pick-any x y z
    let {right := assume A := (x divides y & x divides z)
	            (!chain->
		     [A ==> (x divides (y + z))        [sum-lemma1]
			==> (x divides y & x divides (y + z))
                                                       [augment]]);
         left := assume A := (x divides y & x divides (y + z))
	             (!chain->
		      [A ==> (x divides z)               [sum-lemma2]
			 ==> (x divides y & x divides z) [augment]])}
       (!equiv right left)

conclude product-left-lemma := (forall x y z . x divides y ==> x divides y * z)
  pick-any x y z
    assume A := (x divides y)
      pick-witness u for (!elim x y) witnessed
        (!chain->
	 [(y * z) = ((x * u) * z)           [witnessed]
	          = (x * (u * z))           [Times.associative]
		  ==> (x * (u * z) = y * z) [sym]
		  ==> (exists ?v . x * ?v = y * z) [existence]
		  ==> (x divides y * z)     [characterization]])

conclude product-lemma := (forall x y z . x divides y | x divides z ==> x divides y * z)
pick-any x y z
    assume A := (x divides y | x divides z)
      conclude goal := (x divides y * z)
        (!cases A
          assume A1 := (x divides y)
            (!chain-> [A1 ==> goal  [product-left-lemma]])
          assume A2 := (x divides z)
            (!chain->
	     [A2 ==> (x divides z * y)  [product-left-lemma]
                 ==> goal               [Times.commutative]]))

conclude first-lemma := (forall x y z . zero < y & z divides y & z divides x % y ==> z divides x)
  pick-any x y z
    assume A := (zero < y & z divides y & z divides x % y)
      conclude goal := (z divides x)
        pick-witness u for (!elim z y) witnessed1
          pick-witness v for (!elim z (x % y)) witnessed2
            (!chain->
	     [x = ((x / y) * y + x % y)
	                [(zero < y) division-algorithm-corollary1]
		= ((x / y) * (z * u) + z * v)
		           [witnessed1 witnessed2]
		= (((x / y) * u) * z + v * z) [Times.commutative
						 Times.associative]
		= (((x / y) * u + v) * z) [Times.right-distributive]
		= (z * ((x / y) * u + v)) [Times.commutative]
		==> (z * ((x / y) * u + v) = x) [sym]
		==> (exists ?w . z * ?w = x)      [existence]
		==> goal                          [characterization]])

conclude antisymmetric := (forall x y . x divides y & y divides x ==> x = y)
  pick-any x y
    assume (x divides y & y divides x)
      pick-witness u for (!elim x y) 
       pick-witness v for (!elim y x)
        let {witnessed1 := (x * u = y);
             witnessed2 := (y * v = x)}
        (!two-cases
	 assume A1 := (x = zero)
	   (!chain->
	    [witnessed1 ==> (zero * u = y)  [A1]
			==> (zero = y)      [Times.left-zero]
			==> (x = y)         [A1]])
         assume A2 := (x =/= zero)
	   let {C1 := (!chain-> [A2 ==> (zero < x) [Less.zero<]]);
                C2 := 
		  (!chain->
		   [x = (y * v)          [witnessed2]
		      = ((x * u) * v)    [witnessed1]
		      = (x * (u * v))    [Times.associative]
		      ==> (x * (u * v) = x)    [sym]
		      ==> (u * v = one)  [C1 Times.identity-lemma1]
		      ==> (u = one)      [Times.identity-lemma2]])}
	   (!chain
	    [x = (x * one)          [Times.right-one]
	       = (x * u)            [C2]
	       = y                  [witnessed1]]))

conclude transitive := (forall x y z . x divides y & y divides z ==> x divides z)
  pick-any x y z
    assume (x divides y & y divides z)
      pick-witness u for (!elim x y) witnessed1
        pick-witness v for (!elim y z) witnessed2
          (!chain->
	   [(x * (u * v)) 
	    = ((x * u) * v)              [Times.associative]
	    = (y * v)                    [witnessed1]
	    = z                          [witnessed2]
	    ==> (exists ?w . x * ?w = z) [existence]
	    ==> (x divides z)            [characterization]])

conclude Minus-lemma := (forall x y z . x divides y & x divides z ==> x divides (y - z))
  pick-any x y z
    assume (x divides y & x divides z)
      pick-witness u for (!elim x y) witnessed1
        pick-witness v for (!elim x z) witnessed2
          (!chain->
	   [(y - z)
	    = (x * u - x * v)  [witnessed1 witnessed2]
	    = (x * (u - v))    [Minus.Times-Distributivity]
	    ==> (x * (u - v) = y - z)         [sym]
	    ==> (exists ?w . x * ?w = y - z)  [existence]
	    ==> (x divides (y - z))           [characterization]])

conclude Mod-lemma := (forall x y z . x divides y & x divides z & zero < z ==> x divides y % z)
  pick-any x y z
    assume (x divides y & x divides z & zero < z)
      let {C1 := (!chain->
		  [(zero < z) 
		   ==> ((y / z) * z + y % z = y) 
                           [division-algorithm-corollary1]]);
           C2 := 
            conclude (x divides (y / z) * z)
	      (!chain->
	       [(x divides z) 
		==> (x divides z * (y / z)) [product-left-lemma]
		==> (x divides (y / z) * z) [Times.commutative]])}
      (!chain->
       [(x divides y)
	==> (x divides ((y / z) * z + y % z))         [C1]
	==> (C2 & (x divides ((y / z) * z + y % z)))  [augment]
	==> (x divides y % z)                         [sum-lemma2]])

conclude nonzero-even' := (forall x n . n =/= zero & Even n ==> (fast-power' x n) = square (fast-power' x half n)) 
pick-any x n
    assume (n =/= zero & Even n)
      (!two-cases
        assume (n = one)
	  (!from-complements
	   ((fast-power' x n) = square (fast-power' x half n))
	   (Even n)
	   (!chain-> [(odd S zero)
		      ==> (odd n)      [(n = one) one-definition]
		      ==> (~ even n)   [EO.not-even-if-odd]]))
       assume (n =/= one)
	 (!chain [(fast-power' x n) = (square (fast-power' x half n))
		                       [nonzero-nonone-even]]))

conclude nonzero-odd' := (forall x n . n =/= zero & ~ Even n ==> (fast-power' x n) = (square (fast-power' x half n)) * x)
pick-any x n
    assume (n =/= zero & ~ even n)
      (!two-cases
        assume (n = one)
	 (!combine-equations
	  (!chain [(fast-power' x n) --> x  [if-one]])
    	  (!chain [((square (fast-power' x half n)) * x)
		   --> ((square (fast-power' x zero)) * x)
		      [(n = one) one-definition half.if-one]
                   --> ((square one) * x)  [if-zero']
	           --> x  [square.definition Times.left-one]]))
        assume (n =/= one)
	  (!chain
	   [(fast-power' x n) --> ((square (fast-power' x half n)) * x)
	      [nonzero-nonone-odd]]))

conclude correctness' := (forall n x . (fast-power' x n) = x ** n)
  (!strong-induction.principle correctness' 
   (step fast-power' if-zero' nonzero-even' nonzero-odd'))

conclude common-divisor := (forall y x . (euclid x y) is-common-divisor [x y])
 (!strong-induction.principle common-divisor
   method (y)
    assume IND-HYP := (strong-induction.hypothesis common-divisor y)
      conclude (strong-induction.conclusion common-divisor y)
        pick-any x
          conclude ((euclid x y) is-common-divisor [x y])
	    (!two-cases
              assume A1 := (y = zero)
                let {C1 := (!chain [(euclid x y) = x  [base A1]]);
                     C2 :=
		      (!chain->
		       [true ==> (x divides x)  [divides.reflexive]
			     ==> ((euclid x y) divides x)  [C1]])}
                  (!chain->
		   [true ==> ((euclid x y) divides zero) 
			                    [divides.right-zero]
                         ==> ((euclid x y) divides y)      [A1]
                         ==> (C2 & (euclid x y) divides y) [augment]])
              assume A2 := (y =/= zero)
                let {C1 :=                       
		      (!chain
		       [(euclid x y) 
			= (euclid y (x % y)) [reduction A2]]);
		     C2 := 
                      (!chain->
		       [(y =/= zero) ==> (zero < y)   [Less.zero<]]);
                     C3 :=
		      (!chain-> 
		       [C2
		    ==> (x % y < y)   [division-algorithm-corollary2]
		    ==> (forall ?x' . 
			   (euclid ?x' (x % y)) 
		             is-common-divisor [?x' (x % y)])   [IND-HYP]
		    ==> ((euclid y (x % y))
                           is-common-divisor [y (x % y)]) [(specify [y])]
		    ==> ((euclid x y) is-common-divisor [y (x % y)])
			                                    [C1]]);
                     C4 := (!left-and C3)}
		  (!chain-> [(C2 & C3) 
			 ==> ((euclid x y) divides x) [divides.first-lemma]
			 ==> ((euclid x y) divides x & C4)  [augment]])))

conclude greatest := (forall y x z . z is-common-divisor [x y] ==> z divides (euclid x y))
 (!strong-induction.principle greatest
   method (y)
    assume IND-HYP := (strong-induction.hypothesis greatest y)
      conclude (strong-induction.conclusion greatest y)
        pick-any x z
	  assume (z is-common-divisor [x y])
            conclude (z divides (euclid x y))
	      (!two-cases
                assume A1 := (y = zero)
                  (!chain-> 
		   [(z divides x) ==> (z divides (euclid x y)) [A1 base]])
                assume A2 := (y =/= zero)
                  let {C1 := 
		        (!chain
			 [(euclid x y) 
			  = (euclid y (x % y))    [A2 reduction]]);
		       C2 := 
		        (!chain->
			 [(y =/= zero) ==> (zero < y)   [Less.zero<]]);
                       C3 := 
                        (!chain->
			 [C2 
			  ==> (z divides x & z divides y & C2)   [augment]
			  ==> (z divides x % y)    [divides.Mod-lemma]]);
                       C4 := 
		        (!chain-> 
			 [C2
		      ==> (x % y < y) 
			            [division-algorithm-corollary2]
		      ==> (forall ?x' ?z .
			    ?z is-common-divisor [?x' (x % y)] ==> 
			    ?z divides (euclid ?x' (x % y)))   [IND-HYP]
                      ==> (z is-common-divisor [y (x % y)] ==>
			   z divides (euclid y (x % y))) 
                                                      [(specify [y z])]])}
                  (!chain-> [(z divides y & C3) 
			     ==> (z divides (euclid y (x % y))) [C4]
			     ==> (z divides (euclid x y))         [C1]])))

conclude correctness := (forall x y . (euclid x y) is-common-divisor [x y] & forall z . z is-common-divisor [x y] ==> z divides (euclid x y))
  pick-any x y
    (!both (!chain-> [true ==> ((euclid x y) is-common-divisor [x y])
                                                   [common-divisor]])
           pick-any z
             (!chain [(z is-common-divisor [x y])
		      ==> (z divides (euclid x y)) [greatest]]))

conclude double := (forall n . half (n + n) = n)
by-induction double {
  zero => (!chain [(half (zero + zero))
	       --> (half zero)         [Plus.right-zero]
               --> zero                [if-zero]])
| (S zero) => 
    (!chain [(half (S zero + S zero))
	 --> (half S (S zero + zero))  [Plus.right-nonzero]
	 --> (half S S (zero + zero))  [Plus.left-nonzero]
	 --> (half S S zero)           [Plus.right-zero]
	 --> (S half zero)             [nonzero-nonone]
	 --> (S zero)                  [if-zero]])
| (S (S n)) => 
   let {induction-hypothesis := (half (n + n) = n)}
    (!chain 
     [(half (S S n + S S n))
      --> (half S (S S n + S n))       [Plus.right-nonzero]
      --> (half S S (S S n + n))       [Plus.right-nonzero]
      --> (S half (S S n + n))         [nonzero-nonone]
      --> (S half S (S n + n))         [Plus.left-nonzero]
      --> (S half S S (n + n))         [Plus.left-nonzero]
      --> (S S half (n + n))           [nonzero-nonone]
      --> (S S n)                      [induction-hypothesis]])
}

conclude Times-two := (forall x . half (two * x) = x)
  pick-any x
    (!chain [(half (two * x))
             --> (half (x + x))    [Times.two-times]
             --> x                 [double]])
 
conclude twice := (forall x . two * half S S x = S S (two * half x))
  pick-any x
    (!chain [(two * half S S x)
	 --> (two * S half x)             [nonzero-nonone]
	 --> ((S half x) + (S half x))    [Times.two-times]
	 --> (S ((half x) + S half x))    [Plus.left-nonzero]
	 --> (S S ((half x) + half x))    [Plus.right-nonzero]
	 --> (S S (two * half x))         [Times.two-times]])

conclude two-plus := (forall x y . half (two * x + y) = x + half y)
by-induction two-plus {
  zero =>
   pick-any y
     (!chain [(half ((two * zero) + y))
              --> (half (zero + y))   [Times.right-zero]
              --> (half y)            [Plus.left-zero]
              <-- (zero + half y)     [Plus.left-zero]])
| (S zero) =>
    pick-any y
      (!chain [(half (two * (S zero) + y))
	       <-- (half (two * one + y))    [one-definition]
	       --> (half (two + y))          [Times.right-one]
	       --> (half ((S one) + y))      [two-definition]
	       --> (half S (one + y))        [Plus.left-nonzero]
	       --> (half S ((S zero) + y))   [one-definition]
	       --> (half S S (zero + y))     [Plus.left-nonzero]
	       --> (half S S y)              [Plus.left-zero]
	       --> (S half y)                [nonzero-nonone]
	       <-- (one + half y)            [Plus.left-one]
	       --> ((S zero) + half y)       [one-definition]])
| (S (S x)) => 
    let {induction-hypothesis :=
           (forall ?y . half (two * x + ?y) = x + half ?y)}
    pick-any y
      (!chain 
       [(half (two * (S S x)) + y)
	--> (half (((S S x) + (S S x)) + y))     [Times.two-times]
	--> (half (S (S ((x + S S x) + y))))     [Plus.left-nonzero]
	--> (S half ((x + (S (S x))) + y))       [nonzero-nonone]
	--> (S half ((S S (x + x)) + y))         [Plus.right-nonzero]
	--> (S half S S ((x + x) + y))           [Plus.left-nonzero]
	--> (S S half ((x + x) + y))             [nonzero-nonone]
	<-- (S S half (two * x + y))             [Times.two-times]
	--> (S S (x + half y))                   [induction-hypothesis]
	<-- (S ((S x) + half y))                 [Plus.left-nonzero]
	<-- ((S S x) + half y)                   [Plus.left-nonzero]])
}

conclude less-S := (forall n . half n < S n)
by-induction less-S {
  zero => (!chain-> [true 
                ==> (zero < S zero)             [Less.<S]
		==> (half zero < S zero)        [if-zero]])
| (S zero) => 
    let {C := (!chain-> [true
                     ==> (zero < S zero)        [Less.<S]
 	             ==> (half S zero < S zero) [if-one]])}
    (!chain-> [true 
           ==> (S zero < S S zero)              [Less.<S]
	   ==> (S zero < S S zero & C)          [augment]
	   ==> (half S zero < S S zero)         [Less.transitive]])
| (n as (S (S n'))) => 
    let {ind-hyp := (half n' < S n');
         C := (!chain-> [true 
                     ==> (S S n' < S S S n')    [Less.<S]])}
    (!chain-> [ind-hyp 
           ==> (S half n' < S S n')             [Less.injective] 
           ==> (half S S n' < S S n')           [nonzero-nonone]
           ==> (half S S n' < S S n' & C)       [augment]
           ==> (half S S n' < S S S n')         [Less.transitive]])
}

conclude less := (forall n . n =/= zero ==> half n < n)
datatype-cases less {
  zero => assume (zero =/= zero)
	    (!from-complements (half zero < zero) 
			       (!reflex zero) 
                               (zero =/= zero))
| (S zero) => 
    assume (S zero =/= zero)
      (!chain-> [true 
             ==> (zero < S zero)         [Less.<S]
             ==> (half S zero < S zero)  [if-one]])
| (n as (S (S m))) => 
    assume (S S m =/= zero)
      (!chain-> [true 
             ==> (half m < S m)          [less-S]
      	     ==> (S half m < S S m)      [Less.injective]
 	     ==> (half S S m < S S m)    [nonzero-nonone]])
}

conclude equal-zero := (forall x . half x = zero ==> x = zero | x = one)
datatype-cases equal-zero {
  zero =>
    assume (half zero = zero) 
      (!left-either (!reflex zero) (zero = one))
| (S zero) =>
    assume (half S zero = zero) 
      let {B := (!chain [(S zero) = one   [one-definition]])}
        (!right-either (S zero = zero) B)
| (S (S n)) =>
    assume A := (half S S n = zero) 
      let {is := (!chain-> [zero = (half S S n)     [A]
			         = (S half n)       [nonzero-nonone]
			    ==> (S half n = zero)   [sym]]);
           is-not := (!chain-> 
		      [true ==> (S half n =/= zero) [S-not-zero]])}
      (!from-complements (S S n = zero | S S n = one) is is-not)
}

conclude less-equal := (forall n . half n <= n)
datatype-cases less-equal {
  zero =>
  conclude (half zero <= zero)
    (!chain-> [true ==> (zero <= zero)      [Less=.reflexive]
		    ==> (half zero <= zero) [if-zero]])
| (S n) =>
  conclude (half S n <= S n)
    (!chain-> [true ==> (S n =/= zero)      [S-not-zero]
		    ==> (half S n < S n)    [less]
		    ==> (half S n <= S n)   [Less=.Implied-by-<]])
}

conclude less-equal-1 := (forall n . n =/= zero ==> S half n <= n)
datatype-cases less-equal-1 {
  zero =>
  conclude (zero =/= zero ==> S half zero <= zero)
    assume (zero =/= zero)
     (!from-complements (S half zero <= zero)
      (!reflex zero) (zero =/= zero))
| (S zero) =>
  conclude (S zero =/= zero ==> S half S zero <= S zero)
    assume (S zero =/= zero)
      (!chain-> [true ==> (S zero <= S zero)        [Less=.reflexive] 
		      ==> (S half S zero <= S zero) [if-one]])
| (S (S n)) =>
  conclude (S S n =/= zero ==> S half S S n <= S S n)
    assume (S S n =/= zero)
      (!chain-> [true ==> (half n <= n)           [less-equal]
		      ==> (S half n <= S n)       [Less=.injective]
		      ==> (S S half n <= S S n)   [Less=.injective]
		      ==> (S half S S n <= S S n) [nonzero-nonone]])
}

conclude even-zero := (even zero)
  (!chain-> [(two * half zero) 
	     --> ((half zero) + (half zero)) [Times.two-times] 
	     --> (zero + zero)               [half.if-zero]
	     --> zero                        [Plus.right-zero]
	     ==> (even zero)                 [even-definition]])

conclude odd-one := (odd S zero)
  (!chain-> [(two * (half S zero) + one)
	     --> (S (two * (half S zero)))   [Plus.right-one]
	     --> (S (two * zero))            [half.if-one]
	     --> (S zero)                    [Times.right-zero]
	     ==> (odd S zero)                [odd-definition]])

conclude even-S-S := (forall n . even S S n <==> even n)
pick-any n 
    let {right := assume (even S S n)
                    (!chain-> 
		     [(S S (two * (half n)))
		  <-- (two * half S S n)         [half.twice]
		  --> (S S n)                    [even-definition]
		  ==> ((S (two * half n)) = S n) [S-injective]
		  ==> (two * (half n) = n)       [S-injective]
		  ==> (even n)                   [even-definition]]);
         left := assume (even n)
       	           (!chain-> 
		    [(two * half S S n)
		 --> (S S (two * half n))      [half.twice]
		 --> (S S n)                   [even-definition]
		 ==> (even S S n)              [even-definition]])}
     (!equiv right left)
     
conclude odd-S-S := (forall n . odd S S n <==> odd n)
pick-any n 
    let {right := 
           assume (odd S S n)
             (!chain-> 
	      [(S S S (two * half n))
	       <-- (S (two * half S S n))         [half.twice]
	       <-- (two * (half S S n) + one)     [Plus.right-one]
	       --> (S S n)                        [odd-definition]
	       ==> (S S (two * half n) = S n)     [S-injective]
	       ==> (S (two * half n) = n)         [S-injective]
	       ==> (two * (half n) + one = n)     [Plus.right-one]
	       ==> (odd n)                        [odd-definition]]);
         left :=
           assume (odd n)
             (!chain-> 
	      [((two * (half S S n)) + one)
	       --> (S (two * half S S n))        [Plus.right-one]
	       --> (S S S (two * half n))        [half.twice]
	       <-- (S S (two * (half n) + one))  [Plus.right-one]
	       --> (S S n)                       [odd-definition]
	       ==> (odd S S n)                   [odd-definition]])}
      (!equiv right left)

conclude odd-if-not-even  := (forall x . ~ even x ==> odd x)
by-induction odd-if-not-even {
  zero => assume (~ even zero)
            (!from-complements 
	     (odd zero) even-zero (~ even zero))
| (S zero) => 
    assume (~ (even (S zero)))
      (!chain-> 
       [((two * (half S zero)) + one)
	--> (S (two * half S zero))   [Plus.right-one]
	--> (S (two * zero))          [half.if-one]
	--> (S zero)                  [Times.right-zero]
	==> (odd S zero)              [odd-definition]])
| (S (S x)) => 
    let {induction-hypothesis := (~ even x ==> odd x)}
      conclude (~ even S S x ==> odd S S x)
        assume hyp := (~ even S S x)
	  let {_ := (!by-contradiction (~ even x)
		     (!chain [(even x) 
		          ==> (even S S x)        [even-S-S]
			  ==> (hyp & even S S x)  [augment]
			  ==> false               [prop-taut]]))}
	    (!chain-> [(~ even x)
		       ==> (odd x)         [induction-hypothesis]
		       ==> (odd S S x)     [odd-S-S]])
}

conclude half-nonzero-if-nonzero-even := (forall n . n =/= zero & even n ==> half n =/= zero)
pick-any n
    assume (n =/= zero & even n)
      (!by-contradiction (half n =/= zero)
        assume opposite := (half n = zero) 
          let {is := (!chain [n <-- (two * half n) [even-definition]
			        --> (two * zero)   [opposite]
				--> zero       [Times.right-zero]]);
               is-not := (n =/= zero)}
          (!absurd is is-not))

conclude half-nonzero-if-nonone-odd := (forall n . n =/= one & odd n ==> half n =/= zero)
pick-any n
    assume (n =/= one & odd n)
      (!by-contradiction (half n =/= zero)
        assume opposite := (half n = zero)
          let {n-one := (!chain 
			 [n <-- (two * (half n) + one) [odd-definition]
			    --> (two * zero + one)     [opposite]
			    --> (zero + one)           [Times.right-zero]
			    --> one                    [Plus.left-zero]])}
          (!absurd n-one (n =/= one)))
  
conclude even-twice := (forall x . even (two * x))
pick-any x
    (!chain-> [(two * half (two * x))
	       --> (two * x)           [half.Times-two]
	       ==> (even (two * x))    [even-definition]])

conclude even-square := (forall x . even x <==> even square x)
  pick-any x 
    let {right :=
          assume (even x) 
           let {i := conclude (two * half square x = square x)
		      (!combine-equations
		       (!chain 
			[(two * half square x)
	             <-- (two * half square (two * half x))
		                         [even-definition]
		     --> (two * half ((two * (half x)) * 
				       (two * (half x))))
		                         [square.definition]
		     --> (two * half two * ((half x) * (two * half x)))
		                         [Times.associative]
		     --> (two * ((half x) * (two * half x)))
		                         [half.Times-two]])
		       (!chain 
			[(square x)
		     <-- (square (two * half x))
		                         [even-definition]
		     --> ((two * half x) * (two * half x))  
		                         [square.definition]
		     --> (two * ((half x) * (two * half x)))
		                         [Times.associative]]))}
	    (!chain-> [i ==> (even square x) [even-definition]]);
         left := 
          assume (even square x)
            (!by-contradiction (even x)
             assume hyp := (~ even x) 
               let {_ := (!chain-> [hyp ==> (odd x) [odd-if-not-even]]);
		    A := conclude (two * (half square x) + one = square x) 
                           let {i := conclude (square x = 
					       two * ((half x) * x) + x)
				       (!chain 
					[(square x)
				     --> (x * x) [square.definition]
				     <-- (((two * half x) + one) * x)   
				                 [odd-definition]
				     --> ((two * half x) * x + one * x)
				                 [Times.right-distributive]
				     --> (two * ((half x) * x) + x)
				                 [Times.associative 
						  Times.left-one]]);
                                ii := conclude (half square x = 
						(half x) * x + half x)
                                        (!chain 
					 [(half square x)
				      --> (half (two * ((half x) * x) + x))
				                 [i]
				      --> ((half x) * x + half x) 
						 [half.two-plus]]);
                                iii := conclude 
                                         (two * (half square x) + one =
					  two * ((half x) * x) + x)
                                         (!chain 
					  [(two * (half square x) + one)
				       --> (two * ((half x) * x + half x)
				                       + one)   [ii]
				       --> ((two * ((half x) * x) +
					    two * half x) + one)
				                 [Times.left-distributive]
				       --> (two * ((half x) * x) +
					    two * (half x) + one)
				                 [Plus.associative]
				       --> (two * ((half x) * x) + x)
				                 [odd-definition]])}
		           (!combine-equations iii i)}
               (!absurd
		(!chain-> [A ==> (odd square x) [odd-definition]])
		(!chain-> [(even square x) ==> (~ odd square x)
			           [not-odd-if-even]])))}
    (!equiv right left)

conclude half-case := (forall n . two * (half n) + parity n = n)
 pick-any n
    (!two-cases 
      assume (even n)
       (!chain [(two * (half n) + parity n)
		--> (two * (half n) + zero)    [if-even]
		--> (two * half n)             [Plus.right-zero]
		--> n                          [EO.even-definition]])
      assume (~ (even n))
       (!chain-> [(~ even n)  
		  ==> (odd n)  [EO.odd-if-not-even]
		  ==> (two * (half n) + one = n) [EO.odd-definition]
		  ==> (two * (half n) + parity n = n)       [if-odd]]))

conclude plus-half := (forall n . n =/= zero ==> (half n) + parity n =/= zero)
pick-any n
    assume A := (n =/= zero)
      (!two-cases
        assume B := (even n)
          let {C := (!chain
		     [((half n) + parity n)
		      = ((half n) + zero)   [if-even]
		      = (half n)            [Plus.right-zero]])}
          (!chain-> [(A & B) 
		     ==> (half n =/= zero) 
			    [EO.half-nonzero-if-nonzero-even]
		     ==> ((half n) + parity n =/= zero) [C]])
        assume (~ even n)
         let {C := (!chain
		    [((half n) + parity n)
                     = ((half n) + S zero)   [if-odd one-definition]
		     = (S ((half n) + zero)) [Plus.right-nonzero]])}
         (!chain-> [true ==> (S ((half n) + zero) =/= zero)
			                           [S-not-zero] 
			 ==> ((half n) + parity n =/= zero) [C]]))

conclude <S           := (forall n . n < S n)
by-induction Less.<S {
  zero => (!chain-> [true ==> (zero < S zero) [Less.zero<S]])
| (S n) => (!chain-> [(n < S n) ==> (S n < S S n) [Less.injective]])
}

conclude =zero        := (forall n . ~ zero < n ==> n = zero)
datatype-cases Less.=zero {
  zero =>
    assume (~ zero < zero)
      (!reflex zero)
| (S n) =>
    assume A := (~ zero < S n)
      (!from-complements (S n = zero)
	A
	(!chain-> [true ==> (zero < S n) [Less.zero<S]]))
}

conclude <S           := (forall n . n < S n)
by-induction Less.<S {
  zero => (!chain-> [true ==> (zero < S zero) [Less.zero<S]])
| (S n) => (!chain-> [(n < S n) ==> (S n < S S n) [Less.injective]])
}

conclude zero<        := (forall n . n =/= zero <==> zero < n)
  pick-any n
    (!equiv
     conclude (n =/= zero ==> zero < n)
       (!contra-pos (!instance Less.=zero [n]))
   conclude (zero < n ==> n =/= zero)
     assume (zero < n)
       (!by-contradiction (n =/= zero)
	assume (n = zero)
          (!absurd 
	   (!chain-> [(zero < n) ==> (zero < zero)  [(n = zero)]])
	   (!chain-> [true ==> (~ zero < zero)      [Less.not-zero]]))))

conclude S1           := (forall x y . S x < y ==> x < y)
by-induction Less.S1 {
  zero => 
  conclude (forall ?y . S zero < ?y ==> zero < ?y)
    pick-any y
      assume Less := (S zero < y)
	(!two-cases 
	  assume (y = zero)
	    (!by-contradiction (zero < y)
	      assume (~ zero < y) 
                let {not-Less := 
		       conclude (~ S zero < y)
		         (!chain-> 
			  [true ==> (~ S zero < zero) [Less.not-zero]
				==> (~ S zero < y)    [(y = zero)]])}
	          (!absurd Less not-Less))
	  assume nonzero := (y =/= zero) 
	    let {has-predecessor := 
                   (!chain-> [nonzero ==> (exists ?m . y = S ?m) 
				 	     [nonzero-S]])}
	      pick-witness m for has-predecessor
	        (!chain-> 
		 [true ==> (zero < S m) [Less.zero<S]
		       ==> (zero < y)     [(y = S m)]]))
| (S n) =>
  conclude (forall ?y . S S n < ?y ==> S n < ?y) 
    let {induction-hypothesis :=  (forall ?y . S n < ?y ==> n < ?y)}
      pick-any y
        assume Less := (S S n < y)
	  (!two-cases 
	    assume (y = zero)
	      (!by-contradiction (S n < y)
	        assume (~ S n < y)
                  let {not-Less := 
		        (!chain-> 
			 [true 
			  ==> (~ S S n < zero) [Less.not-zero]
			  ==> (~ S S n < y)    [(y = zero)]])}
                    (!absurd Less not-Less))
	   assume nonzero := (y =/= zero) 
	     let {has-predecessor := 
                    (!chain-> 
		     [nonzero 
		      ==> (exists ?m . y = S ?m) [nonzero-S]])}
	       pick-witness m for has-predecessor witnessed
	         (!chain-> 
		  [(S S n < y)
		   ==> (S S n < S m) [witnessed]
		   ==> (S n < m)     [Less.injective]
		   ==> (n < m)       [induction-hypothesis]
		   ==> (S n < S m)   [Less.injective]
		   ==> (S n < y)     [(y = S m)]]))
}

conclude S1           := (forall x y . S x < y ==> x < y)
by-induction Less.S1 {
  zero =>
  datatype-cases (forall ?y . S zero < ?y ==> zero < ?y) {
    zero => 
      assume is-Less := (S zero < zero) 
        let {is-not-Less := (!chain-> 
			     [true ==> (~ S zero < zero)
				         [Less.not-zero]])}
          (!from-complements (zero < zero) is-Less is-not-Less)
  | (S m) =>
       assume (S zero < S m)
         (!chain-> [true ==> (zero < S m) [Less.zero<S]])
  }
| (S n) => 
    let {induction-hypothesis := (forall ?y . S n < ?y ==> n < ?y)}
      datatype-cases (forall ?y . S S n < ?y ==> S n < ?y) {
        zero => 
          assume Less := (S S n < zero) 
            let {not-Less := (!chain-> 
			     [true ==> (~ S S n < zero)
				   [Less.not-zero]])}
	      (!from-complements (S n < zero) Less not-Less)
      | (S m) =>
	  (!chain [(S S n < S m)
		   ==> (S n < m)          [Less.injective]
		   ==> (n < m)            [induction-hypothesis]
		   ==> (S n < S m)        [Less.injective]])
      }
}

conclude S2           := (forall x y . x < y ==> x < S y)
datatype-cases Less.S2 {
  zero =>
    conclude (forall ?y . zero < ?y ==> zero < (S ?y))
      pick-any y
        assume (zero < y) 
          (!chain-> [true ==> (zero < S y) [Less.zero<S]])
| (S m) =>
    conclude (forall ?y . S m < ?y ==> S m < (S ?y))
      pick-any y
        (!chain [(S m < y)
		 ==> (m < y)       [Less.S1]
		 ==> (S m < S y)   [Less.injective]])
}

conclude S4           := (forall m n . S m < n ==> exists n' . n = S n')
pick-any m n 
    assume A := (S m < n)
      let {B := (!chain-> 
		 [true ==> (n = zero | (exists ?n' . n = (S ?n')))
		       [(!constructor-exhaustiveness "N")]])}
	(!cases B
          assume C := (n = zero)
	    (!from-complements (exists ?n' . n = (S ?n'))
	     (!chain-> [A ==> (S m < zero) [C]])
	     (!chain-> [true ==> (~ S m < zero) 
				[Less.not-zero]]))
	  assume D := (exists ?n' . n = (S ?n'))
            (!claim D))

conclude S-step       := (forall x y . x < S y & x =/= y ==> x < y)
by-induction Less.S-step {
  zero =>
    datatype-cases 
      (forall ?y . zero < (S ?y) & zero =/= ?y ==> zero < ?y) {
      zero =>
        assume (zero < S zero & zero =/= zero)
         (!from-complements (zero < zero) (!reflex zero) (zero =/= zero))
    | (S y) =>
        assume (zero < (S S y) & zero =/= S y)
	  (!chain-> [true ==> (zero < S y) [Less.zero<S]])
    }
| (S x) => 
    let {induction-hypothesis :=
	  (forall ?y . x < (S ?y) & x =/= ?y ==> x < ?y)}
      datatype-cases 
	  (forall ?y . S x < (S ?y) & S x =/= ?y ==> S x < ?y) {
        zero =>
          assume (S x < S zero & S x =/= zero) 
            let {Less := (!chain-> [(S x < S zero)
				    ==> (x < zero)   [Less.injective]]);
                 not-Less := (!chain-> 
			      [true ==> (~ x < zero)  [Less.not-zero]])}
	      (!from-complements (S x < zero) Less not-Less)
      | (S y) =>
          (!chain
	   [(S x < (S S y) & S x =/= S y)
	    ==> (x < S y & x =/= y) [Less.injective S-injective]
	    ==> (x < y)		    [induction-hypothesis]
	    ==> (S x < S y)         [Less.injective]])
      }
}

conclude discrete     := (forall n . ~ exists x . n < x & x < S n)
by-induction Less.discrete {
  zero =>
    (!by-contradiction (~ exists ?x . zero < ?x & ?x < S zero)
      assume A := (exists ?x . zero < ?x & ?x < S zero)
        pick-witness x for A witnessed 
	  (!two-cases 
	    assume (x = zero) 
              let {Less := (!chain-> 
			    [(zero < x) ==> (zero < zero)  [(x = zero)]]);
                   not-Less := (!chain-> 
				[true ==> (~ zero < zero) [Less.not-zero]])}
	        (!absurd Less not-Less)
	    assume (x =/= zero) 
              let {C :=
	             (!chain-> [(x =/= zero) ==> (exists ?m . x = S ?m) 
				[nonzero-S]])}
	        pick-witness m for C 
                  let {Less := (!chain-> 
				[(x < S zero) 
				 ==> (S m < S zero)   [(x = S m)]
				 ==> (m < zero)       [Less.injective]]);
                       not-Less := (!chain-> 
				    [true ==> (~ m < zero) 
					              [Less.not-zero]])}
                    (!absurd Less not-Less)))
| (S n) => 
    let {induction-hypothesis := (~ exists ?x . n < ?x & ?x < S n)}
       (!by-contradiction (~ exists ?x . S n < ?x & ?x < S S n)
         assume A := (exists ?x . S n < ?x & ?x < S S n)
           pick-witness x for A witnessed 
	     (!two-cases
	       assume (x = zero) 
                 let {is-Less := (!chain-> 
				  [(S n < x) ==> (S n < zero) 
				   [(x = zero)]]);
                      is-not-Less := (!chain-> 
				      [true ==> (~ S n < zero)
					           [Less.not-zero]])}
                   (!absurd is-Less is-not-Less)
	       assume (x =/= zero) 
	         let {C := 
	               (!chain-> [(x =/= zero) ==> (exists ?m . x = S ?m) 
				                      [nonzero-S]])}
	           pick-witness m for C witnessed 
		     let {_ := (!chain-> 
				[(S n < x) 
				 ==> (S n < S m)    [witnessed]
				 ==> (n < m)        [Less.injective]]);
		          E := (!chain-> 
				[(x < S S n)
				 ==> (S m < S S n)  [witnessed]
		                 ==> (m < S n)      [Less.injective]
				 ==> (n < m & m < S n)     [augment]
				 ==> (exists ?m . n < ?m & ?m < S n)
				                    [existence]])}
		       (!absurd E induction-hypothesis)))
}

conclude transitive   := (forall x y z . x < y & y < z ==> x < z)
  let 
   {transitive0 :=
	    (forall ?z ?x ?y . ?x < ?y & ?y < ?z ==> ?x < ?z);
    _ := by-induction transitive0 {
         zero =>
          pick-any x y
	    assume (x < y & y < zero) 
              let {not-Less := (!chain-> 
				[true ==> (~ y < zero) [Less.not-zero]])}
	        (!from-complements (x < zero) (y < zero) not-Less)
         | (S n) => 
            let {induction-hypothesis :=
                   (forall ?x ?y . ?x < ?y & ?y < n ==> ?x < n)}
              pick-any x y
                assume (x < y & y < S n)
	          conclude (x < S n) 
	            let {_ := conclude (x < n)
	                        (!two-cases
				   assume (y = n)
		                     (!chain-> 
				      [(x < y) ==> (x < n) [(y = n)]])
		                   assume (y =/= n)
		                     (!chain-> 
				      [(y =/= n)
				       ==> (y < S n & y =/= n) [augment]
				       ==> (y < n)             [Less.S-step]
				       ==> (x < y & y < n)     [augment]
				       ==> (x < n) [induction-hypothesis]]))}
	              (!chain-> [(x < n) ==> (x < S n)  [Less.S2]])
	 }}
     pick-any x y z
       (!chain [(x < y & y < z) ==> (x < z) [transitive0]])

conclude irreflexive  := (forall n . ~ n < n)
by-induction Less.irreflexive {
  zero => (!chain-> [true ==> (~ zero < zero)  [Less.not-zero]])
| (S n) => (!chain-> [(~ n < n) ==> (~ S n < S n)  [Less.injective]])
}

conclude asymmetric   := (forall m n . m < n ==> ~ n < m)
pick-any x y
    assume (x < y)
      (!by-contradiction (~ y < x)
         assume (y < x) 
           let {is-Less := (!chain-> 
			    [(y < x) 
			     ==> (x < y & y < x)     [augment]
			     ==> (x < x)             [Less.transitive]]);
                is-not-Less := (!chain-> 
				[true ==> (~ x < x)  [Less.irreflexive]])}
             (!absurd is-Less is-not-Less))

conclude S-not-<      := (forall n . ~ S n < n)
pick-any n
    (!by-contradiction (~ S n < n)
      assume (S n < n)
        (!absurd
	 (!chain-> [(S n < n) ==> (n < n)  [Less.S1]])
	 (!chain-> [true ==> (~ n < n)  [Less.irreflexive]])))

conclude Reverse-S    := (forall n m . ~ m < n ==> n < S m)
  pick-any n m
    (!chain [(~ m < n) 
	     ==> (n <= m)    [Less=.trichotomy2]
	     ==> (n < S m)   [Less=.S1]])

conclude trichotomy   := (forall m n . ~ m < n & m =/= n ==> n < m)
by-induction Less.trichotomy {
  zero =>
    pick-any n
      assume (~ zero < n & zero =/= n)
        conclude (n < zero) 
	  let {has-predecessor := 
                 (!chain-> 
		  [(zero =/= n)
		   ==> (n =/= zero)       [sym]
		   ==> (exists ?k . n = (S ?k))  [nonzero-S]])}
	     pick-witness k for has-predecessor 
               let {Less := (!chain-> 
			     [true ==> (zero < (S k)) [Less.zero<S]
				   ==> (zero < n)     [(n = (S k))]]);
                    not-Less := (~ zero < n)}
	         (!from-complements (n < zero) Less not-Less)
| (S m) => 
    let {induction-hypothesis := 
          (forall ?n . (~ m < ?n & m =/= ?n) ==> ?n < m)}
      datatype-cases (forall ?n . ~ S m < ?n & S m =/= ?n ==> 
			          ?n < S m)
      { zero => 
          assume (~ S m < zero & S m =/= zero)
	    (!chain-> [true ==> (zero < S m) [Less.zero<S]])
      | (S k) =>
          assume A := (~ S m < (S k) & S m =/= (S k))
	    (!chain-> 
	     [A ==> (~ m < k & m =/= k) [Less.injective S-injective]
		==> (k < m)             [induction-hypothesis]
		==> ((S k) < S m)       [Less.injective]])
      }
}

conclude trichotomy1  := (forall m n . ~ m < n & ~ n < m ==> m = n)
pick-any m:N n
    assume (~ m < n & ~ n < m)
      (!by-contradiction (m = n)
        (!chain 
	 [(m =/= n) ==> (~ m < n & m =/= n)  [augment]
	           ==> (n < m)               [Less.trichotomy]
		   ==> (n < m & ~ n < m)     [augment]
		   ==> false                 [prop-taut]]))

conclude trichotomy2  := (forall m n . m = n <==> ~ m < n & ~ n < m)
pick-any m:N n
    let {A := assume (m = n) 
                let {C := (!chain-> 
			   [true ==> (~ m < m)  [Less.irreflexive]])}
                  (!both (!chain-> [C ==> (~ m < n)   [(m = n)]])
			 (!chain-> [C ==> (~ n < m)   [(m = n)]]));
         B := (!chain [(~ m < n & ~ n < m) ==> (m = n) 
		                           [Less.trichotomy1]])}
      (!equiv A B)

conclude Plus-cancellation := (forall k m n . m + k < n + k ==> m < n)
by-induction Less.Plus-cancellation {
  zero =>
    pick-any m n
      (!chain [(m + zero < n + zero)
	       ==> (m < n) [Plus.right-zero]])
| (S k) => 
    let {induction-hypothesis :=
	    (forall ?m ?n . ?m + k < ?n + k ==> ?m < ?n)}
    pick-any m n
      (!chain 
       [(m + S k < n + S k)
	==> (S (m + k) < S (n + k)) [Plus.right-nonzero]
	==> (m + k < n + k)         [Less.injective]
	==> (m < n)                 [induction-hypothesis]])
}

conclude Plus-k       := (forall k m n . m < n ==> m + k < n + k)
  pick-any k m n
    assume hyp1 := (m < n) 
      let {goal := (m + k < n + k)}
        (!by-contradiction goal
          (!chain
	   [(~ goal) ==> (n + k <= m + k) [Less=.trichotomy2]
	             ==> (n <= m)         [Less=.Plus-cancellation]
		     ==> (~ m < n)        [Less=.trichotomy4]
		     ==> (hyp1 & ~ m < n) [augment]
		     ==> false            [prop-taut]]))

conclude Plus-k       := (forall k m n . m < n ==> m + k < n + k)
  pick-any k m n
    assume hyp1 := (m < n) 
      let {goal := (m + k < n + k)}
        (!by-contradiction goal
          (!chain
	   [(~ goal) ==> (n + k <= m + k) [Less=.trichotomy2]
                     ==> (n <= m)         [Less=.Plus-cancellation]
		     ==> (~ m < n)        [Less=.trichotomy4]
		     ==> false     [method (p) (!absurd hyp1 p)]]))

conclude Plus-k1      := (forall k m n . m < n ==> m < n + k)
by-induction Less.Plus-k1 {
  zero => 
    pick-any m n
      (!chain [(m < n) ==> (m < n + zero)  [Plus.right-zero]])
| (S k) =>
    let {IH := (forall ?m ?n . ?m < ?n ==> ?m < ?n + k)}
    pick-any m n 
      assume (m < n)
        conclude (m < n + (S k))
          (!chain-> 
	   [true ==> (k < (S k))          [Less.<S]
		 ==> (k + n < (S k) + n)  [Less.Plus-k]
		 ==> (n + k < n + (S k))  [Plus.commutative]
		 ==> (m < n & n + k < n + (S k))   [augment]
		 ==> (m < n + k & n + k < n + (S k))    [IH]
		 ==> (m < n + (S k))      [Less.transitive]])
}

conclude Plus-k-equiv := (forall k m n . m < n <==> m + k < n + k)
  pick-any k m n
    (!equiv (!chain [(m < n) ==> (m + k < n + k) [Less.Plus-k]])
	    (!chain [(m + k < n + k) ==> (m < n) [Less.Plus-cancellation]]))

conclude not-equal    := (forall m n . m < n ==> m =/= n)
pick-any m:N n
    assume (m < n)
      (!by-contradiction (m =/= n)
	 assume (m = n) 
           let {is-not-Less := 
		  (!chain-> 
		   [(m = n) ==> (~ m < n & ~ n < m) [Less.trichotomy2]
		            ==> (~ m < n)           [left-and]])}
	     (!absurd (m < n) is-not-Less))

conclude not-equal1   := (forall m n . m < n ==> n =/= m)
pick-any m:N n
    assume (m < n)
      (!by-contradiction (n =/= m)
	assume (n = m) 
          let {is-not-Less := 
                 (!chain-> 
		  [m = n                       [(n = m)]
		     ==> (~ m < n & ~ n < m)   [Less.trichotomy2]
		     ==> (~ (m < n))           [left-and]])}
 	    (!absurd (m < n) is-not-Less))

conclude Implied-by-<     := (forall m n . m < n ==> m <= n)
pick-any m n
    (!chain [(m < n) ==> (m < n | m = n)   [alternate]
	             ==> (m <= n)          [Less=.definition]])

conclude Implied-by-equal := (forall m n . m = n ==> m <= n)
pick-any m:N n
    (!chain [(m = n) ==> (m < n | m = n)   [alternate]
	             ==> (m <= n)          [Less=.definition]])

conclude reflexive   := (forall n . n <= n)
  pick-any n
    let {disj := (!right-either (n < n) (!reflex n))}
      (!chain-> [disj ==> (n <= n) [Less=.definition]])

conclude zero<=      := (forall n . zero <= n)
datatype-cases Less=.zero<= {
  zero =>
   (!chain-> 
    [(zero = zero) ==> (zero <= zero) [Less=.Implied-by-equal]])
| (S n) =>
   (!chain-> 
    [true ==> (zero < S n)      [Less.zero<S]
	  ==> (zero <= S n)     [Less=.Implied-by-<]])
}

conclude S-zero-S-n  := (forall n . S zero <= S n)
datatype-cases Less=.S-zero-S-n {
  zero => 
    let {disj := (!right-either (S zero < S zero) (!reflex (S zero)))}
      (!chain-> 
       [disj ==> (S zero <= S zero) [Less=.definition]])
| (S m) => 
    let {Less := 
          (!chain-> 
	   [true ==> (zero < S m)             [Less.zero<S]
		 ==> (S zero < (S S m))       [Less.injective]]);
         disj := (!left-either Less (S zero = (S S m)))}
      (!chain-> 
       [disj ==> (S zero <= (S S m))   [Less=.definition]])
}

conclude injective   := (forall n m . S n <= S m <==> n <= m)
  pick-any n m
    (!chain 
     [(S n <= S m)
      <==> (S n < S m | S n = S m)  [Less=.definition]
      <==> (n < m | n = m)          [Less.injective S-injective]
      <==> (n <= m)                 [Less=.definition]])

conclude not-S       := (forall n . ~ S n <= n)
  pick-any n
    (!by-contradiction (~ S n <= n)
      assume hyp := (S n <= n) 
        let {disjunction := 
	       (!chain-> 
		[hyp ==> (S n < n | S n = n) [Less=.definition]])}
	(!cases disjunction
	  assume hyp1 := (S n < n) 
            let {not-hyp1 := (!chain-> [true ==> (~ hyp1) 
						[Less.S-not-<]])}
	    (!absurd hyp1 not-hyp1)
	  assume hyp2 := (S n = n) 
            let {not-hyp2 := (!chain-> 
		              [true ==> (~ hyp2) [S-not-same]])}
	    (!absurd hyp2 not-hyp2)))

conclude S-not-equal := (forall k n . S k <= n ==> k =/= n)
  pick-any k:N n
    assume hyp := (S k <= n) 
      let {P := (S n <= n)}
        (!by-contradiction (k =/= n)
	  assume (k = n)
	    (!absurd 
	     (!chain-> [hyp ==> P      [(k = n)]])
	     (!chain-> [true ==> (~ P) [Less=.not-S]])))

conclude discrete    := (forall m n . m < n ==> S m <= n)
  pick-any m n
    assume (m < n)
      (!by-contradiction (S m <= n)
        assume p := (~ S m <= n)
  	  let {in-between := (exists ?n . m < ?n & ?n < S m)}
	    (!absurd
	     (!chain-> 
	      [p ==> (~ (S m < n | S m = n))   [Less=.definition]
		 ==> (~ S m < n & S m =/= n)   [dm]
		 ==> (n < S m)                 [Less.trichotomy]
		 ==> (m < n & n < S m)         [augment]
		 ==> in-between                [existence]])
	     (!chain-> 
	      [true ==> (~ in-between)   [Less.discrete]])))

conclude transitive  := (forall x y z . x <= y & y <= z ==> x <= z)
  pick-any x:N y:N z
    assume (x <= y & y <= z) 
      let {disj1 := (!chain-> 
		     [(y <= z) ==> (y < z | y = z) [Less=.definition]])}
        conclude (x <= z)
          (!cases disj1
	    assume C := (y < z) 
	      let {disj2 := (!chain-> 
			     [(x <= y) 
			      ==> (x < y | x = y)  [Less=.definition]])}
	        conclude (x <= z) 
	          (!cases disj2
                    assume (x < y)
		      (!chain-> 
		       [(x < y) ==> (x < y & C)   [augment]
			        ==> (x < z)       [Less.transitive]
				==> (x <= z)      [Less=.Implied-by-<]])
	            assume (x = y)
		      (!chain-> [(y < z) 
				 ==> (x < z)   [(x = y)]
				 ==> (x <= z)  [Less=.Implied-by-<]]))
	    assume (y = z)
	      (!chain-> [(x <= y) ==> (x <= z) [(y = z)]]))

conclude transitive1 := (forall x y z . x < y & y <= z ==> x < z)
    pick-any x:N y:N z:N
    assume (x < y & y <= z) 
      (!by-contradiction (x < z)
       assume A := (~ x < z)
         (!absurd 
          (y <= z)
          conclude (~ y <= z)
	    (!chain->
	     [A ==> (z <= x)     [Less=.trichotomy2]
		==> (z <= x & x < y)       [augment]
		==> (z < y)      [Less=.transitive2]
		==> (~ y <= z)   [Less=.trichotomy3]])))

conclude transitive2 := (forall x y z . x <= y & y < z ==> x < z)
  pick-any x:N y:N z:N
    assume (x <= y & y < z) 
      conclude (x < z)
        let {D := (!chain->
		   [(x <= y) ==> (x < y | x = y) [Less=.definition]])}
        (!cases D
         assume (x < y)
           (!chain-> [(x < y & y < z) ==> (x < z) [Less.transitive]])
         assume (x = y)
	   (!chain-> [(y < z) ==> (x < z) [(x = y)]]))

conclude S1          := (forall n m . n <= m ==> n < S m)
  pick-any n:N m
    assume hyp := (n <= m) 
      let {disj := (!chain-> 
		    [hyp ==> (n < m | n = m) [Less=.definition]])}
        conclude (n < S m)
	  (!cases disj
	    assume p := (n < m)
	      (!chain-> 
	       [true ==> (m < S m)          [Less.<S]
		     ==> (p & m < S m)      [augment]
		     ==> (n < S m)          [Less.transitive]])
	    assume (n = m)
	      (!chain-> [true ==> (m < S m) [Less.<S]
			      ==> (n < S m) [(n = m)]]))
                  
conclude S2          := (forall n m . n <= m ==> n <= S m)
  pick-any n m
    (!chain [(n <= m) ==> (n < S m)     [Less=.S1]
	              ==> (n <= S m)    [Less=.Implied-by-<]])

conclude S3          := (forall n . n <= S n)
  pick-any n
    (!chain-> 
     [true ==> (n < S n)       [Less.<S]
	   ==> (n <= S n)      [Less=.Implied-by-<]])

conclude trichotomy2 := (forall m n . ~ n < m ==>  m <= n)
  pick-any m n
    (!contra-pos (!instance Less=.trichotomy1 [n m]))

conclude trichotomy3 := (forall m n . n < m ==> ~ m <= n)
  pick-any m:N n
    assume h1 := (n < m)
      (!by-contradiction (~ m <= n)
         assume h2 := (m <= n)
	   let {h3 := (!chain-> 
		       [h2 ==> (m < n | m = n) [Less=.definition]]);
                selfLess := 
                  conclude (n < n)
	            (!cases h3
		      assume h4 := (m < n)
		        (!chain-> [h1 ==> (h1 & h4)    [augment]
					 ==> (n < n)   [Less.transitive]])
		      assume (m = n)
		        (!chain-> [(n < m) ==> (n < n) [(m = n)]]));
                not-selfLess :=
	          (!chain-> 
		   [true ==> (~ n < n) [Less.irreflexive]])}
             (!absurd selfLess not-selfLess))

conclude trichotomy4 := (forall m n . n <= m ==> ~ m < n)
  pick-any m n
    (!contra-pos (!instance Less=.trichotomy3 [n m]))

conclude trichotomy5 := (forall m n . m <= n & n <= m ==> m = n)
pick-any m:N n
    assume (m <= n & n <= m)
      (!by-contradiction (m = n)
        assume (m =/= n) 
	  let {P1 := (!chain-> 
		      [(m <= n)
		       ==> (m < n | m = n) [Less=.definition]]);
	       P2 := (!chain-> 
		      [(n <= m)
		       ==> (n < m | n = m) [Less=.definition]])}
            (!cases P1
	      assume (m < n)
	        (!cases P2
                  (!chain 
		   [(n < m)
		    ==> (m < n & n < m)    [augment]
		    ==> (~ n < m & n < m)  [Less.asymmetric]
		    ==> false              [prop-taut]])
	        assume (n = m)
		  (!absurd (!sym (n = m)) (m =/= n)))
	      assume (m = n)
                (!absurd (m = n) (m =/= n))))

conclude Plus-cancellation := (forall k m n . m + k <= n + k ==> m <= n)
pick-any k m n
    assume p1 := (m + k <= n + k) 
      let {p2 := 
            (!chain-> [p1 ==> (m + k < n + k | m + k = n + k) 
			               [Less=.definition]])}
      conclude (m <= n)
	(!cases p2
          (!chain [(m + k < n + k)
		   ==> (m < n)      [Less.Plus-cancellation]
		   ==> (m <= n)     [Less=.Implied-by-<]])
	  (!chain [(m + k = n + k)
		   ==> (m = n)      [Plus.=-cancellation]
		   ==> (m <= n)     [Less=.Implied-by-equal]])) 

conclude Plus-k      := (forall k m n . m <= n ==> m + k <= n + k)
  pick-any k m n
    assume hyp1 := (m <= n) 
      let {goal := (m + k <= n + k)}
        (!by-contradiction goal
	  (!chain [(~ goal) ==> (n + k < m + k) [Less=.trichotomy1]
		   ==> (n < m)                  [Less.Plus-cancellation]
		   ==> (~ m <= n)               [Less=.trichotomy3]
		   ==> (hyp1 & ~ m <= n)        [augment]
		   ==> false                    [prop-taut]]))

conclude Plus-k1     := (forall k m n . m <= n ==> m <= n + k)
by-induction Less=.Plus-k1 {
  zero => 
    pick-any m n
      (!chain [(m <= n) ==> (m <= n + zero)  [Plus.right-zero]])
| (S k) =>
    let {IH := (forall ?m ?n . ?m <= ?n ==> ?m <= ?n + k)}
    pick-any m n 
      assume (m <= n)
        conclude (m <= n + (S k))
          (!chain-> 
	   [true ==> (k <= (S k))          [Less=.S3]
		 ==> (k + n <= (S k) + n)  [Less=.Plus-k]
		 ==> (n + k <= n + (S k))  [Plus.commutative]
		 ==> (m <= n & n + k <= n + (S k))  [augment]
		 ==> (m <= n + k & n + k <= n + (S k))   [IH]
		 ==> (m <= n + (S k))      [Less=.transitive]])
}

conclude k-Less=     := (forall k m n . n = m + k ==> m <= n)
by-induction Less=.k-Less= {
  zero =>
    conclude (forall ?m ?n . ?n = ?m + zero ==> ?m <= ?n)
      pick-any m n
        assume hyp := (n = m + zero)
	 (!chain-> 
	  [m = (m + zero)     [Plus.right-zero]
	     = n              [hyp]
	   ==> (m <= n)       [Less=.Implied-by-equal]])
| (S k) =>
   conclude (forall ?m ?n . ?n = ?m + (S k) ==> ?m <= ?n)
     pick-any m n
       let {ind-hyp := (forall ?m ?n . ?n = ?m + k ==> ?m <= ?n)}
         assume hyp :=  (n = m + (S k)) 
	   let {C := (!chain->
		      [n = (m + (S k))    [hyp]
			 = (S (m + k))    [Plus.right-nonzero]
			 = (S m + k)      [Plus.left-nonzero]
			 ==> (S m <= n)   [ind-hyp]])}
	    (!chain-> 
	     [true ==> (m <= S m)         [Less=.S3]
		   ==> ((m <= S m) & C)   [augment]
		   ==> (m <= n)           [Less=.transitive]])
}

conclude zero2       := (forall n . n <= zero ==> n = zero)
  pick-any n
    assume hyp := (n <= zero) 
      let {disj := (!chain-> 
		    [hyp ==> (n < zero | n = zero) [Less=.definition]])}
      (!cases disj
   	 assume (n < zero) 
           let {not-Less := (!chain-> 
			     [true ==> (~ n < zero) [Less.not-zero]])}
 	   (!from-complements (n = zero) (n < zero) not-Less)
         assume (n = zero)
	   (!claim (n = zero)))

conclude zero2       := (forall n . n <= zero ==> n = zero)
  pick-any n
    assume hyp := (n <= zero)
      (!dsyl (!chain-> 
	      [hyp ==> (n < zero | n = zero) [Less=.definition]])
	     (!chain-> 
	      [true ==> (~ n < zero)         [Less.not-zero]]))

conclude not-S-zero  := (forall n . ~ S n <= zero)
  pick-any n
    (!by-contradiction (~ S n <= zero)
      assume A := (S n <= zero)
        (!absurd
          (!chain->
	   [A ==> (S n = zero)  [Less=.zero2]])
	  (!chain->
	   [true ==> (S n =/= zero)  [S-not-zero]])))

conclude S4          := (forall m n . S m <= n ==> exists n' . n = S n')
  pick-any m n 
    assume A := (S m <= n)
      let {B := (!chain->
		 [A ==> (S m < n | S m = n) [Less=.definition]])}
	(!cases B
	 (!chain
	  [(S m < n) ==> (exists ?n' . n = (S ?n'))  [Less.S4]])
	 (!chain
	  [(S m = n) ==> (n = S m)  [sym]
	             ==> (exists ?n' . n = (S ?n')) [existence]]))

conclude S5          := (forall n m . n <= S m & n =/= S m ==> n <= m)
  pick-any n m
    let {A1 := (n <= S m);
         A2 := (n =/= S m)}
    assume (A1 & A2)
      let {B := (!chain-> 
		 [A1 ==> (n < S m | n = S m) [Less=.definition]])}
      (!cases B
        assume B1 := (n < S m)
          (!chain->
	   [B1 ==> (S n <= S m)  [Less=.discrete]
	       ==> (n <= m)      [Less=.injective]])
        assume B2 := (n = S m)
	  (!from-complements (n <= m) B2 A2))

conclude =zero       := (forall m . m < one ==> m = zero)
  pick-any m
    (!chain 
     [(m < one)
      ==> (~ one <= m)       [Less=.trichotomy3]
      ==> (~ S zero <= m)    [one-definition]
      ==> (~ zero < m)       [Less=.discrete]
      ==> (m = zero)         [Less.=zero]])

conclude zero<=one   := (forall m . m = zero ==> m <= one)
  pick-any m
    assume (m = zero)
      conclude (m <= one)
        (!chain->
	 [true ==> (zero <= one) [Less=.zero<=]
	       ==> (m <= one)    [m = zero]])

conclude =-cancellation := (forall y z x . zero < x & x * y = x * z ==> y = z)
by-induction =-cancellation {
  zero =>
    pick-any z x
      assume (zero < x & x * zero = x * z)
        conclude (zero = z)
          let {D := (!chain-> [(x * z) 
			     = (x * zero)    [(x * zero = x * z)]
			     = zero          [right-zero]
			     ==> (x = zero | z = zero) 
				             [no-zero-divisors]])}
            (!cases D
              assume (x = zero)
	        (!from-complements (zero = z)
                   (x = zero)
		   (!chain-> 
		    [(zero < x) ==> (x =/= zero) [Less.not-equal1]]))
              assume (z = zero)
                (!sym (z = zero)))
| (S y) =>
    let {ind-hyp := (forall ?z ?x . zero < ?x & ?x * y = ?x * ?z ==> y = ?z)}
      datatype-cases (forall ?z ?x . 
			zero < ?x & ?x * (S y) = ?x * ?z ==> (S y) = ?z)
      {
        zero =>
	  conclude (forall ?x . 
                      zero < ?x & ?x * (S y) = ?x * zero ==> (S y) = zero)
            pick-any x
              assume (zero < x & x * (S y) = x * zero)
                let {C1 := (!chain-> 
			    [(x * (S y)) 
			     = (x * zero) [(x * (S y) = x * zero)]
			     = zero       [right-zero]
			     ==> (x = zero | (S y) = zero)  
			     [no-zero-divisors]])}
                  (!cases C1
	            assume (x = zero)
		      (!from-complements ((S y) = zero)
                        (x = zero)
			(!chain-> 
			 [(zero < x) ==> (x =/= zero) [Less.not-equal1]]))
                    assume ((S y) = zero)
		      (!claim ((S y) = zero)))
      | (S z) =>
          conclude (forall ?x . zero < ?x & ?x * (S y) = ?x * (S z) 
			        ==> (S y) = (S z))
            pick-any x
              assume (zero < x & x * (S y) = x * (S z))
                (!chain-> 
		 [(x * y + x)
		  = (x * (S y))  [right-nonzero]
		  = (x * (S z))  [(x * (S y) = x * (S z))]
		  = (x * z + x)
		  ==> (x * y = x * z)  [Plus.=-cancellation]
		  ==> (zero < x & x * y = x * z) [augment]
		  ==> (y = z)                    [ind-hyp]
       		  ==> (S y = S z)                [S-injective]])
      }
}

conclude <-cancellation := (forall y z x . zero < x & x * y < x * z ==> y < z)       
by-induction <-cancellation {
  zero =>
    pick-any z x
      assume (zero < x & x * zero < x * z)
        (!by-contradiction (zero < z)
          assume A := (~ zero < z)
            let {_ := (!chain-> [A ==> (z = zero) [Less.=zero]])}
              (!absurd
	       (!chain->
		[(x * zero < x * z)
		 ==> (zero < zero)  [right-zero (z = zero)]])
	       (!chain->
		[true ==> (~ zero < zero) [Less.irreflexive]])))
| (S y) =>
    let {ind-hyp := (forall ?z ?x . zero < ?x & ?x * y < ?x * ?z ==> y < ?z)}
      datatype-cases (forall ?z ?x . zero < ?x & ?x * (S y) < ?x * ?z 
			            ==> (S y) < ?z)
      {
        zero =>
          pick-any x
            assume (zero < x  &  x * (S y) < x * zero)
              (!from-complements ((S y) < zero)
                (!chain-> [(x * (S y) < x * zero)
			    ==> (x * (S y) < zero)  [right-zero]])
		(!chain-> [true ==> (~ x * (S y) < zero) [Less.not-zero]]))
      | (S z) =>
          pick-any x
            assume (zero < x  &  x * (S y) < x * (S z))
              conclude ((S y) < (S z))
                (!chain->
		 [(x * (S y) < x * (S z))
		  ==> (x * y + x < x * z + x) [right-nonzero]
		  ==> (x * y < x * z)         [Less.Plus-cancellation]
		  ==> (y < z)                 [(zero < x) ind-hyp]
		  ==> ((S y) < (S z))         [Less.injective]])
      }
}

conclude <-cancellation-conv := (forall x y z . zero < x & y < z ==> x * y < x * z)
  pick-any x y z
    assume A1 := (zero < x & y < z)
      let {goal := (x * y < x * z)}
        (!by-contradiction goal
          assume (~ goal)
            let {D := (!chain->
		       [(~ goal) 
			==> (x * z <= x * y)   [Less=.trichotomy2]
			==> (x * z < x * y | x * z = x * y)  
			                       [Less=.definition]])}
              (!cases D
                assume A2 := (x * z < x * y)
                  (!chain->
		   [A2 ==> (z < y)             [<-cancellation]
		       ==> (~ y < z)           [Less.asymmetric]
		       ==> (y < z & ~ y < z)   [augment]
		       ==> false               [prop-taut]])
                assume A3 := (x * z = x * y)
                  (!absurd
		   (!chain->
		    [(zero < x & A3) ==> (z = y) [=-cancellation]])
		   (!chain-> [(y < z)
			  ==> (~ z = y)   [Less.not-equal1]]))))

conclude <=-cancellation-conv := (forall x y z . y <= z ==> x * y <= x * z)                  
  pick-any x y z
    assume A := (y <= z)
      let {goal := (x * y <= x * z)}
        (!two-cases 
          assume A1 := (zero < x)
            (!by-contradiction goal
              assume (~ goal)
                (!chain-> 
		 [(~ goal) 
		  ==> (x * z < x * y)  [Less=.trichotomy1]
		  ==> (z < y)          [A1 <-cancellation]
		  ==> (~ y <= z)       [Less=.trichotomy4]
		  ==> (A & ~ A)        [augment]
		  ==> false            [prop-taut]]))
          assume A2 := (~ zero < x)
            let {C := (!chain->
		       [true ==> (~ x < zero)      [Less.not-zero]
			     ==> (~ x < zero & A2) [augment]
			     ==> (x = zero)        [Less.trichotomy1]])}
              (!chain<- [goal <== (zero * y <= zero * z)   [C]
			      <== (zero <= zero)  [left-zero]
			      <== true            [Less=.reflexive]]))

conclude identity-lemma1 := (forall x y . zero < x & x * y = x ==> y = one)
pick-any x y
    assume (zero < x & x * y = x)
      (!chain->
       [(x * y = x)
        ==> (x * y = x * one)   [right-one]
	==> (y = one)           [(zero < x) =-cancellation]]) 

conclude identity-lemma2 := (forall x y . x * y = one ==> x = one)
pick-any x y
    assume A := (x * y = one)
      let {C1 := (!by-contradiction (x =/= zero)
                   assume (x = zero)
                     (!absurd
		      (!chain->
		       [true ==> (zero * y = zero) [left-zero]
			     ==> (x * y = zero)    [(x = zero)]
			     ==> (one = zero)      [A]])
		      (!chain->
		       [true ==> (one =/= zero)    [one-not-zero]])));
	   C2 := (!by-contradiction (y =/= zero)
                   assume (y = zero)
                     (!absurd
		      (!chain->
		       [true ==> (x * zero = zero) [right-zero]
			     ==> (x * y = zero)    [(y = zero)]
			     ==> (one = zero)      [A]])
		      (!chain->
		       [true ==> (one =/= zero)    [one-not-zero]])));
           C3 := (!by-contradiction (~ one < x)
                   assume (one < x)
                     let {_ := (!chain->
				[C2 ==> (zero < y)  [Less.zero<]])}
                       (!absurd
			(!chain->
			 [(one < x)
		      ==> (zero < y & one < x)      [augment]
		      ==> (y * one < y * x) [<-cancellation-conv]
		      ==> (one * y < x * y) [commutative]
		      ==> (one * y < one)   [A]
		      ==> (y < (S zero))    [left-one one-definition]
		      ==> (y < (S zero) & y =/= zero) [augment]
		      ==> (y < zero)        [Less.S-step]])
			(!chain->
			 [true ==> (~ y < zero) [Less.not-zero]])));
           C4 := (!chain-> 
		  [C3 ==> (~ (S zero) < x)  [one-definition]
		      ==> (x <= (S zero))   [Less=.trichotomy2]
		      ==> (x < (S zero) | x = (S zero))  [Less=.definition]])}
         (!by-contradiction (x = one)
           assume A := (x =/= one)
             (!absurd
	      (!chain-> 
	       [A ==> (C4 & A)               [augment]
		  ==> (C4 & x =/= (S zero))  [one-definition]
		  ==> (x < (S zero))         [prop-taut]
		  ==> (x =/= zero & x < (S zero))  [augment]
		  ==> (x < zero)             [Less.S-step]])
	      (!chain->
	       [true ==> (~ x < zero)        [Less.not-zero]])))

conclude squeeze := (forall x y . x * y < x ==> y = zero)
  pick-any x:N y:N
    assume (x * y < x)
      (!by-contradiction (y = zero)
       assume (y =/= zero)
         let {subgoal := (~ x * y < x);
	      B := datatype-cases subgoal on y {
                     zero => (!from-complements (~ x * zero < x)
                              (!reflex zero)
                              (!chain-> 
			       [(y =/= zero) 
				==> (zero =/= zero) [(y = zero)]]))
                   | (S y) => 
		       (!chain-> 
			[true 
		     ==> (~ x * y < zero)     [Less.not-zero]
		     ==> (~ x * y + x < zero + x) [Less.Plus-k-equiv]
		     ==> (~ x * y + x < x)    [Plus.left-zero]
		     ==> (~ x * (S y) < x)    [Times.right-nonzero]])
                   }}
          (!absurd (x * y < x) subgoal))

conclude commutative :=  (forall ?x ?y . (Max ?x ?y) = (Max ?y ?x))
  pick-any x:N y
    conclude ((Max x y) = (Max y x))	    
      (!two-cases
        assume (y < x) 
          let {_ := 
	       (!chain-> [(y < x) ==> (~ (x < y)) [Less.asymmetric]])}
	  (!chain [(Max x y)
		   --> x                     [less2]
		   <-- (Max y x)             [not-less2]])
        assume (~ y < x)
	  (!two-cases
	    assume (x = y)
	      (!chain [(Max x y)
		       --> (Max y y)   [(x = y)]
		       <-- (Max y x)   [(x = y)]])
	    assume (x =/= y) 
	      let {_ := 
                   (!chain->
	            [(x =/= y)
		 ==> (y =/= x)               [sym]
		 ==> (~ y < x & y =/= x    ) [augment]
		 ==> (x < y)                 [Less.trichotomy]])}
	      (!chain [(Max x y)
		       --> y               [not-less2]
		       <-- (Max y x)       [less2]])))

conclude associative := (forall ?x ?y ?z . (Max (Max ?x ?y) ?z) = (Max ?x (Max ?y ?z)))
pick-any x:N y:N z:N
    (!two-cases
      assume (y < x)
        (!two-cases 
	  assume (z < x) 
            let {e1 := (!chain [(Max (Max x y) z)
			    --> (Max x z)       [less2]
			    --> x               [less2]]);
                 e2 := conclude ((Max x (Max y z)) = x)
	                (!two-cases
	                 assume (z < y)
			   (!chain [(Max x (Max y z))
				--> (Max x y)   [less2]
				--> x           [less2]])
	                 assume (~ z < y)
	                   (!chain [(Max x (Max y z))
			        --> (Max x z)    [not-less2]
			        --> x            [less2]]))}
            (!combine-equations e1 e2)
	  assume (~ z < x) 
	    let {e3 := (!chain [(Max (Max x y) z)
			    --> (Max x z)       [less2]
			    --> z               [not-less2]]);
                 _ := (!chain-> 
		       [(~ z < x)
	            ==> (y < x & ~ z < x)        [augment]
	            ==> (y < z)                  [Less.transitive1]]);
                 e4 := conclude ((Max x (Max y z)) = z)
	                 (!chain [(Max x (Max y z))
		              --> (Max x (Max z y)) [commutative]
		              --> (Max x z)         [less2]
		              --> z                 [not-less2]])}
            (!combine-equations e3 e4))
     assume (~ (y < x))
       (!two-cases
	 assume (y < z) 
           let {e5 := (!chain [(Max (Max x y) z)
			   --> (Max y z)      [not-less2]
			   --> (Max z y)      [commutative]
			   --> z              [less2]]);
                _ := (!chain-> 
		      [(y < z)
		   ==> (~ y < x & y < z)      [augment]
		   ==> (x < z)                [Less.transitive3]]);
                e6 := conclude ((Max x (Max y z)) = z)
	                (!chain 
			 [(Max x (Max y z))
		      --> (Max x (Max z y))   [commutative]
		      --> (Max x z)           [less2]
		      --> (Max z x)           [commutative]
		      --> z                   [less2]])}
           (!combine-equations e5 e6)
	 assume (~ y < z)
	   (!two-cases
	     assume (z < x)
	       (!combine-equations
		(!chain [(Max (Max x y) z)
			 --> (Max y z)         [not-less2]
			 --> (Max z y)         [commutative]
			 --> y                 [not-less2]])
		(!chain [(Max x (Max y z))
			 --> (Max x (Max z y)) [commutative]
			 --> (Max x y)         [not-less2]
			 --> y                 [not-less2]]))
	     assume (~ z < x)
	       (!combine-equations
		(!chain [(Max (Max x y) z)
			 --> (Max y z)         [not-less2]
			 --> (Max z y)         [commutative]
			 --> y                 [not-less2]])
		(!chain [(Max x (Max y z))
			 --> (Max x (Max z y)) [commutative]
			 --> (Max x y)         [not-less2]
			 --> y                 [not-less2]])))))

conclude idempotent := (forall ?x . (Max ?x ?x) = ?x)
  pick-any x
    (!chain-> [true ==> (~ (x < x))     [Less.irreflexive]
		    ==> ((Max x x) = x) [not-less2]])

conclude Plus-Cancel := (forall y x . y <= x ==> x = (x - y) + y)
by-induction Plus-Cancel {
  zero =>
    conclude (forall ?x . zero <= ?x ==> ?x = (?x - zero) + zero)
      pick-any x
        assume (zero <= x)
	  (!sym (!chain [((x - zero) + zero)
			 = (x + zero)        [zero-right]
			 = x                 [Plus.right-zero]]))
| (S y) =>
   let {ind-hyp := (forall ?x . y <= ?x ==> ?x = (?x - y) + y)}
   datatype-cases 
      (forall ?x . S y <= ?x ==> ?x = (?x - S y) + S y) {
     zero =>
       conclude
          (S y <= zero ==> (zero = (zero - S y) + S y))
         assume A := (S y <= zero)
           (!from-complements (zero = (zero - S y) + S y)
	    A
	    (!chain-> [true ==> (~ A)  [Less=.not-S-zero]]))
   | (S x) =>
      conclude
         (S y <= S x ==> (S x = (S x - S y) + S y))
        assume A := (S y <= S x)
          let {C := (!chain-> [A ==> (y <= x) [Less=.injective]])}
	  (!sym (!chain 
		 [((S x - S y) + S y)
		  = ((x - y) + S y)       [both-nonzero]
		  = (S ((x - y) + y))     [Plus.right-nonzero]
		  = (S x)                 [C ind-hyp]]))
   }
}

conclude second-equal := (forall x . x - x = zero)
by-induction second-equal {
  zero => (!chain [(zero - zero) = zero   [zero-left]])
| (S x) => 
    let {ind-hyp := (x - x = zero)}
      (!chain [(S x - S x) = (x - x)   [both-nonzero]
	                   = zero      [ind-hyp]])
}

conclude second-equal := (forall x . x - x = zero)
  pick-any x:N
    (!chain-> [true
	       ==> (x <= x)                 [Less=.reflexive]
	       ==> (x = (x - x) + x)        [Plus-Cancel]
	       ==> (zero + x = (x - x) + x) [Plus.left-zero]
	       ==> (zero = x - x)           [Plus.=-cancellation]
	       ==> (x - x = zero)           [sym]]

conclude second-greater := (forall x y . x < y ==> x - y = zero)
by-induction second-greater {
  zero =>
    conclude (forall ?y . zero < ?y ==> zero - ?y = zero)
      pick-any y
        assume (zero < y)
          (!chain [(zero - y) = zero [zero-left]])
| (S x) =>
  let {ind-hyp := (forall ?y . x < ?y ==> x - ?y = zero)}
  datatype-cases (forall ?y . S x < ?y ==> S x - ?y = zero)
  {  
    zero =>
      assume A := (S x < zero)
        (!from-complements (S x - zero = zero)
         A
         (!chain-> [true ==> (~ A) [Less.not-zero]]))
  | (S y) =>
      assume A := (S x < S y)
        let {C := (!chain-> [A ==> (x < y)  [Less.injective]])}
        (!chain [(S x - S y)
                 = (x - y)        [both-nonzero]
		 = zero           [C ind-hyp]])
  }
}

conclude second-greater-or-equal := (forall x y . x <= y ==> x - y = zero)
  pick-any x:N y
    assume A := (x <= y)
      let {C := (!chain-> [A ==> (x < y | x = y) [Less=.definition]])}
      (!cases C
       (!chain [(x < y) ==> (x - y = zero)  [second-greater]])
       assume (x = y)
         (!chain [(x - y) = (x - x)   [(x = y)]
	                  = zero      [second-equal]]))

conclude alt-<=-characterization := (forall x y . x <= y <==> exists z . y = x + z)
  pick-any x y
    (!equiv
     (!chain [(x <= y)
	      ==> (y = (y - x) + x)         [Plus-Cancel]
	      ==> (y = x + (y - x))         [Plus.commutative]
	      ==> (exists ?z . y = x + ?z)  [existence]])
     assume A := (exists ?z . y = x + ?z)
       pick-witness z for A witnessed
	 (!chain-> [witnessed ==> (x <= y)  [Less=.k-Less=]]))

conclude <-left := (forall x y . zero < y  & y <= x ==> x - y < x)
  pick-any x y
    assume A := (zero < y & y <= x)
      let {goal := ((x - y) < x)}
      (!by-contradiction goal
       assume (~ goal)
         (!absurd
	  (!chain-> [(zero < y)
		     ==> (zero + x < y + x)     [Less.Plus-k]
		     ==> (x < y + x)            [Plus.left-zero]])
	  (!chain-> [(~ goal)                 
		     ==> (x <= x - y)           [Less=.trichotomy1]
		     ==> (x + y <= (x - y) + y) [Less=.Plus-k]
		     ==> (x + y <= x)   [(y <= x) Plus-Cancel]
		     ==> (~ x < x + y)  [Less=.trichotomy4]
		     ==> (~ x < y + x)  [Plus.commutative]])))
 
conclude Plus-Minus-property := (forall x y z . x = y + z ==> x - y = z)
  pick-any x y z
    assume A := (x = y + z)
      let {C1 := 
           (!chain->
	    [A ==> (y <= x)           [Less=.k-Less=]
	       ==> (x = (x - y) + y)  [Plus-Cancel]]);
            C2 := (!chain-> [A ==> (x = z + y)    [Plus.commutative]])}
      (!chain-> 
       [((x - y) + y) = x        [C1]
	              = (z + y)  [C2]
	              ==> ((x - y) = z)  [Plus.=-cancellation]])

conclude Plus-Minus-property-1 := (forall x y z . x = y + z ==> x - z = y)
pick-any x:N y:N z:N
 (!chain [(x = y + z) 
      ==> (x = z + y)   [Plus.commutative]
      ==> (x - z = y)   [Plus-Minus-property]])

conclude Plus-Minus-property-2 := (forall x y z . x + y = z ==> x = z - y)
pick-any x:N y:N z:N
 (!chain [(x + y = z)
      ==> (z = x + y)  [sym]
      ==> (z - y = x)  [Plus-Minus-property-1]
      ==> (x = z - y)  [sym]])

conclude Plus-Minus-property-3 := (forall x y z . x + y = z ==> y = z - x)
pick-any x:N y:N z:N
 (!chain [(x + y = z)
      ==> (z = x + y)  [sym]
      ==> (z - x = y)  [Plus-Minus-property]
      ==> (y = z - x)  [sym]])

conclude cancellation :=  (forall x y . (x + y) - x = y)
  pick-any x y
    (!chain->
     [(x + y = x + y)  ==> ((x + y) - x = y) [Plus-Minus-property]])

conclude comparison := (forall x y z . z < y & y <= x ==> x - y < x - z)
  pick-any x y z
    let {A1 := (z < y);
         A2 := (y <= x)}
    assume (A1 & A2)
      let {u := (x - y);
           v := (x - z);
           B1 := (!chain->
		  [A2 ==> (x = u + y)  [Plus-Cancel]]);
           B2 := (!chain->
		  [(A1 & A2) 
		   ==> (z < x)         [Less=.transitive1]
		   ==> (z <= x)        [Less=.Implied-by-<]
		   ==> (x = v + z)     [Plus-Cancel]
		   ==> (x = z + v)     [Plus.commutative]
		   ==> (u + y = z + v) [B1]])}
      (!by-contradiction (u < v)
       assume (~ u < v)
	  let {C1 := (!chain-> 
		      [(~ u < v) ==> (v <= u)  [Less=.trichotomy2]]);
	       C2 := (!chain->
		      [(z < y) ==> (z + v < y + v) [Less.Plus-k]
			       ==> (z + v < v + y) [Plus.commutative]]);
	       C3 := (!chain->
		      [(v <= u)
			==> (v + y <= u + y)   [Less=.Plus-k]
			==> (z + v < v + y & v + y <= u + y) [augment]
			==> (z + v < u + y)    [Less=.transitive1]
			==> (u + y =/= z + v)  [Less.not-equal1]])}
	  (!absurd B2 C3))

conclude Times-Distributivity := (forall x y z . x * y - x * z = x * (y - z))
  pick-any x y z
    (!two-cases
      assume A := (z <= y)
        (!chain->
          [(x * y)
	   = (x * ((y - z) + z))   [Plus-Cancel]
	   = (x * (y - z) + x * z) [Times.left-distributive]
	   = (x * z + x * (y - z)) [Plus.commutative]
	   ==> (x * y - x * z = x * (y - z))  
	                           [Plus-Minus-property]])
      assume A := (~ z <= y)
        let {C := (!chain-> [A ==> (y < z)  [Less=.trichotomy1]])}
          (!combine-equations
	   (!chain->
	    [C ==> (C | y = z)       [alternate]
	       ==> (y <= z)          [Less=.definition]
	       ==> (x * y <= x * z)  [Times.<=-cancellation-conv]
	       ==> (x * y - x * z = zero) 
	                             [second-greater-or-equal]])
	   (!chain
	    [(x * (y - z))
	     = (x * zero)       [second-greater]
	     = zero             [Times.right-zero]])))

conclude S-not-zero     := (forall n . (S n) =/= zero)
pick-any n 
    (!sym (!instance (first (datatype-axioms "N")) n))

conclude S-not-zero     := (forall n . (S n) =/= zero)
  pick-any n 
    (!chain->
     [true ==> (zero =/= (S n)) [(datatype-axioms "N")]
	   ==> ((S n) =/= zero) [sym]])

conclude one-not-zero   := (one =/= zero)
(!by-contradiction one-not-zero
   assume (one = zero) 
     let {is := conclude ((S zero) = zero)
                  (!chain
		   [(S zero)
		    <-- one          [one-definition]
		    --> zero         [(one = zero)]]);
          is-not := (!chain-> [true ==> ((S zero) =/= zero)
			  	           [S-not-zero]])}
       (!absurd is is-not))

conclude S-injective      := (forall m n . (S m) = (S n) <==> m = n)
  pick-any m:N n:N 
    let {right := (!chain [((S m) = (S n)) ==> (m = n)
			   [(second (datatype-axioms "N"))]]);
         left := assume (m = n)
                   (!chain [(S m) --> (S n) [(m = n)]])}
      (!equiv right left)

conclude nonzero-S := (forall n . n =/= zero ==> (exists m . n = (S m)))
by-induction nonzero-S {
  zero => assume (zero =/= zero)
           (!from-complements (exists ?m (zero = (S ?m)))
                              (!reflex zero)
                              (zero =/= zero))
| (S m) => assume ((S m) =/= zero) 
    let {_ := (!reflex (S m))}
      (!egen (exists ?m . (S m) = (S ?m)) m)
}

conclude S-not-same := (forall n . (S n) =/= n)
by-induction S-not-same {
  zero => conclude ((S zero) =/= zero)
            (!instance S-not-zero zero)
| (S n) => 
  let {induction-hypothesis := ((S n) =/= n)}
    (!chain-> [induction-hypothesis
	   ==> ((S (S n)) =/= (S n)) [S-injective]])
}

conclude left-zero    := (forall n . zero + n = n)
by-induction left-zero {
  zero => conclude (zero + zero = zero)
            (!chain [(zero + zero) --> zero [right-zero]])
| (S n) => conclude (zero + (S n) = (S n)) 
             let {induction-hypothesis := (zero + n = n)}
             (!chain [(zero + (S n))
		      --> (S (zero + n)) [right-nonzero]
		      --> (S n)          [induction-hypothesis]])
}

conclude left-nonzero := (forall n m . (S m) + n = (S (m + n)))
by-induction left-nonzero {
  zero =>
  pick-any m
    (!chain [((S m) + zero)
             --> (S m)           [right-zero]
             <-- (S (m + zero))  [right-zero]])
| (S n) => 
  let {induction-hypothesis := (forall ?m . (S ?m) + n = (S (?m + n)))}
  pick-any m
    (!chain [((S m) + (S n))
	     --> (S ((S m) + n)) [right-nonzero]
	     --> (S (S (m + n))) [induction-hypothesis]
	     <-- (S (m + (S n))) [right-nonzero]])
}

conclude right-one := (forall n . n + one = (S n))
  pick-any n
    (!chain [(n + one)
             --> (n + (S zero))   [one-definition]
             --> (S (n + zero))   [right-nonzero]
             --> (S n)            [right-zero]])

conclude left-one  := (forall n . one + n = (S n))
  pick-any n
    (!chain [(one + n)
             --> ((S zero) + n)   [one-definition]
             --> (S (zero + n))   [left-nonzero]
             --> (S n)            [left-zero]])

conclude associative := (forall m p n . (m + p) + n = m + (p + n))
by-induction associative {
  zero =>
    pick-any p n
      (!chain [((zero + p) + n)
               --> (p + n)          [left-zero]
               <-- (zero + (p + n)) [left-zero]])
| (S m) => 
    let {induction-hypothesis :=
           (forall ?p ?n . (m + ?p) + ?n = m + (?p + ?n))}
      pick-any p n
        (!chain
	 [(((S m) + p) + n)
	  --> ((S (m + p)) + n) [left-nonzero]
	  --> (S ((m + p) + n)) [left-nonzero]
	  --> (S (m + (p + n))) [induction-hypothesis]
	  <-- ((S m) + (p + n)) [left-nonzero]])
}

conclude commutative := (forall n m . m + n = n + m)
by-induction commutative {
  zero =>
    pick-any m
      (!chain [(m + zero)
               --> m             [right-zero]
               <-- (zero + m)    [left-zero]])
| (S n) =>
    pick-any m 
      let {induction-hypothesis := (forall ?m . ?m + n = n + ?m)}
      (!chain [(m + (S n))
	       --> (S (m + n)) [right-nonzero]
	       --> (S (n + m)) [induction-hypothesis]
	       <-- ((S n) + m) [left-nonzero]])
}

conclude =-cancellation := (forall k m n . m + k = n + k ==> m = n)
by-induction =-cancellation {
  zero =>
    pick-any m n
      assume assumption := (m + zero = n + zero)
        (!chain [m <-- (m + zero) [right-zero]
		   --> (n + zero) [assumption]
		   --> n          [right-zero]])
| (S k) => 
    let {induction-hypothesis :=
           (forall ?m ?n . ?m + k = ?n + k ==> ?m = ?n)}
    pick-any m n
      assume assumption := (m + S k = n + S k)
        (!chain->
	 [(S (m + k))
	  <-- (m + S k)            [right-nonzero]
	  --> (n + S k)            [assumption]
	  --> (S (n + k))          [right-nonzero]
	  ==> (m + k = n + k)      [S-injective]
	  ==> (m = n)              [induction-hypothesis]])
}

conclude squeeze-property := (forall m n . m + n = zero ==> m = zero)
  pick-any m n
    assume A := (m + n = zero)
      (!by-contradiction (m = zero)
         assume (m =/= zero) 
           let {C := (!chain->
		      [(m =/= zero)
		       ==> (exists ?k . m = (S ?k)) [nonzero-S]])}
           pick-witness k for C witnessed 
             let {is := conclude ((S (k + n)) = zero)
                          (!chain [(S (k + n))
				   <-- ((S k) + n)  [left-nonzero]
				   <-- (m + n)      [witnessed]
				   --> zero         [A]]);
                  is-not := (!chain-> [true ==> ((S (k + n)) =/= zero)
					            [S-not-zero]])}
             (!absurd is is-not))

conclude Plus-case := (forall m n x . x ** (m + n) = x ** m * x ** n)
by-induction Plus-case {
  zero =>
    conclude (forall n x . x ** (zero + n) = x ** zero * x ** n)
      pick-any n x
	(!chain 
	 [(x ** (zero + n))
      --> (x ** n)              [Plus.left-zero]
      <-- (one * x ** n)        [Times.left-one]
      <-- (x ** zero * x ** n)  [if-zero]])
| (m as (S m')) => 
  let {ind-hyp := (forall n x . x ** (m' + n) = x ** m' * x ** n)}
    conclude (forall n x . x ** (m + n) = x ** m * x ** n)
      pick-any n x
        (!combine-equations
          (!chain [(x ** ((S m') + n))
   	       --> (x ** (S (m' + n)))        [Plus.left-nonzero]
	       --> (x * x ** (m' + n))        [if-nonzero]
	       --> (x * (x ** m' * x ** n))   [ind-hyp]])
       (!chain [(x ** (S m') * x ** n)
  	    --> ((x * (x ** m')) * x ** n)    [if-nonzero]
	    --> (x * (x ** m' * x ** n))      [Times.associative]]))
}

conclude left-one := (forall n . one ** n = one)
by-induction left-one {
  zero => (!chain [(one ** zero) --> one  [if-zero]])
| (S n) => 
  let {induction-hypothesis := (one ** n = one)}
  (!chain [(one ** (S n))
	   --> (one * (one ** n)) [if-nonzero]
	   --> (one ** n)         [Times.left-one]
	   --> one                [induction-hypothesis]])
}

conclude right-one := (forall x . x ** one = x)
  pick-any x:N
    (!chain [(x ** one)
	     --> (x ** (S zero))    [one-definition]
	     --> (x * x ** zero)    [if-nonzero]
	     --> (x * one)          [if-zero]
	     --> x                  [Times.right-one]])

conclude left-zero    := (forall x . zero * x = zero)
by-induction left-zero {
  zero =>
   (!chain [(zero * zero) = zero  [right-zero]])
| (S x) => 
  let {induction-hypothesis := (zero * x = zero)}
  (!chain [(zero * (S x))
           = (zero * x + zero)    [right-nonzero]
           = (zero + zero)        [induction-hypothesis]
           = zero                 [Plus.right-zero]])
}

conclude left-nonzero := (forall x y . (S y) * x = x + y * x)
by-induction left-nonzero {
  zero =>
    pick-any y
      (!combine-equations
       (!chain [((S y) * zero) = zero  [right-zero]])
       (!chain [(zero + y * zero)
             = (zero + zero)     [right-zero]
             = zero              [Plus.right-zero]]))
| (S x) =>
    pick-any y
      let {induction-hypothesis := (forall ?y . (S ?y) * x = x + ?y * x)}
      (!combine-equations
       (!chain 
	[((S y) * (S x))
	 --> ((S y) * x + (S y))   [right-nonzero]
	 --> ((x + y * x) + (S y)) [induction-hypothesis]
	 --> (S ((x + y * x) + y)) [Plus.right-nonzero]
	 --> (S (x + (y * x + y))) [Plus.associative]])
       (!chain 
	[((S x) + y * (S x))
	 --> ((S x) + (y * x + y)) [right-nonzero]
	 --> (S (x + (y * x + y))) [Plus.left-nonzero]]))
}

conclude right-one := (forall x . x * one = x)
pick-any x
    (!chain [(x * one)
             --> (x * (S zero))   [one-definition]
             --> (x * zero + x)   [right-nonzero]
             --> (zero + x)       [right-zero]
             --> x                [Plus.left-zero]])

conclude left-one  :=  (forall x . one * x = x)
  pick-any x
    (!chain [(one * x)
             --> ((S zero) * x)    [one-definition]
             --> (x + zero * x)    [left-nonzero]
             --> (x + zero)        [left-zero]
             --> x                 [Plus.right-zero]])

conclude right-distributive := (forall x y z . (x + y) * z = x * z + y * z)
by-induction right-distributive {
  zero =>
    pick-any y z
      (!combine-equations
       (!chain [((zero + y) * z) = (y * z)   [Plus.left-zero]])
       (!chain [(zero * z + y * z)
                --> (zero + y * z)           [left-zero]
                --> (y * z)                  [Plus.left-zero]]))
| (S x) => 
    let {induction-hypothesis :=
           (forall ?y ?z . (x + ?y) * ?z = x * ?z + ?y * ?z)}
    pick-any y z
    (!combine-equations
     (!chain 
      [(((S x) + y) * z)
       --> ((S (x + y)) * z)             [Plus.left-nonzero]
       --> (z + ((x + y) * z))           [left-nonzero]
       --> (z + (x * z + y * z))         [induction-hypothesis]])
     (!chain 
      [((S x) * z + y * z)
       --> ((z + x * z) + y * z)   [left-nonzero]
       --> (z + (x * z + y * z))   [Plus.associative]]))
}

conclude left-distributive := (forall z x y . z * (x + y) = z * x + z * y)
  pick-any z x y
    (!chain [(z * (x + y))
             --> ((x + y) * z)      [commutative]
             --> (x * z + y * z)    [right-distributive]
             --> (z * x + z * y)    [commutative]])

conclude associative := (forall x y z . (x * y) * z = x * (y * z))
by-induction associative {
  zero =>
    pick-any y z
      (!chain [((zero * y) * z)
               --> (zero * z)       [left-zero]
               --> zero             [left-zero]
               <-- (zero * (y * z)) [left-zero]])
| (S x) => 
  let {induction-hypothesis :=
          (forall ?y ?z . (x * ?y) * ?z = x * (?y * ?z))}
  pick-any y z
    (!chain 
     [(((S x) * y) * z)
      --> ((y + (x * y)) * z)     [left-nonzero]
      --> (y * z + (x * y) * z)   [right-distributive]
      --> (y * z + (x * (y * z))) [induction-hypothesis]
      <-- ((S x) * (y * z))       [left-nonzero]])
}

conclude commutative := (forall x y . x * y = y * x)
by-induction commutative {
  zero =>
    conclude (forall ?y . zero * ?y = ?y * zero)
      pick-any y
        (!chain [(zero * y)
                 --> zero        [left-zero]
                 <-- (y * zero)  [right-zero]])
| (S x) => 
    let {induction-hypothesis := (forall ?y . (x * ?y = ?y * x))}
    conclude (forall ?y . (S x) * ?y = ?y * (S x))
      pick-any y
        (!combine-equations
	  (!chain [((S x) * y)
		   --> (y + x * y)  [left-nonzero]
		   --> (y + y * x)  [induction-hypothesis]])
	  (!chain [(y * (S x))
		   --> (y * x + y)  [right-nonzero]
		   --> (y + y * x)  [Plus.commutative]]))
}

conclude no-zero-divisors := (forall x y . x * y = zero ==> x = zero | y = zero) 
  pick-any x y
    assume (x * y = zero)
      (!two-cases
        assume (x = zero)
          (!left-either (x = zero) (y = zero))
        assume A1 := (x =/= zero) 
          let {C1 := (!chain-> 
		      [A1 ==> (exists ?u . x = (S ?u)) 
			                  [nonzero-S]])}
           pick-witness u for C1 
	    let {C3 :=
             (!by-contradiction (y = zero)
              assume A2 := (y =/= zero) 
                let {C2 := (!chain-> 
			    [A2 ==> (exists ?v . y = (S ?v))
			              [nonzero-S]])}
                  pick-witness v for C2
                    let {equal := (zero = (S ((S u) * v + u)))}
                      (!absurd
                        conclude equal
		          (!chain 
			   [zero 
			    <-- (x * y)             [(x * y = zero)]
			    --> ((S u) * (S v))     [(x = (S u)) (y = (S v))]
			    --> ((S u) * v + (S u)) [right-nonzero]
			    --> (S ((S u) * v + u)) [Plus.right-nonzero]])
			conclude (~ equal)
			  (!chain-> 
			   [true ==> ((S ((S u) * v + u)) =/= zero)
				                [S-not-zero]
			         ==> (~ equal)  [sym]])))}
               (!right-either (x = zero) C3))

conclude no-zero-divisors := (forall x y . x * y = zero ==> x = zero | y = zero)
datatype-cases no-zero-divisors {
  zero =>
    conclude (forall ?y . zero * ?y = zero ==> zero = zero | ?y = zero)
      pick-any y
        assume (zero * y = zero)
          (!left-either (!reflex zero) (y = zero))
| (S x) =>
  datatype-cases (forall ?y . (S x) * ?y = zero ==> (S x) = zero | ?y = zero)
  {
    zero =>
      conclude ((S x) * zero = zero ==> (S x) = zero | zero = zero)
        assume ((S x) * zero = zero)
          (!right-either ((S x) = zero) (!reflex zero))
  | (S y) =>
      conclude ((S x) * (S y) = zero ==> (S x) = zero | (S y) = zero)
        assume is-zero := ((S x) * (S y) = zero)
          let {C := 
                conclude ((S x) * (S y) = (S ((S x) * y + x)))
		  (!chain [((S x) * (S y))
			   --> ((S x) * y + (S x)) [right-nonzero]
			   --> (S ((S x) * y + x)) [Plus.right-nonzero]]);
               is-not :=
	         (!chain-> 
		  [true ==> ((S ((S x) * y + x)) =/= zero)[S-not-zero]
			==> ((S x) * (S y) =/= zero)      [C]])}
          (!from-complements ((S x) = zero | (S y) = zero) is-zero is-not)
  }
}

conclude two-times := (forall x . two * x = x + x)
  pick-any x
    (!chain [(two * x)
             --> ((S one) * x)   [two-definition]
             --> (x + one * x)   [left-nonzero]
             --> (x + x)         [left-one]])

conclude zero-property := (forall x . square x = zero ==> x = zero) 
  pick-any x
    assume A := ((square x) = zero)
      conclude (x = zero)
        (!chain-> [(x * x) 
                   <-- (square x)    [def]
                   --> zero          [A]
           ==> (x = zero | x = zero) [Times.no-zero-divisors]
           ==> (x = zero)            [prop-taut]]) 

conclude left-transitive := (forall L x y . x <= y & y <=L L ==> x <=L L)
datatype-cases left-transitive {
  nil =>
  pick-any x y
    assume (x <= y & y <=L nil)
      (!chain-> [true ==> (x <=L nil) [empty]])
| (z :: M) =>
  pick-any x y
    assume (x <= y & y <=L (z :: M))
      conclude (x <=L (z :: M))
        (!chain-> 
         [(x <= y & y <=L (z :: M))
          ==> (x <= y & y <= z)         [nonempty]
          ==> (x <= z)                  [Less=.transitive]
          ==> (x <=L (z :: M))          [nonempty]])
}

conclude before-all-implies-before-first := (forall L x . (forall y . y in L ==> x <= y) ==> x <=L L)
datatype-cases before-all-implies-before-first {
  nil =>
  pick-any x
    assume (forall y . y in nil ==> x <= y)
      conclude (x <=L nil)
        (!chain-> [true ==> (x <=L nil) [empty]])
| (z:N :: L) =>
  pick-any x
    assume i := (forall y . y in (z :: L) ==> x <= y)
      conclude (x <=L (z :: L))
        (!chain-> [(z = z)                 
                    ==> (z = z | z in L)  [alternate]
		    ==> (z in (z :: L))   [in.nonempty]
		    ==> (x <= z)          [i]
		    ==> (x <=L (z :: L))  [nonempty]])
}

conclude append := (forall L M x . x <=L L & x <=L M ==> x <=L (L join M))
datatype-cases append {
  nil =>
  pick-any M x
    (!chain [(x <=L nil & x <=L M)
	     ==> (x <=L M)              [right-and]
	     ==> (x <=L (nil join M))   [join.left-empty]])
| (u :: N) =>
  pick-any M x
    assume (x <=L (u :: N) & (x <=L M))
      (!chain-> 
       [(x <=L (u :: N))
	==> (x <= u)                  [nonempty]
	==> (x <=L (u :: (N join M))) [nonempty]
	==> (x <=L ((u :: N) join M)) [join.left-nonempty]])
}

conclude head := (forall L x . ordered (x :: L) ==> x <=L L)
  pick-any L x
    (!chain 
     [(ordered (x :: L))
      ==> (x <=L L & ordered L) [nonempty]
      ==> (x <=L L)             [left-and]])

conclude tail := (forall L x . ordered (x :: L) ==> ordered L)
  pick-any L x
    (!chain 
     [(ordered (x :: L))
      ==> (x <=L L & ordered L) [nonempty]
      ==> (ordered L)           [right-and]])

conclude first-to-rest-relation := (forall L x y .  ordered (x :: L) & y in L ==> x <= y)  
by-induction first-to-rest-relation {
  nil =>
  pick-any x:N y:N
    assume i := ((ordered (x :: nil)) & y in nil) 
      let {not-in := (!chain-> 
		      [true ==> (~ y in nil) [in.empty]])}
      (!from-complements (x <= y) (y in nil) not-in)
| (z:N :: M:(List N)) => 
  let {ind-hyp := (forall ?x ?y . 
                    ordered (?x :: M) & ?y in M ==> ?x <= ?y)}
  conclude (forall ?x ?y . 
             ordered (?x :: (z :: M)) & ?y in (z :: M) 
	     ==> ?x <= ?y)
    pick-any x:N y:N
      assume ((ordered (x :: (z :: M))) & y in (z :: M)) 
        let {p0 := 
              (!chain-> 
	       [(ordered (x :: (z :: M)))
		==> (x <=L (z :: M) & ordered (z :: M))
                                   [nonempty]
                ==> (x <=L (z :: M) & z <=L M & ordered M)
                                   [nonempty]
                ==> (x <= z & z <=L M & ordered M)
                                   [<=L.nonempty]]);
             p1 :=
              (!chain-> [p0 ==> (ordered M)   [prop-taut]]);
             p2 := 
              (!chain-> 
	       [p0 ==> (x <= z & z <=L M) [prop-taut]
		   ==> (x <=L M)          [<=L.left-transitive]
		   ==> (x <=L M & ordered M)     [augment]
		   ==> (ordered (x :: M))        [nonempty]]);
             p3 := (!chain-> 
		    [(y in (z :: M)) 
		     ==> (y = z | y in M)  [in.nonempty]])}
        (!cases (y = z | y in M)
           assume (y = z)
             (!chain-> [p0 ==> (x <= z)  [left-and]
			   ==> (x <= y)  [(y = z)]])
             (!chain [(y in M)
                      ==> (p2 & y in M)     [augment]
                      ==> (x <= y)          [ind-hyp]]))
}

conclude cons := (forall L x . ordered L & (forall y . y in L ==> x <= y) ==> ordered (x :: L))
pick-any L x 
    let {p := (forall ?y . ?y in L ==> x <= ?y)}
    assume (ordered L & p)
      (!chain->
       [p ==> (x <=L L) [<=L.before-all-implies-before-first]
          ==> (x <=L L & ordered L    )    [augment]
          ==> (ordered (x :: L))           [nonempty]])

conclude append := (forall L M . ordered L & ordered M & (forall x y . x in L & y in M ==> x <= y) ==> ordered (L join M))
by-induction append {
  nil:(List N) =>
  conclude (forall ?R .
             ordered nil & ordered ?R &
             (forall ?x ?y . ?x in nil & ?y in ?R ==> ?x <= ?y)
             ==> (ordered (nil join ?R)))
    pick-any R
      assume ((ordered nil) & (ordered R) &
              (forall ?x ?y . ?x in nil & ?y in R ==> ?x <= ?y))
        (!chain-> 
         [(ordered R)             
          ==> (ordered (nil join R)) [join.left-empty]])
| (z :: L:(List N)) => 
  let {ind-hyp := 
           (forall ?R .
             ordered L & ordered ?R &
             (forall ?x ?y . ?x in L & ?y in ?R ==> ?x <= ?y)
             ==> (ordered (L join ?R)))}
  conclude
      (forall ?R .
        ordered (z :: L) & ordered ?R &
        (forall ?x ?y . ?x in (z :: L) & ?y in ?R ==> ?x <= ?y)
        ==> (ordered ((z :: L) join ?R)))
    pick-any R:(List N) 
      let {A1 := (ordered (z :: L));
           A2 := (ordered R);
           A3 := (forall ?x ?y . 
                    ?x in (z :: L) & ?y in R ==> ?x <= ?y)}
      assume (A1 & A2 & A3)
        let {C1 :=  (!chain-> 
		     [(ordered (z :: L)) ==> (ordered L)  [tail]]);
             C2 := conclude 
                      (forall ?x ?y . ?x in L & ?y in R ==> ?x <= ?y)
  	             pick-any x:N y:N
	               assume D := (x in L & y in R)
                         (!chain-> 
			  [D ==> (x in (z :: L) & y in R)  [in.tail]
			     ==> (x <= y)                  [A3]]);
             C3 := conclude (ordered (L join R))
                    (!chain-> 
		     [C1 ==> (C1 & (ordered R) & C2) [augment]
		         ==> (ordered (L join R))    [ind-hyp]]);
             C4 := conclude (z <=L R)
                     (!two-cases
		      assume (R = nil)
		      (!chain-> [true ==> (z <=L nil)  [<=L.empty]
			              ==> (z <=L R)    [(R = nil)]])
                      assume (R =/= nil)
                        let {D1 := 
                              conclude (z in (z :: L))
			        (!chain-> 
				 [(z = z)
				  ==> (z = z | z in L)  [alternate]
				  ==> (z in (z :: L))   [in.nonempty]]);
                             D2 := (exists ?u ?M . R = (?u :: ?M));
                             D3 := conclude D2
                                     (!chain-> 
				      [true 
				       ==> (R = nil | D2) 
				               [(datatype-axioms "List")]
				       ==> ((R =/= nil) & (R = nil | D2))   
				                            [augment]
				       ==> D2               [prop-taut]])}
                        pick-witnesses u M for D3
                          (!chain-> 
			   [true 
			    ==> (u in (u :: M))  [in.head]
			    ==> (u in R)         [(R = (u :: M))]
			    ==> (z in (z :: L) & u in R)  [augment]
			    ==> (z <= u)         [A3]
			    ==> (z <=L (u :: M)) [<=L.nonempty]
			    ==> (z <=L R)        [(R = (u :: M))]]))}
          conclude (ordered ((z :: L) join R))
            (!chain-> 
	     [(ordered (z :: L))
	      ==> ((z <=L L) & ordered L)     [nonempty]
	      ==> (z <=L L)                   [left-and]
	      ==> ((z <=L L) & C4)            [augment]
	      ==> (z <=L (L join R))          [<=L.append]
	      ==> (z <=L (L join R) & C3)     [augment]
	      ==> (ordered (z :: (L join R))) [nonempty]
	      ==> (ordered ((z :: L) join R)) [join.left-nonempty]
	      ])
    }